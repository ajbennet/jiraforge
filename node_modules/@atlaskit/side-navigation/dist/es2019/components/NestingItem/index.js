import _extends from "@babel/runtime/helpers/extends";
/**
 * @jsxRuntime classic
 * @jsx jsx
 */
import React, { Fragment, useCallback, useEffect, useMemo, useRef, useState } from 'react';

// eslint-disable-next-line @atlaskit/ui-styling-standard/use-compiled -- Ignored via go/DSP-18766
import { jsx } from '@emotion/react';
import ArrowRightIcon from '@atlaskit/icon/core/migration/arrow-right--arrow-right-circle';
import { fg } from '@atlaskit/platform-feature-flags';
import { Box, xcss } from '@atlaskit/primitives';
import { N10 } from '@atlaskit/theme/colors';
import { overrideStyleFunction } from '../../common/styles';
import { ButtonItem, CustomItem, NavigationContent } from '../index';
import { ROOT_ID } from '../NestableNavigationContent';
import { NestedContext, useNestedContext } from '../NestableNavigationContent/context';
import { useChildIdsEffect } from '../utils/hooks';
import { nestingItemStyle } from './styles';
const iconContainerStyles = xcss({
  display: 'inline'
});

// Doesn't extend from ButtonItemProps because it blows ERT up.

/**
 * NestingItem will render itself differently depending in what context it is rendered in.
 * When not open - it will render itself as an item.
 * When open - it will render its children.
 */
const NestingItem = props => {
  const {
    children,
    iconAfter,
    title,
    onClick,
    cssFn,
    isSelected,
    id,
    component,
    testId,
    ...rest
  } = props;
  const {
    currentStackId,
    onNest,
    onUnNest,
    backButton: contextualBackButton,
    stack,
    childIds,
    forceShowTopScrollIndicator,
    activeParentId,
    goBackButtonRef,
    isDefaultFocusControl,
    focusGoBackButton
  } = useNestedContext();
  const mergedStyles = overrideStyleFunction(nestingItemStyle, cssFn);
  const [isInteracted, setIsInteracted] = useState(false);
  const parentItemRef = useRef(null);

  // To avoid error we need to make sure that the component is wrapped in ForwardRef
  const isForwardRefCheck = component => {
    var _component$prototype;
    if (component !== null && component !== void 0 && (_component$prototype = component.prototype) !== null && _component$prototype !== void 0 && _component$prototype.isReactComponent) {
      return false;
    }
    return (component === null || component === void 0 ? void 0 : component.$$typeof) === Symbol.for('react.forward_ref');
  };
  const shouldFocus = isDefaultFocusControl && fg('platform-side-navigation-keyboard-focus');
  const backButtonRef = shouldFocus ? goBackButtonRef : null;
  const activeParentRef = shouldFocus ? parentItemRef : null;
  useEffect(() => {
    if (shouldFocus) {
      if (activeParentId === id) {
        var _parentItemRef$curren;
        parentItemRef === null || parentItemRef === void 0 ? void 0 : (_parentItemRef$curren = parentItemRef.current) === null || _parentItemRef$curren === void 0 ? void 0 : _parentItemRef$curren.focus();
      }
      if (focusGoBackButton) {
        var _goBackButtonRef$curr;
        goBackButtonRef === null || goBackButtonRef === void 0 ? void 0 : (_goBackButtonRef$curr = goBackButtonRef.current) === null || _goBackButtonRef$curr === void 0 ? void 0 : _goBackButtonRef$curr.focus();
      }
    }
  }, [activeParentId, id, goBackButtonRef, focusGoBackButton, isDefaultFocusControl, shouldFocus]);
  const backButton = props.overrides && props.overrides.GoBackItem && props.overrides.GoBackItem.render && props.overrides.GoBackItem.render({
    onClick: onUnNest,
    testId: testId && `${testId}--go-back-item`,
    ref: backButtonRef
  }) || contextualBackButton;
  const context = useMemo(() => ({
    stack,
    currentStackId,
    onNest,
    onUnNest,
    backButton,
    parentId: id,
    childIds,
    forceShowTopScrollIndicator,
    activeParentId,
    goBackButtonRef,
    isDefaultFocusControl,
    focusGoBackButton
  }), [stack, currentStackId, onNest, onUnNest, backButton, id, childIds, forceShowTopScrollIndicator, activeParentId, goBackButtonRef, isDefaultFocusControl, focusGoBackButton]);
  useChildIdsEffect(childIds, id);
  const isNormalClick = e => !(e.button || e.metaKey || e.altKey || e.ctrlKey || e.shiftKey);

  /**
   * We want both the on nest handler and the onclick handler to be called.
   * We create a wrapper function to call both.
   */
  const onClickHandler = useCallback(e => {
    if (isInteracted) {
      // We return early if this has been interacted with because its assumed
      // this will be already exiting - so we don't want to double up the click.
      return;
    }

    // Avoid a nesting transition if a modifier key is detected during click.
    // @ts-expect-error - Argument of type 'MouseEvent<Element, MouseEvent> | KeyboardEvent<Element>' is not assignable to parameter of type 'MouseEvent'
    if (isNormalClick(e)) {
      setIsInteracted(true);
      onNest(id);
    }
    onClick && onClick(e);
  }, [isInteracted, onClick, onNest, id]);
  if (currentStackId === id) {
    return jsx(NestedContext.Provider, {
      value: context
    }, stack.length >= 1 && jsx(Box, {
      paddingBlock: "space.075",
      paddingInline: "space.100"
    }, backButton), jsx(NavigationContent, {
      testId: testId,
      showTopScrollIndicator: forceShowTopScrollIndicator || stack.length >= 1
    }, children));
  }
  if ([ROOT_ID, ...stack].includes(id)) {
    return children;
  }
  const componentProps = {
    iconAfter: jsx(Fragment, null, iconAfter ? jsx(Box, {
      xcss: iconContainerStyles,
      "data-custom-icon": true,
      as: "span"
    }, iconAfter) : null, jsx(Box, {
      "data-right-arrow": true,
      xcss: iconContainerStyles,
      as: "span"
    }, jsx(ArrowRightIcon, {
      testId: testId && `${testId}--item--right-arrow`,
      color: "currentColor",
      LEGACY_secondaryColor: `var(--ds-surface, ${N10})`,
      label: ""
    }))),
    onClick: onClickHandler,
    isSelected: isSelected,
    testId: testId && `${testId}--item`,
    ...rest,
    children: title,
    cssFn: mergedStyles
  };
  if (component) {
    return jsx(CustomItem, _extends({
      ref: isForwardRefCheck(component) ? parentItemRef : null
    }, componentProps, {
      //@ts-expect-error TODO Fix legit TypeScript 3.9.6 improved inference error
      component: component
    }));
  }
  return jsx(ButtonItem, _extends({
    ref: activeParentRef
  }, componentProps));
};
export default NestingItem;