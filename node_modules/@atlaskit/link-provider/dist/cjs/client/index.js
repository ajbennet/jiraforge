"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.urlResponsePromiseCache = exports.default = void 0;
var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));
var _objectWithoutProperties2 = _interopRequireDefault(require("@babel/runtime/helpers/objectWithoutProperties"));
var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));
var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));
var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _dataloader = _interopRequireDefault(require("dataloader"));
var _asyncRetry = _interopRequireDefault(require("async-retry"));
var _pThrottle = _interopRequireDefault(require("p-throttle"));
var _linkingCommon = require("@atlaskit/linking-common");
var _responses = require("./types/responses");
var _lru_map = require("lru_map");
var _excluded = ["error"];
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { (0, _defineProperty2.default)(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
var MAX_BATCH_SIZE = 50;
var MIN_TIME_BETWEEN_BATCHES = 250;
var URL_RESPONSE_CACHE_SIZE = 100;

// Contains cached mapping between url and a promise of a response.
// Note that promise can be either unsettled/ongoing OR successfully resolved (not an error or non-resolved)
var urlResponsePromiseCache = exports.urlResponsePromiseCache = new _lru_map.LRUMap(URL_RESPONSE_CACHE_SIZE);
var CardClient = exports.default = /*#__PURE__*/function () {
  function CardClient(envKey, baseUrlOverride) {
    var _this = this;
    (0, _classCallCheck2.default)(this, CardClient);
    (0, _defineProperty2.default)(this, "postBatchResolve", /*#__PURE__*/function () {
      var _ref = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee(resources) {
        var _Intl;
        var resourceType,
          deDuplicatedResources,
          resolvedResources,
          headers,
          map,
          i,
          resource,
          data,
          _args = arguments;
        return _regenerator.default.wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              resourceType = _args.length > 1 && _args[1] !== undefined ? _args[1] : 'URL';
              // De-duplicate requested URLs (see `this.createLoader` for more detail).
              // Also de-duplicate requested ARIs as backend does not de-duplicate any requests.
              deDuplicatedResources = (0, _toConsumableArray2.default)(new Set(resources));
              resolvedResources = [];
              headers = _objectSpread({
                /**
                 * This header exist to enable the backend to process relative time, eg: "today", with respect to the user timezone.
                 * eg: used in "confluence-object-provider" to resolve confluence SLLV links that may involve relative time calculation.
                 */
                'origin-timezone': (_Intl = Intl) === null || _Intl === void 0 ? void 0 : _Intl.DateTimeFormat().resolvedOptions().timeZone
              }, _this.product ? {
                'X-Product': _this.product
              } : {});
              _context.prev = 4;
              if (!(resourceType === 'URL')) {
                _context.next = 9;
                break;
              }
              _context.next = 8;
              return (0, _linkingCommon.request)('post', "".concat(_this.resolverUrl, "/resolve/batch"), deDuplicatedResources.map(function (resourceUrl) {
                return {
                  resourceUrl: resourceUrl
                };
              }), headers);
            case 8:
              resolvedResources = _context.sent;
            case 9:
              if (!(resourceType === 'ARI')) {
                _context.next = 13;
                break;
              }
              _context.next = 12;
              return (0, _linkingCommon.request)('post', "".concat(_this.resolverUrl, "/resolve/ari/batch"), deDuplicatedResources.map(function (ari) {
                return {
                  ari: ari
                };
              }), headers);
            case 12:
              resolvedResources = _context.sent;
            case 13:
              _context.next = 18;
              break;
            case 15:
              _context.prev = 15;
              _context.t0 = _context["catch"](4);
              // we make sure we return a valid dataloader response by creating an error
              // response for each url/ari
              resolvedResources = resources.map(function () {
                // @ts-ignore
                var status = (0, _responses.isErrorResponse)(_context.t0) ? _context.t0.status : 500;
                var errorResponse = {
                  status: status,
                  // @ts-ignore
                  error: _context.t0
                };
                return errorResponse;
              });
            case 18:
              // Reduce into a map to make accessing faster and easier.
              map = {}; // NOTE: the batch endpoint returns the URLs/ARIs in the same order they were given.
              for (i = 0; i < deDuplicatedResources.length; ++i) {
                resource = deDuplicatedResources[i];
                data = resolvedResources[i];
                map[resource] = data;
              }

              // Reconvert list back into the original order in which it was given to us.
              return _context.abrupt("return", resources.map(function (originalResource) {
                return map[originalResource];
              }));
            case 21:
            case "end":
              return _context.stop();
          }
        }, _callee, null, [[4, 15]]);
      }));
      return function (_x) {
        return _ref.apply(this, arguments);
      };
    }());
    // Endpoint for batch resolve url
    (0, _defineProperty2.default)(this, "batchResolve", /*#__PURE__*/function () {
      var _ref2 = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee2(urls) {
        return _regenerator.default.wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              return _context2.abrupt("return", _this.postBatchResolve(urls, 'URL'));
            case 1:
            case "end":
              return _context2.stop();
          }
        }, _callee2);
      }));
      return function (_x2) {
        return _ref2.apply(this, arguments);
      };
    }());
    // Endpoint for batch resolve ari
    (0, _defineProperty2.default)(this, "batchResolveAris", /*#__PURE__*/function () {
      var _ref3 = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee3(aris) {
        return _regenerator.default.wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              return _context3.abrupt("return", _this.postBatchResolve(aris, 'ARI'));
            case 1:
            case "end":
              return _context3.stop();
          }
        }, _callee3);
      }));
      return function (_x3) {
        return _ref3.apply(this, arguments);
      };
    }());
    this.resolverUrl = (0, _linkingCommon.getResolverUrl)(envKey, baseUrlOverride);
    this.loadersByDomain = {};
    this.retryConfig = {
      retries: 2
    };
    this.resolvedCache = {};
    this.envKey = envKey;
    this.baseUrlOverride = baseUrlOverride;
  }
  return (0, _createClass2.default)(CardClient, [{
    key: "setProduct",
    value: function setProduct(product) {
      this.product = product;
    }
  }, {
    key: "createLoader",
    value: function createLoader() {
      var batchResolveThrottler = (0, _pThrottle.default)({
        limit: 1,
        interval: MIN_TIME_BETWEEN_BATCHES
      });
      var throttledBatchResolve = batchResolveThrottler(this.batchResolve);
      return new _dataloader.default(
      // We place all calls to `batchResolve` in a limiter so we don't send off several simultaneous batch requests.
      // This is for two reasons:
      //  1: we want to avoid getting rate limited upstream (eg: forge and other APIs)
      //  2: we want to avoid sending out heaps of requests from the client at once
      function (urls) {
        return throttledBatchResolve(urls);
      }, {
        maxBatchSize: MAX_BATCH_SIZE,
        // NOTE: we turn off DataLoader's cache because it doesn't work for our use-case. Consider the following:
        // - a smartlink to a restricted item is resolved to "forbidden" with a "request access button"
        // - the user clicks "request access", and then following the auth prompts and gets access
        // - the frontend now re-renders the smartlink, but due to DataLoader's caching, the previous "forbidden" state is
        //   because the smartlink's URL (which is the cache key) is exactly the same
        //
        // For this reason, we disable DataLoader's cache.
        // This means that URLs will not be de-duplicated by DataLoader, so we perform the de-duplication logic
        // ourselves in `this.batchResolve`.
        cache: false
      });
    }
  }, {
    key: "getLoader",
    value: function getLoader(hostname) {
      if (!this.loadersByDomain[hostname]) {
        this.loadersByDomain[hostname] = this.createLoader();
      }
      return this.loadersByDomain[hostname];
    }
  }, {
    key: "resolveUrl",
    value: function () {
      var _resolveUrl = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee4(url) {
        var force,
          hostname,
          loader,
          responsePromise,
          response,
          isUnresolvedLink,
          _args4 = arguments;
        return _regenerator.default.wrap(function _callee4$(_context4) {
          while (1) switch (_context4.prev = _context4.next) {
            case 0:
              force = _args4.length > 1 && _args4[1] !== undefined ? _args4[1] : false;
              hostname = new URL(url).hostname;
              loader = this.getLoader(hostname);
              responsePromise = urlResponsePromiseCache.get(url);
              if (!responsePromise || force) {
                responsePromise = loader.load(url);
                urlResponsePromiseCache.set(url, responsePromise);
              }
              _context4.prev = 5;
              _context4.next = 8;
              return responsePromise;
            case 8:
              response = _context4.sent;
              _context4.next = 15;
              break;
            case 11:
              _context4.prev = 11;
              _context4.t0 = _context4["catch"](5);
              // Technically this never happens, since batchResolve handles errors and doesn't throw,
              // But just in case.
              urlResponsePromiseCache.delete(url);
              throw _context4.t0;
            case 15:
              isUnresolvedLink = !(0, _responses.isSuccessfulResponse)(response) || (0, _linkingCommon.getStatus)(response.body) !== 'resolved';
              if (isUnresolvedLink) {
                // We want consequent calls for fetchData() to cause actual http call
                urlResponsePromiseCache.delete(url);
              }
              return _context4.abrupt("return", response);
            case 18:
            case "end":
              return _context4.stop();
          }
        }, _callee4, this, [[5, 11]]);
      }));
      function resolveUrl(_x4) {
        return _resolveUrl.apply(this, arguments);
      }
      return resolveUrl;
    }()
  }, {
    key: "prefetchData",
    value: function () {
      var _prefetchData = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee6(url) {
        var _this2 = this;
        var response, retriedResponse;
        return _regenerator.default.wrap(function _callee6$(_context6) {
          while (1) switch (_context6.prev = _context6.next) {
            case 0:
              _context6.next = 2;
              return this.resolveUrl(url, false);
            case 2:
              response = _context6.sent;
              if (!(0, _responses.isSuccessfulResponse)(response)) {
                _context6.next = 7;
                break;
              }
              return _context6.abrupt("return", response.body);
            case 7:
              _context6.prev = 7;
              _context6.next = 10;
              return (0, _asyncRetry.default)( /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee5() {
                var _response;
                return _regenerator.default.wrap(function _callee5$(_context5) {
                  while (1) switch (_context5.prev = _context5.next) {
                    case 0:
                      if (_this2.resolvedCache[url]) {
                        _context5.next = 11;
                        break;
                      }
                      _context5.next = 3;
                      return _this2.resolveUrl(url, false);
                    case 3:
                      _response = _context5.sent;
                      if (!(0, _responses.isSuccessfulResponse)(_response)) {
                        _context5.next = 8;
                        break;
                      }
                      return _context5.abrupt("return", _response);
                    case 8:
                      throw new Error('Retry for URL failed');
                    case 9:
                      _context5.next = 12;
                      break;
                    case 11:
                      throw new Error('Retry unneeded - link has been resolved.');
                    case 12:
                    case "end":
                      return _context5.stop();
                  }
                }, _callee5);
              })), this.retryConfig);
            case 10:
              retriedResponse = _context6.sent;
              return _context6.abrupt("return", retriedResponse.body);
            case 14:
              _context6.prev = 14;
              _context6.t0 = _context6["catch"](7);
              return _context6.abrupt("return", undefined);
            case 17:
            case "end":
              return _context6.stop();
          }
        }, _callee6, this, [[7, 14]]);
      }));
      function prefetchData(_x5) {
        return _prefetchData.apply(this, arguments);
      }
      return prefetchData;
    }()
  }, {
    key: "isRateLimitError",
    value: function isRateLimitError(response) {
      return (0, _responses.isErrorResponse)(response) && response.error.status === 429;
    }

    // Fetch data from URL
  }, {
    key: "fetchData",
    value: function () {
      var _fetchData = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee8(url, force) {
        var _this3 = this;
        var response;
        return _regenerator.default.wrap(function _callee8$(_context8) {
          while (1) switch (_context8.prev = _context8.next) {
            case 0:
              _context8.next = 2;
              return this.resolveUrl(url, force);
            case 2:
              response = _context8.sent;
              if (!this.isRateLimitError(response)) {
                _context8.next = 7;
                break;
              }
              _context8.next = 6;
              return (0, _asyncRetry.default)( /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee7() {
                var retryResponse;
                return _regenerator.default.wrap(function _callee7$(_context7) {
                  while (1) switch (_context7.prev = _context7.next) {
                    case 0:
                      _context7.next = 2;
                      return _this3.resolveUrl(url, false);
                    case 2:
                      retryResponse = _context7.sent;
                      if (!_this3.isRateLimitError(retryResponse)) {
                        _context7.next = 5;
                        break;
                      }
                      throw _this3.mapErrorResponse(retryResponse, new URL(url).hostname);
                    case 5:
                      return _context7.abrupt("return", retryResponse);
                    case 6:
                    case "end":
                      return _context7.stop();
                  }
                }, _callee7);
              })), this.retryConfig);
            case 6:
              response = _context8.sent;
            case 7:
              if ((0, _responses.isSuccessfulResponse)(response)) {
                _context8.next = 9;
                break;
              }
              throw this.mapErrorResponse(response, new URL(url).hostname);
            case 9:
              // Set a flag in the `resolvedCache` for this URL. The intent of this is
              // to ensure that the exponential backoff method in `prefetchData` does
              // not continue to retry fetching for this URL, especially if it was previously
              // in a failed state. Note: this scenario only occurs on initial page load, if the
              // user scrolls through the page very fast. Once the URL is visible, prefetching
              // no longer takes place.
              this.resolvedCache[url] = true;
              // Return the JSON-LD response back up!
              return _context8.abrupt("return", response.body);
            case 11:
            case "end":
              return _context8.stop();
          }
        }, _callee8, this);
      }));
      function fetchData(_x6, _x7) {
        return _fetchData.apply(this, arguments);
      }
      return fetchData;
    }()
    /**
     * Fetch data for multiple ARIs (batch) in one operation
     * @param aris Array of ARIs to fetch data for
     */
  }, {
    key: "fetchDataAris",
    value: (function () {
      var _fetchDataAris = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee9(aris) {
        return _regenerator.default.wrap(function _callee9$(_context9) {
          while (1) switch (_context9.prev = _context9.next) {
            case 0:
              _context9.next = 2;
              return this.batchResolveAris(aris);
            case 2:
              return _context9.abrupt("return", _context9.sent);
            case 3:
            case "end":
              return _context9.stop();
          }
        }, _callee9, this);
      }));
      function fetchDataAris(_x8) {
        return _fetchDataAris.apply(this, arguments);
      }
      return fetchDataAris;
    }())
  }, {
    key: "postData",
    value: function () {
      var _postData = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee10(data) {
        var requestData;
        return _regenerator.default.wrap(function _callee10$(_context10) {
          while (1) switch (_context10.prev = _context10.next) {
            case 0:
              requestData = {
                key: data.key,
                action: data.action,
                context: data.context
              };
              _context10.next = 3;
              return (0, _linkingCommon.request)('post', "".concat(this.resolverUrl, "/invoke"), requestData);
            case 3:
              return _context10.abrupt("return", _context10.sent);
            case 4:
            case "end":
              return _context10.stop();
          }
        }, _callee10, this);
      }));
      function postData(_x9) {
        return _postData.apply(this, arguments);
      }
      return postData;
    }()
    /**
     * Make request to the Search endpoint See `InvocationRequest` in ORS openapi.yaml for backend
     * spec.
     * @param data Payload including the search provider key and query. An empty search query string
     * results in recent results being returned (pre-query).
     * @returns JsonLd collection of search results.
     */
  }, {
    key: "search",
    value: (function () {
      var _search = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee11(data) {
        var key, action, query, context, requestData, response;
        return _regenerator.default.wrap(function _callee11$(_context11) {
          while (1) switch (_context11.prev = _context11.next) {
            case 0:
              key = data.key, action = data.action; // Note: context in action is different to context in data, see types.
              query = action.query, context = action.context;
              requestData = {
                key: key,
                search: {
                  query: query,
                  context: context
                }
              };
              _context11.next = 5;
              return (0, _linkingCommon.request)('post', "".concat(this.resolverUrl, "/invoke/search"), requestData);
            case 5:
              response = _context11.sent;
              if (!(0, _responses.isErrorResponse)(response)) {
                _context11.next = 8;
                break;
              }
              throw this.mapErrorResponse(response);
            case 8:
              return _context11.abrupt("return", response);
            case 9:
            case "end":
              return _context11.stop();
          }
        }, _callee11, this);
      }));
      function search(_x10) {
        return _search.apply(this, arguments);
      }
      return search;
    }())
  }, {
    key: "fetchAvailableSearchProviders",
    value: function () {
      var _fetchAvailableSearchProviders = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee12() {
        var response;
        return _regenerator.default.wrap(function _callee12$(_context12) {
          while (1) switch (_context12.prev = _context12.next) {
            case 0:
              _context12.next = 2;
              return (0, _linkingCommon.request)('post', "".concat(this.resolverUrl, "/providers"), {
                type: 'search'
              });
            case 2:
              response = _context12.sent;
              return _context12.abrupt("return", response.providers);
            case 4:
            case "end":
              return _context12.stop();
          }
        }, _callee12, this);
      }));
      function fetchAvailableSearchProviders() {
        return _fetchAvailableSearchProviders.apply(this, arguments);
      }
      return fetchAvailableSearchProviders;
    }()
  }, {
    key: "mapErrorResponse",
    value: function mapErrorResponse(response) {
      var hostname = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
      // Catch non-200 server responses to fallback or return useful information.
      if (response !== null && response !== void 0 && response.error) {
        var errorType = response.error.type;
        var errorMessage = response.error.message;
        var extensionKey = response.error.extensionKey;
        // this means there was a network error and we fallback to blue link
        // without impacting SLO's
        if (response.error instanceof _linkingCommon.NetworkError) {
          return new _linkingCommon.APIError('fallback', hostname, errorMessage, errorType);
        }
        switch (errorType) {
          // BadRequestError - indicative of an API error, render
          // a blue link to mitigate customer impact.
          case 'ResolveBadRequestError':
          case 'SearchBadRequestError':
          case 'BadRequestError':
            return new _linkingCommon.APIError('fallback', hostname, errorMessage, errorType, extensionKey);
          // AuthError - if the user logs in, we may be able
          // to recover. Render an unauthorized card.
          case 'ResolveAuthError':
          case 'SearchAuthError':
          case 'AuthError':
            return new _linkingCommon.APIError('auth', hostname, errorMessage, errorType, extensionKey);
          // UnsupportedError - we do not know how to render this URL.
          // Bail out and ask the Editor to render as a blue link.
          case 'ResolveUnsupportedError': // URL isn't supported
          case 'SearchUnsupportedError': // Search isn't supported
          case 'UnsupportedError':
            // URL isn't supported
            return new _linkingCommon.APIError('fatal', hostname, errorMessage, errorType, extensionKey);
          case 'ResolveFailedError': // Failed
          case 'SearchFailedError':
          case 'ResolveTimeoutError': // Timeouts
          case 'SearchTimeoutError':
          case 'SearchRateLimitError': //Rate Limit Error
          case 'ResolveRateLimitError':
          case 'InternalServerError': // ORS failures
          case 'TimeoutError':
          case 'RateLimitError':
            return new _linkingCommon.APIError('error', hostname, errorMessage, errorType, extensionKey);
        }
      }
      // Catch all: we don't know this error, bail out.
      var _ref6 = response || {},
        error = _ref6.error,
        rest = (0, _objectWithoutProperties2.default)(_ref6, _excluded);
      return new _linkingCommon.APIError('fatal', hostname,
      // reason we stringify the error differently is because
      // JSON.stringify will return "{}" if it is an instance of Error
      // e.g. JSON.stringify(new Error('something went wrong')) will return '{}'
      // reason is JSON.stringify method only serializes enumerable properties but properties like "message" and "stack" are non enumerable
      // e.g. https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error/message
      // more info here https://stackoverflow.com/questions/18391212/is-it-not-possible-to-stringify-an-error-using-json-stringify
      // we assume 'rest'  to "serializable" meaning all its properties are enumerable
      response ? "".concat(this.stringifyError(error), " ").concat(JSON.stringify(rest)) : 'Response undefined', 'UnexpectedError');
    }

    /**
     * This method will strigify both enumerable and  non enumerable properties of an object
     * @param err
     * @returns object serialized to JSON with both enumerable and non enumerable objects
     */
  }, {
    key: "stringifyError",
    value: function stringifyError(err) {
      /**
       * By default JSON.stringify only serializes enumerable properties of an object. In order for us to
       * serialize non enumerable properties out of an error we need to expclitily provide the non enumerable property names.
       * the second parameter to JSON.stringify gets the properties that will be serialized from the object passed in the first argument
       * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyNames
       */
      return JSON.stringify(err,
      //In ES5, if the argument to getOwnPropertyNames method is not an object (a primitive), then it will cause a TypeError
      (0, _typeof2.default)(err) === 'object' ? Object.getOwnPropertyNames(err) : undefined);
    }
  }]);
}();