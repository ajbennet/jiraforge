let config;
const DEFAULT_TTVC_REVISION = 'fy25.02';

// Defensively typed, since this is directly user-editable
// and they could delete empty members

export function setUFOConfig(newConfig) {
  var _newConfig$vc;
  // Handle edge cases with `enabledVCRevisions`
  const {
    enabledVCRevisions
  } = (_newConfig$vc = newConfig === null || newConfig === void 0 ? void 0 : newConfig.vc) !== null && _newConfig$vc !== void 0 ? _newConfig$vc : {};
  if (typeof (enabledVCRevisions === null || enabledVCRevisions === void 0 ? void 0 : enabledVCRevisions.byExperience) === 'object') {
    config = {
      ...newConfig,
      vc: {
        ...newConfig.vc,
        enabledVCRevisions: {
          // enforce axiom about `enabledVCRevisions.all` config
          all: Array.from(new Set([DEFAULT_TTVC_REVISION, ...(enabledVCRevisions === null || enabledVCRevisions === void 0 ? void 0 : enabledVCRevisions.all), ...Object.values(enabledVCRevisions === null || enabledVCRevisions === void 0 ? void 0 : enabledVCRevisions.byExperience).flat()])),
          byExperience: {
            ...(enabledVCRevisions === null || enabledVCRevisions === void 0 ? void 0 : enabledVCRevisions.byExperience)
          }
        }
      }
    };
  } else {
    config = newConfig;
  }
}
export function getConfig() {
  return config;
}
const isValidConfigArray = array => {
  return Array.isArray(array) && array.length > 0;
};
export function getEnabledVCRevisions(experienceKey = '') {
  try {
    var _config$vc;
    if (!config) {
      return [];
    }
    if ((_config$vc = config.vc) !== null && _config$vc !== void 0 && _config$vc.enabled) {
      var _config$vc2, _enabledVCRevisions$b;
      const {
        enabledVCRevisions
      } = (_config$vc2 = config.vc) !== null && _config$vc2 !== void 0 ? _config$vc2 : {};
      if (isValidConfigArray(enabledVCRevisions === null || enabledVCRevisions === void 0 ? void 0 : (_enabledVCRevisions$b = enabledVCRevisions.byExperience) === null || _enabledVCRevisions$b === void 0 ? void 0 : _enabledVCRevisions$b[experienceKey])) {
        var _enabledVCRevisions$b2;
        return (_enabledVCRevisions$b2 = enabledVCRevisions.byExperience) === null || _enabledVCRevisions$b2 === void 0 ? void 0 : _enabledVCRevisions$b2[experienceKey];
      }
      if (isValidConfigArray(enabledVCRevisions === null || enabledVCRevisions === void 0 ? void 0 : enabledVCRevisions.all)) {
        return enabledVCRevisions.all;
      }
      return [DEFAULT_TTVC_REVISION];
    }
    return [];
  } catch {
    return [];
  }
}
export function isVCRevisionEnabled(revision, experienceKey) {
  return getEnabledVCRevisions(experienceKey).includes(revision);
}
export function getMostRecentVCRevision(experienceKey = '') {
  const enabledVCRevisions = getEnabledVCRevisions(experienceKey);
  return enabledVCRevisions[enabledVCRevisions.length - 1];
}
export function getInteractionRate(name, interactionKind) {
  try {
    if (!config) {
      return 0;
    }
    const {
      killswitch,
      rates,
      rules,
      kind,
      autoGeneratedRate
    } = config;
    if (killswitch != null) {
      // Specifically kill certain events
      if (killswitch.includes(name)) {
        return 0;
      }
    }
    if (rates != null) {
      // Decide the rate explicitly
      if (rates[name] != null) {
        return rates[name];
      }
    }
    if (rules != null) {
      for (let i = 0; i < rules.length; i++) {
        const rule = rules[i];
        const {
          test,
          rate
        } = rule;
        if (test != null && rate != null) {
          const regexp = new RegExp(test, 'ig');
          if (regexp.test(name)) {
            return rate;
          }
        }
      }
    }
    const isAutogenerated = name === null || name === void 0 ? void 0 : name.startsWith('auto-generated');
    if (isAutogenerated) {
      const rate = autoGeneratedRate;
      if (rate != null) {
        return rate;
      }
    }
    if (kind != null) {
      const rate = kind[interactionKind];
      if (rate != null) {
        return rate;
      }
    }
    return 0;
  } catch (e) {
    // Fallback
    return 0;
  }
}
export function getExperimentalInteractionRate(name, interactionType) {
  try {
    if (!config) {
      return 0;
    }
    const {
      experimentalInteractionMetrics
    } = config;
    if (!(experimentalInteractionMetrics !== null && experimentalInteractionMetrics !== void 0 && experimentalInteractionMetrics.enabled)) {
      return 0;
    }
    if (experimentalInteractionMetrics.rates && typeof experimentalInteractionMetrics.rates[name] === 'number') {
      return experimentalInteractionMetrics.rates[name];
    }
    if (experimentalInteractionMetrics.kind && typeof experimentalInteractionMetrics.kind[interactionType] === 'number') {
      return experimentalInteractionMetrics.kind[interactionType];
    }
    return 0;
  } catch (e) {
    return 0;
  }
}
export function getPostInteractionRate(name, interactionType) {
  try {
    if (!config) {
      return 0;
    }
    const {
      postInteractionLog
    } = config;
    if (!(postInteractionLog !== null && postInteractionLog !== void 0 && postInteractionLog.enabled)) {
      return 0;
    }
    if (postInteractionLog.rates && typeof postInteractionLog.rates[name] === 'number') {
      return postInteractionLog.rates[name];
    }
    if (postInteractionLog.kind && typeof postInteractionLog.kind[interactionType] === 'number') {
      return postInteractionLog.kind[interactionType];
    }
    return 0;
  } catch (e) {
    return 0;
  }
}
export function getCapabilityRate(capability) {
  try {
    if (!config) {
      return 0;
    }
    const {
      capability: capabilityRate
    } = config;
    if (capabilityRate != null) {
      const rate = capabilityRate[capability];
      if (rate != null) {
        return rate;
      }
    }
    return 0;
  } catch {
    return 0;
  }
}
const validTypingMethods = ['timeout', 'timeoutNoAlloc', 'mutationObserver'];
export function getTypingPerformanceTracingMethod() {
  const defaultMethod = 'timeout';
  try {
    if (!config) {
      return defaultMethod;
    }
    const {
      typingMethod
    } = config;
    if (typingMethod != null && validTypingMethods.find(m => m === typingMethod)) {
      return typingMethod;
    } else {
      return defaultMethod;
    }
  } catch (e) {
    return defaultMethod;
  }
}

// Will ask UFO to wait for BM3 TTI for all events on this list
export function getAwaitBM3TTIList() {
  try {
    if (!config) {
      return [];
    }
    const {
      awaitBM3TTI
    } = config;
    if (awaitBM3TTI != null) {
      return awaitBM3TTI;
    } else {
      return [];
    }
  } catch (e) {
    return [];
  }
}

// Flag to remove ufo segments prefixes
export function getRemovePageSegmentsUFOPrefixes() {
  try {
    if (!config) {
      return false;
    }
    const {
      removePageSegmentsUFOPrefixes
    } = config;
    if (removePageSegmentsUFOPrefixes != null) {
      return removePageSegmentsUFOPrefixes;
    } else {
      return false;
    }
  } catch (e) {
    return false;
  }
}

// Flag to remove ufo segments prefixes
export function getRemoveInteractionsUFOPrefixes() {
  try {
    if (!config) {
      return false;
    }
    const {
      removeInteractionsUFOPrefixes
    } = config;
    if (removeInteractionsUFOPrefixes != null) {
      return removeInteractionsUFOPrefixes;
    } else {
      return false;
    }
  } catch (e) {
    return false;
  }
}

// Will ask UFO to override ufoName => experienceKey to the apdex key
// This is to cover use cases where one rUFO route is split into multiple BM3 keys (1:N)
// This workaround should only be used as last resource,
// when we find router limitations preventing teams from splliting these routes
export function getUfoNameOverrides() {
  try {
    if (!config) {
      return undefined;
    }
    const {
      ufoNameOverrides
    } = config;
    if (ufoNameOverrides != null) {
      return ufoNameOverrides;
    }
    return undefined;
  } catch (e) {
    return undefined;
  }
}

// Contains the list of interactions that do not abort existing known interactions
export function getDoNotAbortActivePressInteraction() {
  try {
    if (!config) {
      return undefined;
    }
    const {
      doNotAbortActivePressInteraction
    } = config;
    return doNotAbortActivePressInteraction;
  } catch (e) {
    return undefined;
  }
}

// Contains the list of interactions that do not abort on transitions
export function getDoNotAbortActivePressInteractionOnTransition() {
  try {
    if (!config) {
      return undefined;
    }
    const {
      doNotAbortActivePressInteractionOnTransition
    } = config;
    return doNotAbortActivePressInteractionOnTransition;
  } catch (e) {
    return undefined;
  }
}