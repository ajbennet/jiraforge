import _defineProperty from "@babel/runtime/helpers/defineProperty";
import { fg } from '@atlaskit/platform-feature-flags';
import { isVCRevisionEnabled } from '../../config';
import { getActiveInteraction } from '../../interaction-metrics';
import { attachAbortListeners } from './attachAbortListeners';
import { getVCRevisionDebugDetails } from './getVCRevisionDebugDetails';
import { getVCRevisionsData } from './getVCRevisionsData';
import { getViewportHeight, getViewportWidth } from './getViewport';
import { Observers } from './observers';
const abortReason = {
  scroll: 'scroll',
  keypress: 'keypress',
  resize: 'resize',
  error: 'error'
};
const UNUSED_SECTOR = 0;
function filterComponentsLog(log) {
  return Object.fromEntries(Object.entries(log).map(([timestamp, entries]) => [Number(timestamp), entries.map(entry => {
    const {
      __debug__element,
      ...rest
    } = entry;
    return rest;
  })]));
}
export class VCObserver {
  constructor(options) {
    /* abort logic */
    _defineProperty(this, "abortReason", {
      reason: null,
      info: '',
      timestamp: -1,
      blocking: false
    });
    _defineProperty(this, "outOfBoundaryInfo", '');
    _defineProperty(this, "viewport", {
      w: 0,
      h: 0
    });
    /* heatmap */
    _defineProperty(this, "arraySize", 0);
    _defineProperty(this, "componentsLog", {});
    _defineProperty(this, "vcRatios", {});
    _defineProperty(this, "active", false);
    _defineProperty(this, "totalTime", 0);
    _defineProperty(this, "startTime", 0);
    _defineProperty(this, "_startMeasureTimestamp", -1);
    _defineProperty(this, "ssr", {
      reactRendered: -1
    });
    _defineProperty(this, "unbind", []);
    _defineProperty(this, "getAbortReasonInfo", () => {
      if (this.abortReason.reason === null) {
        return null;
      }
      const info = this.abortReason.info !== '' ? ` ${this.abortReason.info}` : '';
      return `${this.abortReason.reason}${info}`;
    });
    _defineProperty(this, "getVCRawData", () => {
      this.measureStart();
      if (!this.active) {
        this.measureStop();
        return null;
      }
      this.stop();
      const abortReasonInfo = this.getAbortReasonInfo();
      this.measureStop();
      return {
        abortReasonInfo,
        abortReason: {
          ...this.abortReason
        },
        heatmap: this.heatmap,
        heatmapNext: this.heatmapNext,
        outOfBoundaryInfo: this.outOfBoundaryInfo,
        totalTime: Math.round(this.totalTime + this.observers.getTotalTime()),
        componentsLog: {
          ...this.componentsLog
        },
        viewport: {
          ...this.viewport
        },
        oldDomUpdatesEnabled: this.oldDomUpdatesEnabled,
        devToolsEnabled: this.devToolsEnabled,
        ratios: this.vcRatios
      };
    });
    _defineProperty(this, "getVCResult", async ({
      start,
      stop,
      tti,
      prefix,
      ssr,
      vc,
      isEventAborted,
      experienceKey,
      interactionId,
      includeSSRRatio
    }) => {
      const startTime = performance.now();
      // add local measurement
      const fullPrefix = prefix !== undefined && prefix !== '' ? `${prefix}:` : '';
      const rawData = vc !== undefined ? vc : this.getVCRawData();
      if (rawData === null) {
        return {};
      }
      const {
        abortReason,
        abortReasonInfo,
        heatmap,
        heatmapNext,
        outOfBoundaryInfo,
        totalTime,
        componentsLog,
        viewport,
        devToolsEnabled,
        ratios
      } = rawData;
      const isTTVCv1Disabled = !isVCRevisionEnabled('fy25.01', experienceKey);
      if (abortReasonInfo !== null) {
        // exposing data to devtools
        try {
          if (devToolsEnabled && !this.isPostInteraction) {
            window.__vcNotAvailableReason = abortReasonInfo;
          }
        } catch (e) {}
        const vcAbortedResultWithRevisions = {
          [`${fullPrefix}vc:state`]: false,
          [`${fullPrefix}vc:abort:reason`]: abortReason.reason,
          [`${fullPrefix}vc:abort:timestamp`]: abortReason.timestamp,
          [`${fullPrefix}vc:rev`]: [{
            revision: 'fy25.02',
            clean: false,
            'metric:vc90': null,
            abortReason: abortReason.reason
          }]
        };
        if (!isTTVCv1Disabled) {
          vcAbortedResultWithRevisions[`${fullPrefix}vc:rev`].push({
            revision: 'fy25.01',
            clean: false,
            'metric:vc90': null,
            abortReason: abortReason.reason
          });
        }
        return vcAbortedResultWithRevisions;
      }
      const ttvcV1Result = isTTVCv1Disabled ? {
        VC: {},
        VCBox: {},
        VCEntries: {
          abs: [],
          rel: [],
          speedIndex: -1
        },
        totalPainted: -1
      } : VCObserver.calculateVC({
        heatmap,
        ssr,
        componentsLog: {
          ...componentsLog
        },
        viewport,
        fixSSRAttribution: includeSSRRatio
      });
      const {
        VC,
        VCBox,
        VCEntries,
        totalPainted
      } = ttvcV1Result;
      const _componentsLog = {};
      Object.entries(this.componentsLog).forEach(([_timestamp, value]) => {
        const timestamp = Number(_timestamp);
        if (stop > timestamp) {
          _componentsLog[timestamp] = value;
        }
      });
      const vcNext = VCObserver.calculateVC({
        heatmap: heatmapNext,
        ssr,
        componentsLog: _componentsLog,
        viewport,
        fixSSRAttribution: includeSSRRatio
      });
      try {
        if (!this.isPostInteraction) {
          VCObserver.VCParts.forEach(key => {
            if (isTTVCv1Disabled) {
              const duration = vcNext.VC[key];
              if (duration !== null && duration !== undefined) {
                performance.measure(`VC${key}`, {
                  start,
                  duration
                });
                performance.measure(`VC_Next${key}`, {
                  start,
                  duration
                });
              }
            } else {
              const ttvcV1duration = VC[key];
              if (ttvcV1duration !== null && ttvcV1duration !== undefined) {
                performance.measure(`VC${key}`, {
                  start,
                  duration: ttvcV1duration
                });
              }
              const ttvcV2duration = vcNext.VC[key];
              if (ttvcV2duration !== null && ttvcV2duration !== undefined) {
                performance.measure(`VC_Next${key}`, {
                  start,
                  duration: ttvcV2duration
                });
              }
            }
          });
        }
      } catch (e) {
        /* empty */
      }
      const outOfBoundary = outOfBoundaryInfo ? {
        [`${fullPrefix}vc:oob`]: outOfBoundaryInfo
      } : {};
      //const oldDomUpdates = oldDomUpdatesEnabled ? { [`${fullPrefix}vc:old:dom`]: vcNext.VCBox } : {};

      const stopTime = performance.now();

      // exposing data to devtools
      try {
        if (!this.isPostInteraction && devToolsEnabled) {
          const ttvcV1DevToolInfo = isTTVCv1Disabled ? undefined : {
            entries: VCEntries.rel,
            log: componentsLog,
            metrics: {
              '75': VC['75'],
              '80': VC['80'],
              '85': VC['85'],
              '90': VC['90'],
              '95': VC['95'],
              '98': VC['98'],
              '99': VC['99'],
              tti,
              ttai: stop - start
            },
            start,
            stop,
            heatmap,
            ratios
          };
          const ttvcV2DevToolInfo = {
            entries: vcNext.VCEntries.rel,
            log: componentsLog,
            metrics: {
              '75': vcNext.VC['75'],
              '80': vcNext.VC['80'],
              '85': vcNext.VC['85'],
              '90': vcNext.VC['90'],
              '95': vcNext.VC['95'],
              '98': vcNext.VC['98'],
              '99': vcNext.VC['99'],
              tti,
              ttai: stop - start
            },
            start,
            stop,
            heatmap: heatmapNext,
            ratios
          };
          if (isTTVCv1Disabled) {
            window.__vc = ttvcV2DevToolInfo;
            window.__vcNext = ttvcV2DevToolInfo;
          } else {
            window.__vc = ttvcV1DevToolInfo;
            window.__vcNext = ttvcV2DevToolInfo;
          }

          // Emitting a custom event to make it available in the Chrome extension
          window.dispatchEvent(new CustomEvent('vcReady', {
            detail: {
              log: filterComponentsLog(componentsLog),
              entries: isTTVCv1Disabled ? vcNext.VCEntries.rel : VCEntries.rel
            }
          }));

          // Add devtool callback for both v1 and v2
          if (typeof window.__ufo_devtool_onVCRevisionReady__ === 'function' && fg('platform_ufo_ttvc_v3_devtool')) {
            var _ufo_devtool_onVCRev2, _ref2;
            // Handle v1 if not disabled
            if (!isTTVCv1Disabled) {
              var _ufo_devtool_onVCRev, _ref;
              (_ufo_devtool_onVCRev = (_ref = window).__ufo_devtool_onVCRevisionReady__) === null || _ufo_devtool_onVCRev === void 0 ? void 0 : _ufo_devtool_onVCRev.call(_ref, getVCRevisionDebugDetails({
                revision: 'fy25.01',
                isClean: !abortReasonInfo,
                abortReason: abortReason.reason,
                VCEntries: VCEntries.rel,
                componentsLog,
                interactionId
              }));
            }

            // Handle v2
            (_ufo_devtool_onVCRev2 = (_ref2 = window).__ufo_devtool_onVCRevisionReady__) === null || _ufo_devtool_onVCRev2 === void 0 ? void 0 : _ufo_devtool_onVCRev2.call(_ref2, getVCRevisionDebugDetails({
              revision: 'fy25.02',
              isClean: !abortReasonInfo,
              abortReason: abortReason.reason,
              VCEntries: vcNext.VCEntries.rel,
              componentsLog,
              interactionId
            }));
          }
        }
      } catch (e) {
        /*  do nothing */
      }
      const isVCClean = !abortReasonInfo;
      const revisionsData = getVCRevisionsData({
        fullPrefix,
        interaction: {
          start,
          end: stop
        },
        isVCClean,
        calculatedVC: {
          VC,
          VCBox
        },
        calculatedVCNext: {
          VC: vcNext.VC,
          VCBox: vcNext.VCBox
        },
        isEventAborted,
        experienceKey
      });
      const speedIndex = {
        [`ufo:speedIndex`]: isTTVCv1Disabled ? vcNext.VCEntries.speedIndex : VCEntries.speedIndex,
        [`ufo:next:speedIndex`]: vcNext.VCEntries.speedIndex
      };
      const SSRRatio = VCObserver.getSSRRatio(VCEntries.rel, ssr);
      const SSRRatioNext = VCObserver.getSSRRatio(vcNext.VCEntries.rel, ssr);
      const SSRRatioPayload = includeSSRRatio ? {
        [`${fullPrefix}vc:ssrRatio`]: isTTVCv1Disabled ? SSRRatioNext : SSRRatio,
        [`${fullPrefix}vc:next:ssrRatio`]: SSRRatioNext
      } : {};
      if (isTTVCv1Disabled) {
        return {
          [`${fullPrefix}vc:size`]: viewport,
          [`${fullPrefix}vc:time`]: Math.round(totalTime + (stopTime - startTime)),
          [`${fullPrefix}vc:ratios`]: ratios,
          ...outOfBoundary,
          [`${fullPrefix}vc:ignored`]: this.getIgnoredElements(componentsLog),
          ...SSRRatioPayload,
          [`${fullPrefix}vc:ssrRatio`]: SSRRatioNext,
          ...revisionsData,
          ...speedIndex
        };
      }
      const isTTVCv3Enabled = isVCRevisionEnabled('fy25.03', experienceKey);
      return {
        'metrics:vc': VC,
        [`${fullPrefix}vc:state`]: true,
        [`${fullPrefix}vc:clean`]: isVCClean,
        [`${fullPrefix}vc:dom`]: VCBox,
        [`${fullPrefix}vc:updates`]: isTTVCv3Enabled ? undefined : VCEntries.rel.slice(0, 50),
        // max 50
        [`${fullPrefix}vc:size`]: viewport,
        [`${fullPrefix}vc:time`]: Math.round(totalTime + (stopTime - startTime)),
        [`${fullPrefix}vc:total`]: totalPainted,
        [`${fullPrefix}vc:ratios`]: ratios,
        [`${fullPrefix}vc:ssrRatio`]: SSRRatio,
        ...outOfBoundary,
        [`${fullPrefix}vc:next`]: vcNext.VC,
        [`${fullPrefix}vc:next:updates`]: isTTVCv3Enabled ? undefined : vcNext.VCEntries.rel.slice(0, 50),
        // max 50
        [`${fullPrefix}vc:next:dom`]: vcNext.VCBox,
        ...SSRRatioPayload,
        [`${fullPrefix}vc:ignored`]: this.getIgnoredElements(componentsLog),
        ...revisionsData,
        ...speedIndex
      };
    });
    _defineProperty(this, "handleUpdate", (rawTime, intersectionRect, targetName, element, type, ignoreReason, attributeName, oldValue, newValue) => {
      if (this.abortReason.reason === null || this.abortReason.blocking === false) {
        const time = Math.round(rawTime - this.startTime);
        const mappedValues = this.mapPixelsToHeatmap(intersectionRect.left, intersectionRect.top, intersectionRect.width, intersectionRect.height);
        this.vcRatios[targetName] = this.getElementRatio(mappedValues);
        if (!ignoreReason) {
          this.applyChangesToHeatMap(mappedValues, time, this.heatmapNext);
        }
        const interaction = getActiveInteraction();
        const isTTVCv1Disabled = !isVCRevisionEnabled('fy25.01', interaction === null || interaction === void 0 ? void 0 : interaction.ufoName);
        if (!isTTVCv1Disabled && (!ignoreReason || ignoreReason === 'not-visible') && type !== 'attr') {
          this.applyChangesToHeatMap(mappedValues, time, this.heatmap);
        }
        if (!this.componentsLog[time]) {
          this.componentsLog[time] = [];
        }
        this.componentsLog[time].push({
          __debug__element: this.devToolsEnabled ? new WeakRef(element) : null,
          type,
          intersectionRect,
          targetName,
          ignoreReason,
          attributeName,
          oldValue,
          newValue
        });
      }
    });
    _defineProperty(this, "mapPixelsToHeatmap", (left, top, width, height) => {
      const {
        w,
        h
      } = this.viewport;
      const l = Math.floor(left / w * this.arraySize);
      const t = Math.floor(top / h * this.arraySize);
      const r = Math.ceil((left + width) / w * this.arraySize);
      const b = Math.ceil((top + height) / h * this.arraySize);

      // that info is temporary to get info why it goes over boundary
      if (this.outOfBoundaryInfo === '') {
        let outOfBoundaryInfo = '';
        if (r > this.arraySize) {
          outOfBoundaryInfo += ` r ${r} ! ${left} ${width}`;
        }
        if (b > this.arraySize) {
          outOfBoundaryInfo += ` r ${r} ! ${top} ${height}`;
        }
        this.outOfBoundaryInfo = outOfBoundaryInfo;
      }

      // correct values to min - 0, max - arraySize
      const result = {
        l: Math.max(0, l),
        t: Math.max(0, t),
        r: Math.min(this.arraySize, r),
        b: Math.min(this.arraySize, b)
      };
      return result;
    });
    _defineProperty(this, "getElementRatio", mappedValues => {
      const {
        r,
        l,
        b,
        t
      } = mappedValues;
      return (r - l) * (b - t) / (this.arraySize * this.arraySize);
    });
    _defineProperty(this, "abortReasonCallback", (key, time) => {
      switch (key) {
        case 'wheel':
          this.setAbortReason(abortReason.scroll, time);
          break;
        case 'keydown':
          this.setAbortReason(abortReason.keypress, time);
          break;
        case 'resize':
          this.setAbortReason(abortReason.resize, time);
          break;
      }
    });
    _defineProperty(this, "attachAbortListeners", () => {
      var _window;
      this.detachAbortListeners();
      let unbinds = attachAbortListeners(window, this.viewport, this.abortReasonCallback);
      if ((_window = window) !== null && _window !== void 0 && _window.__SSR_ABORT_LISTENERS__) {
        Object.entries(window.__SSR_ABORT_LISTENERS__.aborts).forEach(([key, time]) => {
          if (time) {
            this.abortReasonCallback(key, time);
          }
        });
      }
      this.unbind = unbinds;
    });
    this.arraySize = options.heatmapSize || 200;
    this.devToolsEnabled = options.devToolsEnabled || false;
    this.oldDomUpdatesEnabled = options.oldDomUpdates || false;
    const {
      ssrEnablePageLayoutPlaceholder
    } = options;
    this.observers = new Observers({
      selectorConfig: options.selectorConfig || {
        id: false,
        testId: false,
        role: false,
        className: true,
        dataVC: true
      },
      SSRConfig: {
        enablePageLayoutPlaceholder: ssrEnablePageLayoutPlaceholder || false
      }
    });
    this.heatmap = !isVCRevisionEnabled('fy25.01') ? [] : this.getCleanHeatmap();
    this.heatmapNext = this.getCleanHeatmap();
    this.isPostInteraction = options.isPostInteraction || false;
  }
  start({
    startTime
  }) {
    this.active = true;
    if (this.observers.isBrowserSupported()) {
      this.setViewportSize();
      this.resetState();
      this.startTime = startTime;
      this.attachAbortListeners();
      this.observers.subscribeResults(this.handleUpdate);
      this.observers.observe();
    } else {
      this.setAbortReason('not-supported', startTime);
    }
  }
  stop() {
    this.observers.disconnect();
    this.detachAbortListeners();
  }
  getIgnoredElements(componentsLog) {
    return Object.values(componentsLog).flat().filter(({
      ignoreReason
    }) => Boolean(ignoreReason)).map(({
      targetName,
      ignoreReason
    }) => ({
      targetName,
      ignoreReason
    }));
  }
  static getSSRRatio(entries, ssr) {
    if (ssr === undefined || entries.length === 0) {
      return undefined;
    }
    const maybeSSR = entries[0];
    if (maybeSSR.elements[0] === 'SSR') {
      return maybeSSR.vc;
    }
    return 0;
  }
  static calculateVC({
    heatmap,
    ssr = UNUSED_SECTOR,
    componentsLog,
    viewport,
    fixSSRAttribution
  }) {
    const lastUpdate = {};
    let totalPainted = 0;
    const ssrTime = fixSSRAttribution ? Math.floor(ssr) : ssr;
    if (ssrTime !== UNUSED_SECTOR) {
      var _window$document;
      const element = {
        __debug__element: new WeakRef((_window$document = window.document) === null || _window$document === void 0 ? void 0 : _window$document.body),
        intersectionRect: {
          top: 0,
          left: 0,
          right: 0,
          bottom: 0,
          x: 0,
          y: 0,
          width: viewport.w,
          height: viewport.h,
          toJSON() {
            return {};
          }
        },
        targetName: 'SSR'
      };
      if (!componentsLog[ssrTime]) {
        componentsLog[ssrTime] = [];
      }
      componentsLog[ssrTime].push(element);
    }
    heatmap.forEach(line => {
      line.forEach(entry => {
        const rounded = Math.floor(entry === UNUSED_SECTOR && ssrTime !== UNUSED_SECTOR ? ssrTime : entry);
        totalPainted += rounded !== UNUSED_SECTOR ? 1 : 0;
        if (rounded !== UNUSED_SECTOR) {
          lastUpdate[rounded] = lastUpdate[rounded] ? lastUpdate[rounded] + 1 : 1;
        }
      });
    });
    const entries = Object.entries(lastUpdate).map(a => [parseInt(a[0], 10), a[1]]).sort((a, b) => a[0] > b[0] ? 1 : -1);
    const VC = VCObserver.makeVCReturnObj();
    const VCBox = VCObserver.makeVCReturnObj();
    entries.reduce((acc = 0, v) => {
      const currRatio = v[1] / totalPainted;
      let VCRatio = currRatio + acc;
      const preciseCurrRatio = Math.round(100 * (v[1] / totalPainted));
      const preciseAccRatio = Math.round(acc * 100);
      VCRatio = (preciseCurrRatio + preciseAccRatio) / 100;
      const time = v[0];
      VCObserver.VCParts.forEach(key => {
        const value = parseInt(key, 10);
        if ((VC[key] === null || VC[key] === undefined) && VCRatio >= value / 100) {
          var _componentsLog$time;
          VC[key] = time;
          VCBox[key] = [...new Set((_componentsLog$time = componentsLog[time]) === null || _componentsLog$time === void 0 ? void 0 : _componentsLog$time.filter(v => !v.ignoreReason).map(v => v.targetName))];
        }
      });
      return VCRatio;
    }, 0);
    const VCEntries = entries.reduce((acc, [timestamp, entryPainted], i) => {
      var _acc$abs, _componentsLog$timest, _acc$rel$vc, _acc$rel;
      const currentlyPainted = entryPainted + (((_acc$abs = acc.abs[i - 1]) === null || _acc$abs === void 0 ? void 0 : _acc$abs[1]) || 0);
      const currentlyPaintedRatio = Math.round(currentlyPainted / totalPainted * 1000) / 10;
      const logEntry = [...new Set((_componentsLog$timest = componentsLog[timestamp]) === null || _componentsLog$timest === void 0 ? void 0 : _componentsLog$timest.filter(v => !v.ignoreReason).map(v => v.targetName))];
      const ratioDelta = (currentlyPaintedRatio - ((_acc$rel$vc = (_acc$rel = acc.rel[i - 1]) === null || _acc$rel === void 0 ? void 0 : _acc$rel.vc) !== null && _acc$rel$vc !== void 0 ? _acc$rel$vc : 0)) / 100;
      const speedIndex = timestamp * ratioDelta;
      acc.speedIndex += speedIndex;
      acc.abs.push([timestamp, currentlyPainted]);
      acc.rel.push({
        time: timestamp,
        vc: currentlyPaintedRatio,
        elements: logEntry
      });
      return acc;
    }, {
      abs: [],
      rel: [],
      speedIndex: 0
    });
    VCEntries.speedIndex = Math.round(VCEntries.speedIndex);
    return {
      VC,
      VCBox,
      VCEntries,
      totalPainted
    };
  }
  setSSRElement(element) {
    this.observers.setReactRootElement(element);
  }
  setReactRootRenderStart(startTime = performance.now()) {
    this.observers.setReactRootRenderStart(startTime);
  }
  setReactRootRenderStop(stopTime = performance.now()) {
    this.observers.setReactRootRenderStop(stopTime);
  }
  setAbortReason(abort, timestamp, info = '') {
    if (this.abortReason.reason === null || this.abortReason.blocking === false) {
      this.abortReason.reason = abort;
      this.abortReason.info = info;
      this.abortReason.timestamp = timestamp;
      this.abortReason.blocking = abort !== abortReason.scroll;
      if (this.abortReason.blocking) {
        this.detachAbortListeners();
      }
    }
  }
  resetState() {
    this.abortReason = {
      reason: null,
      info: '',
      timestamp: -1,
      blocking: false
    };
    this.detachAbortListeners();
    this.heatmap = !isVCRevisionEnabled('fy25.01') ? [] : this.getCleanHeatmap();
    this.heatmapNext = this.getCleanHeatmap();
    this.totalTime = 0;
    this.componentsLog = {};
    this.vcRatios = {};
  }
  getCleanHeatmap() {
    return Array(this.arraySize).fill('').map(() => Array(this.arraySize).fill(UNUSED_SECTOR));
  }
  setViewportSize() {
    this.viewport.w = getViewportWidth();
    this.viewport.h = getViewportHeight();
  }
  applyChangesToHeatMap(a, time, heatmap) {
    const {
      l,
      t,
      r,
      b
    } = a;
    const localHeatmap = heatmap;
    for (let row = t; row < b; row++) {
      for (let col = l; col < r; col++) {
        if (localHeatmap[row] === undefined) {
          try {
            this.setAbortReason(abortReason.error, time, `index - ${row}`);
          } catch (e) {
            this.setAbortReason(abortReason.error, time, 'row error');
          }
          return;
        } else {
          localHeatmap[row][col] = time;
        }
      }
    }
  }
  static makeVCReturnObj() {
    const vc = {};
    VCObserver.VCParts.forEach(v => {
      vc[v] = null;
    });
    return vc;
  }
  detachAbortListeners() {
    if (this.unbind) {
      const {
        unbind
      } = this;
      for (let i = 0; i < unbind.length; i++) {
        unbind[i]();
      }
      this.unbind.length = 0;
    }
  }
  measureStart() {
    this._startMeasureTimestamp = performance.now();
  }
  measureStop() {
    if (this._startMeasureTimestamp === -1) {
      return;
    }
    this.totalTime += performance.now() - this._startMeasureTimestamp;
    this._startMeasureTimestamp = -1;
  }
}
/** config * */
_defineProperty(VCObserver, "VCParts", ['25', '50', '75', '80', '85', '90', '95', '98', '99']);