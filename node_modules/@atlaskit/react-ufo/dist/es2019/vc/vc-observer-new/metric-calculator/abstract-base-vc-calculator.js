import { fg } from '@atlaskit/platform-feature-flags';
import { calculateTTVCPercentiles, calculateTTVCPercentilesWithDebugInfo } from './percentile-calc';
import getViewportHeight from './utils/get-viewport-height';
import getViewportWidth from './utils/get-viewport-width';
export default class AbstractVCCalculatorBase {
  constructor(revisionNo) {
    this.revisionNo = revisionNo;
  }
  filterViewportEntries(entries) {
    return entries.filter(entry => {
      return 'rect' in entry.data;
    });
  }
  async calculateBasic(filteredEntries, startTime, stopTime) {
    const percentiles = [25, 50, 75, 80, 85, 90, 95, 98, 99];
    const viewportEntries = this.filterViewportEntries(filteredEntries);
    const vcLogs = await calculateTTVCPercentiles({
      viewport: {
        width: getViewportWidth(),
        height: getViewportHeight()
      },
      startTime,
      stopTime,
      orderedEntries: viewportEntries,
      percentiles
    });
    return vcLogs;
  }
  async calculateWithDebugInfo(filteredEntries, startTime, stopTime, isPostInteraction, isVCClean, interactionId, dirtyReason) {
    const percentiles = [25, 50, 75, 80, 85, 90, 95, 98, 99];
    const viewportEntries = this.filterViewportEntries(filteredEntries);
    const vcLogs = await calculateTTVCPercentilesWithDebugInfo({
      viewport: {
        width: getViewportWidth(),
        height: getViewportHeight()
      },
      startTime,
      stopTime,
      orderedEntries: viewportEntries
    });
    const vcDetails = {};
    let percentileIndex = 0;
    const entryDataBuffer = new Set();
    if (vcLogs) {
      for (const entry of vcLogs) {
        const {
          time,
          viewportPercentage,
          entries
        } = entry;

        // Only process entries if we haven't reached all percentiles
        if (percentileIndex >= percentiles.length) {
          break;
        }

        // Check if this entry matches any checkpoint percentiles
        if (viewportPercentage >= percentiles[percentileIndex]) {
          const elementNames = entries.map(e => e.elementName);

          // Process all matching percentiles in one go
          while (percentileIndex < percentiles.length && viewportPercentage >= percentiles[percentileIndex]) {
            vcDetails[`${percentiles[percentileIndex]}`] = {
              t: Math.round(time),
              e: elementNames
            };
            percentileIndex++;
          }

          // Clear buffer after processing all matching percentiles
          entryDataBuffer.clear();
        } else {
          // Only add to buffer if we haven't reached all percentiles
          entries.forEach(e => entryDataBuffer.add(e));
        }
      }
    }

    // Fill in any missing percentiles with the last known values
    let previousResult = {
      t: 0,
      e: []
    };
    for (let i = 0; i < percentiles.length; i++) {
      const percentile = percentiles[i];
      if (!(percentile in vcDetails)) {
        vcDetails[`${percentile}`] = previousResult;
      } else {
        previousResult = vcDetails[`${percentile}`];
      }
    }

    // Handle devtool callback
    if (!isPostInteraction && typeof window !== 'undefined' && typeof window.__ufo_devtool_onVCRevisionReady__ === 'function' && fg('platform_ufo_ttvc_v3_devtool')) {
      try {
        var _ufo_devtool_onVCRev, _ref;
        (_ufo_devtool_onVCRev = (_ref = window).__ufo_devtool_onVCRevisionReady__) === null || _ufo_devtool_onVCRev === void 0 ? void 0 : _ufo_devtool_onVCRev.call(_ref, {
          revision: this.revisionNo,
          isClean: isVCClean,
          abortReason: dirtyReason,
          vcLogs,
          interactionId
        });
      } catch (e) {
        // if any error communicating with devtool, we don't want to break the app
        // eslint-disable-next-line no-console
        console.error('Error in onVCRevisionReady', e);
      }
    }
    return vcDetails;
  }
  async calculate({
    startTime,
    stopTime,
    orderedEntries,
    interactionId,
    isPostInteraction
  }) {
    var _vcDetails$90$t, _vcDetails$;
    const filteredEntries = orderedEntries.filter(entry => {
      return this.isEntryIncluded(entry);
    });
    let isVCClean;
    let dirtyReason;
    const getVCCleanStatusResult = this.getVCCleanStatus(filteredEntries);
    isVCClean = getVCCleanStatusResult.isVCClean;
    dirtyReason = getVCCleanStatusResult.dirtyReason;
    if (!isVCClean) {
      return {
        revision: this.revisionNo,
        'metric:vc90': null,
        clean: false,
        abortReason: dirtyReason
      };
    }
    const useDebugInfo = fg('platform_ufo_ttvc_v3_devtool');
    const vcDetails = useDebugInfo ? await this.calculateWithDebugInfo(filteredEntries, startTime, stopTime, isPostInteraction, isVCClean, interactionId, dirtyReason) : await this.calculateBasic(filteredEntries, startTime, stopTime);
    return {
      revision: this.revisionNo,
      clean: true,
      'metric:vc90': (_vcDetails$90$t = vcDetails === null || vcDetails === void 0 ? void 0 : (_vcDetails$ = vcDetails['90']) === null || _vcDetails$ === void 0 ? void 0 : _vcDetails$.t) !== null && _vcDetails$90$t !== void 0 ? _vcDetails$90$t : null,
      vcDetails: vcDetails !== null && vcDetails !== void 0 ? vcDetails : undefined
    };
  }
}