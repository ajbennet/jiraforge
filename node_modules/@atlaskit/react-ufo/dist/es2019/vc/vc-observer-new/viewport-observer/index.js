import _defineProperty from "@babel/runtime/helpers/defineProperty";
import { isContainedWithinMediaWrapper } from '../../vc-observer/media-wrapper/vc-utils';
import isNonVisualStyleMutation from '../../vc-observer/observers/non-visual-styles/is-non-visual-style-mutation';
import { createIntersectionObserver } from './intersection-observer';
import createMutationObserver from './mutation-observer';
import createPerformanceObserver from './performance-observer';
function isElementVisible(element) {
  if (!(element instanceof HTMLElement)) {
    return true;
  }
  try {
    const visible = element.checkVisibility({
      // @ts-expect-error
      visibilityProperty: true,
      contentVisibilityAuto: true,
      opacityProperty: true
    });
    return visible;
  } catch (e) {
    // there is no support for checkVisibility
    return true;
  }
}
function sameRectSize(a, b) {
  if (!a || !b) {
    return false;
  }
  return a.width === b.width && a.height === b.height;
}
function sameRectDimensions(a, b) {
  if (!a || !b) {
    return false;
  }
  return a.width === b.width && a.height === b.height && a.x === b.x && a.y === b.y;
}
const createElementMutationsWatcher = removedNodeRects => ({
  rect
}) => {
  const wasDeleted = removedNodeRects.some(nr => sameRectDimensions(nr, rect));
  if (wasDeleted) {
    return 'mutation:element-replacement';
  }
  return 'mutation:element';
};
export default class ViewportObserver {
  constructor({
    onChange
  }) {
    _defineProperty(this, "handleIntersectionEntry", ({
      target,
      rect,
      time,
      type,
      mutationData
    }) => {
      if (!target) {
        return;
      }
      const visible = isElementVisible(target);
      const lastElementRect = this.mapVisibleNodeRects.get(target);
      this.mapVisibleNodeRects.set(target, rect);
      this.onChange({
        time,
        type,
        elementRef: new WeakRef(target),
        visible,
        rect,
        previousRect: lastElementRect,
        mutationData
      });
    });
    _defineProperty(this, "handleChildListMutation", ({
      addedNodes,
      removedNodes
    }) => {
      const removedNodeRects = removedNodes.map(ref => {
        const n = ref.deref();
        if (!n) {
          return;
        }
        return this.mapVisibleNodeRects.get(n);
      });
      addedNodes.forEach(addedNodeRef => {
        var _this$intersectionObs3;
        const addedNode = addedNodeRef.deref();
        if (!addedNode) {
          return;
        }
        const sameDeletedNode = removedNodes.find(ref => {
          const n = ref.deref();
          if (!n || !addedNode) {
            return false;
          }
          return n.isEqualNode(addedNode);
        });
        if (sameDeletedNode) {
          var _this$intersectionObs;
          (_this$intersectionObs = this.intersectionObserver) === null || _this$intersectionObs === void 0 ? void 0 : _this$intersectionObs.watchAndTag(addedNode, 'mutation:remount');
          return;
        }
        if (isContainedWithinMediaWrapper(addedNode)) {
          var _this$intersectionObs2;
          (_this$intersectionObs2 = this.intersectionObserver) === null || _this$intersectionObs2 === void 0 ? void 0 : _this$intersectionObs2.watchAndTag(addedNode, 'mutation:media');
          return;
        }
        (_this$intersectionObs3 = this.intersectionObserver) === null || _this$intersectionObs3 === void 0 ? void 0 : _this$intersectionObs3.watchAndTag(addedNode, createElementMutationsWatcher(removedNodeRects));
      });
    });
    _defineProperty(this, "handleAttributeMutation", ({
      target,
      attributeName,
      oldValue,
      newValue
    }) => {
      var _this$intersectionObs4;
      (_this$intersectionObs4 = this.intersectionObserver) === null || _this$intersectionObs4 === void 0 ? void 0 : _this$intersectionObs4.watchAndTag(target, ({
        target,
        rect
      }) => {
        if (isContainedWithinMediaWrapper(target)) {
          return {
            type: 'mutation:media',
            mutationData: {
              attributeName,
              oldValue,
              newValue
            }
          };
        }
        if (isNonVisualStyleMutation({
          target,
          attributeName,
          type: 'attributes'
        })) {
          return {
            type: 'mutation:attribute:non-visual-style',
            mutationData: {
              attributeName,
              oldValue,
              newValue
            }
          };
        }
        const lastElementRect = this.mapVisibleNodeRects.get(target);
        if (lastElementRect && sameRectSize(rect, lastElementRect)) {
          return {
            type: 'mutation:attribute:no-layout-shift',
            mutationData: {
              attributeName,
              oldValue,
              newValue
            }
          };
        }
        return {
          type: 'mutation:attribute',
          mutationData: {
            attributeName,
            oldValue,
            newValue
          }
        };
      });
    });
    _defineProperty(this, "handleLayoutShift", ({
      time,
      changedRects
    }) => {
      for (const changedRect of changedRects) {
        const target = changedRect.node;
        if (target) {
          this.onChange({
            time,
            elementRef: new WeakRef(target),
            visible: true,
            rect: changedRect.rect,
            previousRect: changedRect.previousRect,
            type: 'layout-shift'
          });
        }
      }
    });
    this.mapVisibleNodeRects = new WeakMap();
    this.onChange = onChange;
    this.isStarted = false;
    this.intersectionObserver = null;
    this.mutationObserver = null;
    this.performanceObserver = null;
  }
  initializeObservers() {
    if (this.isStarted) {
      return;
    }
    this.intersectionObserver = createIntersectionObserver({
      onEntry: this.handleIntersectionEntry
    });
    this.mutationObserver = createMutationObserver({
      onChildListMutation: this.handleChildListMutation,
      onAttributeMutation: this.handleAttributeMutation
    });
    this.performanceObserver = createPerformanceObserver({
      onLayoutShift: this.handleLayoutShift
    });
  }
  start() {
    var _this$mutationObserve, _this$performanceObse;
    if (this.isStarted) {
      return;
    }
    this.initializeObservers();
    (_this$mutationObserve = this.mutationObserver) === null || _this$mutationObserve === void 0 ? void 0 : _this$mutationObserve.observe(document.body, {
      attributeOldValue: true,
      attributes: true,
      childList: true,
      subtree: true
    });
    (_this$performanceObse = this.performanceObserver) === null || _this$performanceObse === void 0 ? void 0 : _this$performanceObse.observe({
      type: 'layout-shift',
      buffered: true,
      // @ts-ignore-error
      durationThreshold: 30
    });
    this.isStarted = true;
  }
  stop() {
    var _this$mutationObserve2, _this$intersectionObs5, _this$performanceObse2;
    if (!this.isStarted) {
      return;
    }
    (_this$mutationObserve2 = this.mutationObserver) === null || _this$mutationObserve2 === void 0 ? void 0 : _this$mutationObserve2.disconnect();
    (_this$intersectionObs5 = this.intersectionObserver) === null || _this$intersectionObs5 === void 0 ? void 0 : _this$intersectionObs5.disconnect();
    (_this$performanceObse2 = this.performanceObserver) === null || _this$performanceObse2 === void 0 ? void 0 : _this$performanceObse2.disconnect();
    this.isStarted = false;
  }
}