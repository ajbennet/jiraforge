"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _typeof = require("@babel/runtime/helpers/typeof");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.OpenLayerObserver = OpenLayerObserver;
var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));
var _react = _interopRequireWildcard(require("react"));
var _openLayerObserverContext = require("./open-layer-observer-context");
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != _typeof(e) && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
/**
 * Returns an instance of the open layer observer API. It internally keeps track of the number of open layers and
 * exposes methods to get the current count, increment/decrement the count, and subscribe to changes.
 */
function createInternalAPI() {
  var count = 0;
  var registry = new Set();
  function onChange(listener) {
    /**
     * We are wrapping the passed listener in a function to ensure that each call to `onChange` creates a unique
     * function reference. This is to handle scenarios where the same function is provided to several different `onChange`
     * calls - we want to ensure that each call to `unsubscribe` only removes the specific listener registration that was added.
     */
    function wrapped() {
      listener.apply(void 0, arguments);
    }
    registry.add(wrapped);
    return function unsubscribe() {
      registry.delete(wrapped);
    };
  }
  function increment() {
    count += 1;
    // Using `Array.from` to ensure we iterate over a stable list - e.g. in case a listener adds to the registry while we are
    // iterating over it.
    Array.from(registry).forEach(function (listener) {
      return listener({
        count: count
      });
    });
  }
  function decrement() {
    count -= 1;
    // Using `Array.from` to ensure we iterate over a stable list - e.g. in case a listener adds to the registry while we are
    // iterating over it.
    Array.from(registry).forEach(function (listener) {
      return listener({
        count: count
      });
    });
  }
  return {
    getCount: function getCount() {
      return count;
    },
    onChange: onChange,
    increment: increment,
    decrement: decrement
  };
}

/**
 * Context provider for observing the number of __open__ layering components (e.g. popups, dropdown menus) under the observer.
 * It uses a stable object to keep track of the number of open layered components - which means the observer will not re-render
 * when the number of layers changes.
 *
 * If this `OpenLayerObserver` has a parent `OpenLayerObserver`, it will also increment/decrement its parent observer's layer count.
 * This allows for nested `OpenLayerObserver` components to correctly track the number of open layers.
 *
 * It is intended for use with the `useOpenLayerObserver` hook.
 */
function OpenLayerObserver(_ref) {
  var children = _ref.children;
  // Using state to ensure a stable reference to a single instance.
  var _useState = (0, _react.useState)(function () {
      return createInternalAPI();
    }),
    _useState2 = (0, _slicedToArray2.default)(_useState, 1),
    internalAPI = _useState2[0];
  var parentContext = (0, _react.useContext)(_openLayerObserverContext.OpenLayerObserverContext);
  var increment = (0, _react.useCallback)(function () {
    internalAPI.increment();

    // If the `OpenLayerObserver` is nested, increment the layer count in the parent context as well.
    if (parentContext !== null) {
      parentContext.increment();
    }
  }, [internalAPI, parentContext]);
  var decrement = (0, _react.useCallback)(function () {
    internalAPI.decrement();

    // If the `OpenLayerObserver` is nested, decrement the layer count in the parent context as well.
    if (parentContext !== null) {
      parentContext.decrement();
    }
  }, [internalAPI, parentContext]);
  var contextValue = (0, _react.useMemo)(function () {
    return {
      getCount: internalAPI.getCount,
      onChange: internalAPI.onChange,
      increment: increment,
      decrement: decrement
    };
  }, [decrement, increment, internalAPI.getCount, internalAPI.onChange]);
  return /*#__PURE__*/_react.default.createElement(_openLayerObserverContext.OpenLayerObserverContext.Provider, {
    value: contextValue
  }, children);
}