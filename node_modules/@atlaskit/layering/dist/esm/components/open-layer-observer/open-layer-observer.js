import _slicedToArray from "@babel/runtime/helpers/slicedToArray";
import React, { useCallback, useContext, useMemo, useState } from 'react';
import { OpenLayerObserverContext } from './open-layer-observer-context';
/**
 * Returns an instance of the open layer observer API. It internally keeps track of the number of open layers and
 * exposes methods to get the current count, increment/decrement the count, and subscribe to changes.
 */
function createInternalAPI() {
  var count = 0;
  var registry = new Set();
  function onChange(listener) {
    /**
     * We are wrapping the passed listener in a function to ensure that each call to `onChange` creates a unique
     * function reference. This is to handle scenarios where the same function is provided to several different `onChange`
     * calls - we want to ensure that each call to `unsubscribe` only removes the specific listener registration that was added.
     */
    function wrapped() {
      listener.apply(void 0, arguments);
    }
    registry.add(wrapped);
    return function unsubscribe() {
      registry.delete(wrapped);
    };
  }
  function increment() {
    count += 1;
    // Using `Array.from` to ensure we iterate over a stable list - e.g. in case a listener adds to the registry while we are
    // iterating over it.
    Array.from(registry).forEach(function (listener) {
      return listener({
        count: count
      });
    });
  }
  function decrement() {
    count -= 1;
    // Using `Array.from` to ensure we iterate over a stable list - e.g. in case a listener adds to the registry while we are
    // iterating over it.
    Array.from(registry).forEach(function (listener) {
      return listener({
        count: count
      });
    });
  }
  return {
    getCount: function getCount() {
      return count;
    },
    onChange: onChange,
    increment: increment,
    decrement: decrement
  };
}

/**
 * Context provider for observing the number of __open__ layering components (e.g. popups, dropdown menus) under the observer.
 * It uses a stable object to keep track of the number of open layered components - which means the observer will not re-render
 * when the number of layers changes.
 *
 * If this `OpenLayerObserver` has a parent `OpenLayerObserver`, it will also increment/decrement its parent observer's layer count.
 * This allows for nested `OpenLayerObserver` components to correctly track the number of open layers.
 *
 * It is intended for use with the `useOpenLayerObserver` hook.
 */
export function OpenLayerObserver(_ref) {
  var children = _ref.children;
  // Using state to ensure a stable reference to a single instance.
  var _useState = useState(function () {
      return createInternalAPI();
    }),
    _useState2 = _slicedToArray(_useState, 1),
    internalAPI = _useState2[0];
  var parentContext = useContext(OpenLayerObserverContext);
  var increment = useCallback(function () {
    internalAPI.increment();

    // If the `OpenLayerObserver` is nested, increment the layer count in the parent context as well.
    if (parentContext !== null) {
      parentContext.increment();
    }
  }, [internalAPI, parentContext]);
  var decrement = useCallback(function () {
    internalAPI.decrement();

    // If the `OpenLayerObserver` is nested, decrement the layer count in the parent context as well.
    if (parentContext !== null) {
      parentContext.decrement();
    }
  }, [internalAPI, parentContext]);
  var contextValue = useMemo(function () {
    return {
      getCount: internalAPI.getCount,
      onChange: internalAPI.onChange,
      increment: increment,
      decrement: decrement
    };
  }, [decrement, increment, internalAPI.getCount, internalAPI.onChange]);
  return /*#__PURE__*/React.createElement(OpenLayerObserverContext.Provider, {
    value: contextValue
  }, children);
}