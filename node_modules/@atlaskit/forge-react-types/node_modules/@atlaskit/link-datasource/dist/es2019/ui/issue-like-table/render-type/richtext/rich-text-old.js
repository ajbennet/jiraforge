/**
 * @jsxRuntime classic
 * @jsx jsx
 */
import { useMemo } from 'react';

// eslint-disable-next-line @atlaskit/ui-styling-standard/use-compiled -- Ignored via go/DSP-18766
import { css, jsx } from '@emotion/react';
import { defaultSchema } from '@atlaskit/adf-schema/schema-default';
import { Node as PMNode, Schema } from '@atlaskit/editor-prosemirror/model';
const rootStyles = css({
  position: 'relative'
});
const smartLinkNodeToUrl = node => {
  var _node$attrs$url;
  return (_node$attrs$url = node.attrs.url) !== null && _node$attrs$url !== void 0 ? _node$attrs$url : '';
};
const schemaSmartLinkOverride = new Schema({
  nodes: defaultSchema.spec.nodes.update('inlineCard', {
    ...defaultSchema.spec.nodes.get('inlineCard'),
    leafText: smartLinkNodeToUrl
  }).update('blockCard', {
    ...defaultSchema.spec.nodes.get('blockCard'),
    leafText: smartLinkNodeToUrl
  }).update('embedCard', {
    ...defaultSchema.spec.nodes.get('embedCard'),
    leafText: smartLinkNodeToUrl
  }),
  marks: defaultSchema.spec.marks
});
export const parseRichText = value => {
  try {
    if (value.type === 'adf') {
      const adf = JSON.parse(value.text);
      return PMNode.fromJSON(schemaSmartLinkOverride, {
        ...adf,
        content: [...adf.content.slice(0, 2)]
      }).textContent;
    }
    return null;
  } catch (e) {
    // eslint-disable-next-line no-console
    console.error('error parsing adf', e);
    return null;
  }
};
const RichTextType = ({
  value
}) => {
  const adfPlainText = useMemo(() => parseRichText(value), [value]);
  if (adfPlainText) {
    return jsx("span", {
      css: rootStyles,
      "data-testid": "richtext-plaintext"
    }, adfPlainText);
  } else {
    return jsx("span", {
      "data-testid": "richtext-unsupported"
    });
  }
};
export default RichTextType;