/**
 * @jsxRuntime classic
 * @jsx jsx
 */
import React, { useCallback, useEffect, useMemo, useState } from 'react';

// eslint-disable-next-line @atlaskit/ui-styling-standard/use-compiled -- Ignored via go/DSP-18766
import { css, jsx } from '@emotion/react';
import { useIntl } from 'react-intl-next';
import { useDebouncedCallback } from 'use-debounce';
import { Flex, xcss } from '@atlaskit/primitives';
import { useDatasourceAnalyticsEvents } from '../../../analytics';
import { BasicSearchInput } from '../../common/modal/basic-search-input';
import { basicSearchInputMessages } from '../../common/modal/basic-search-input/messages';
import { ModeSwitcher } from '../../common/modal/mode-switcher';
import { FILTER_SELECTION_DEBOUNCE_MS } from '../../common/modal/popup-select/constants';
import { BasicFilters } from '../basic-filters';
import { useHydrateJqlQuery } from '../basic-filters/hooks/useHydrateJqlQuery';
import { isQueryTooComplex } from '../basic-filters/utils/isQueryTooComplex';
import { JiraJQLEditor } from '../jql-editor';
import { buildJQL } from './buildJQL';
import { modeSwitcherMessages } from './messages';
const inputContainerStyles = css({
  alignItems: 'baseline',
  display: 'flex',
  minHeight: '72px'
});
const basicSearchInputContainerStyles = xcss({
  flexGrow: 1
});
export const DEFAULT_JQL_QUERY = 'ORDER BY created DESC';
export const ALLOWED_ORDER_BY_KEYS = ['key', 'summary', 'assignee', 'status', 'created'];
export const JiraSearchContainerOld = props => {
  const {
    isSearching,
    parameters,
    onSearch,
    onSearchMethodChange: onSearchMethodChangeCallback,
    initialSearchMethod,
    setSearchBarJql,
    searchBarJql = DEFAULT_JQL_QUERY,
    site
  } = props;
  const {
    cloudId: currentCloudId
  } = parameters || {};
  const {
    formatMessage
  } = useIntl();
  const {
    fireEvent
  } = useDatasourceAnalyticsEvents();
  const [basicSearchTerm, setBasicSearchTerm] = useState('');
  const [currentSearchMethod, setCurrentSearchMethod] = useState(initialSearchMethod);
  const [cloudId, setCloudId] = useState(currentCloudId);
  const [isComplexQuery, setIsComplexQuery] = useState(false);
  const [orderKey, setOrderKey] = useState();
  const [orderDirection, setOrderDirection] = useState();
  const [filterSelections, setFilterSelections] = useState({});
  const modeSwitcherOptionsMap = useMemo(() => ({
    jql: {
      label: 'JQL',
      value: 'jql'
    },
    basic: {
      label: formatMessage(modeSwitcherMessages.basicTextSearchLabel),
      value: 'basic',
      disabled: isComplexQuery,
      tooltipText: isComplexQuery ? formatMessage(modeSwitcherMessages.basicModeSwitchDisabledTooltipText) : ''
    }
  }), [formatMessage, isComplexQuery]);
  const modeSwitcherOptions = useMemo(() => [modeSwitcherOptionsMap.basic, modeSwitcherOptionsMap.jql], [modeSwitcherOptionsMap]);
  const {
    hydratedOptions,
    fetchHydratedJqlOptions,
    status: basicFilterHydrationStatus
  } = useHydrateJqlQuery(cloudId || '', searchBarJql);
  const onSearchMethodChange = useCallback(searchMethod => {
    onSearchMethodChangeCallback(searchMethod);
    setCurrentSearchMethod(searchMethod);
  }, [onSearchMethodChangeCallback]);
  const handleBasicSearchChange = useCallback(e => {
    const rawSearch = e.currentTarget.value;
    setBasicSearchTerm(rawSearch);
    setSearchBarJql(buildJQL({
      rawSearch,
      filterValues: filterSelections,
      orderDirection,
      orderKey
    }));
  }, [setSearchBarJql, filterSelections, orderDirection, orderKey]);
  const onQueryChange = useCallback(query => {
    var _query$split$map$filt, _fragments$at, _fragments$at2, _fragments$at3;
    // determine if order keys have been set so they can be saved and persisted when changes occur in basic search
    const fragments = (_query$split$map$filt = query === null || query === void 0 ? void 0 : query.split(/(^| )(order by)( |$)/i).map(item => item.trim()).filter(Boolean)) !== null && _query$split$map$filt !== void 0 ? _query$split$map$filt : [];
    const hasOrder = ((_fragments$at = fragments.at(-2)) === null || _fragments$at === void 0 ? void 0 : _fragments$at.toLowerCase()) === 'order by';
    const key = hasOrder ? (_fragments$at2 = fragments.at(-1)) === null || _fragments$at2 === void 0 ? void 0 : _fragments$at2.split(' ').at(-2) : undefined;
    const order = hasOrder ? (_fragments$at3 = fragments.at(-1)) === null || _fragments$at3 === void 0 ? void 0 : _fragments$at3.split(' ').at(-1) : undefined;

    // TODO: confirm if these are the only order keys we want to preserve - existing whiteboard logic
    if (key && ALLOWED_ORDER_BY_KEYS.includes(key)) {
      setOrderKey(key);
      setOrderDirection(order);
    }
    setSearchBarJql(query);
  }, [setSearchBarJql]);
  const handleSearch = useCallback(() => {
    const isCurrentQueryComplex = isQueryTooComplex(searchBarJql);
    onSearch({
      jql: searchBarJql
    }, {
      searchMethod: currentSearchMethod,
      basicFilterSelections: filterSelections,
      isQueryComplex: isCurrentQueryComplex
    });
    if (currentSearchMethod === 'jql') {
      fireEvent('ui.jqlEditor.searched', {
        isQueryComplex: isCurrentQueryComplex
      });
      setIsComplexQuery(isCurrentQueryComplex);
      if (!isCurrentQueryComplex) {
        fetchHydratedJqlOptions();
      }
    }
  }, [currentSearchMethod, fetchHydratedJqlOptions, filterSelections, fireEvent, searchBarJql, onSearch]);
  const [debouncedBasicFilterSelectionChange] = useDebouncedCallback(filterValues => {
    const jqlWithFilterValues = buildJQL({
      rawSearch: basicSearchTerm,
      filterValues,
      orderDirection,
      orderKey
    });
    setSearchBarJql(jqlWithFilterValues);
    const isCurrentQueryComplex = isQueryTooComplex(jqlWithFilterValues);
    onSearch({
      jql: jqlWithFilterValues
    }, {
      searchMethod: currentSearchMethod,
      basicFilterSelections: filterSelections,
      isQueryComplex: isCurrentQueryComplex
    });
  }, FILTER_SELECTION_DEBOUNCE_MS);
  const handleBasicFilterSelectionChange = useCallback((filterType, options) => {
    const updatedSelection = {
      ...filterSelections,
      [filterType]: options
    };
    setFilterSelections(updatedSelection);
    debouncedBasicFilterSelectionChange(updatedSelection);
  }, [debouncedBasicFilterSelectionChange, filterSelections]);
  useEffect(() => {
    const isCurrentQueryComplex = isQueryTooComplex(searchBarJql);
    setIsComplexQuery(isCurrentQueryComplex);
    if (!isCurrentQueryComplex && searchBarJql !== DEFAULT_JQL_QUERY) {
      fetchHydratedJqlOptions();
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);
  useEffect(() => {
    if (basicFilterHydrationStatus === 'resolved') {
      const {
        basicInputTextValue,
        ...hydratedFilterOptions
      } = hydratedOptions;
      setFilterSelections(hydratedFilterOptions);
      if (basicInputTextValue) {
        setBasicSearchTerm(basicInputTextValue);
      }
    }
  }, [hydratedOptions, basicFilterHydrationStatus]);
  useEffect(() => {
    if (currentCloudId !== cloudId) {
      setBasicSearchTerm('');
      setSearchBarJql(DEFAULT_JQL_QUERY);
      setIsComplexQuery(false);
      setOrderKey(undefined);
      setOrderDirection(undefined);
      setFilterSelections({});
      setCloudId(currentCloudId);
    }
  }, [currentCloudId, cloudId, setSearchBarJql]);
  return jsx("div", {
    css: inputContainerStyles,
    "data-testid": "jira-search-container"
  }, currentSearchMethod === 'basic' && jsx(Flex, {
    alignItems: "center",
    xcss: basicSearchInputContainerStyles
  }, jsx(BasicSearchInput, {
    isSearching: isSearching,
    onChange: handleBasicSearchChange,
    onSearch: handleSearch,
    searchTerm: basicSearchTerm,
    placeholder: basicSearchInputMessages.basicTextSearchLabel,
    testId: "jira-datasource-modal",
    fullWidth: false
  }), jsx(BasicFilters, {
    jql: searchBarJql,
    site: site,
    onChange: handleBasicFilterSelectionChange,
    selections: filterSelections,
    isJQLHydrating: basicFilterHydrationStatus === 'loading'
  })), currentSearchMethod === 'jql' && jsx(JiraJQLEditor, {
    cloudId: cloudId || '',
    isSearching: isSearching,
    onChange: onQueryChange,
    onSearch: handleSearch,
    query: searchBarJql
  }), jsx(ModeSwitcher, {
    onOptionValueChange: onSearchMethodChange,
    selectedOptionValue: currentSearchMethod,
    options: modeSwitcherOptions
  }));
};