import _defineProperty from "@babel/runtime/helpers/defineProperty";
import _extends from "@babel/runtime/helpers/extends";
import _objectWithoutProperties from "@babel/runtime/helpers/objectWithoutProperties";
import _slicedToArray from "@babel/runtime/helpers/slicedToArray";
var _excluded = ["triggerRef"];
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
/**
 * @jsxRuntime classic
 * @jsx jsx
 */
import { useCallback, useEffect, useMemo, useRef, useState } from 'react';

// eslint-disable-next-line @atlaskit/ui-styling-standard/use-compiled -- Ignored via go/DSP-18766
import { css, jsx } from '@emotion/react';
// eslint-disable-next-line @atlaskit/ui-styling-standard/use-compiled -- Ignored via go/DSP-18766
import styled from '@emotion/styled';
import ReactDOM from 'react-dom';
import { FormattedMessage } from 'react-intl-next';
import invariant from 'tiny-invariant';
import Button from '@atlaskit/button/new';
import DropdownMenu, { DropdownItem } from '@atlaskit/dropdown-menu';
import ChevronDown from '@atlaskit/icon/utility/migration/chevron-down';
import ChevronUp from '@atlaskit/icon/utility/migration/chevron-up';
import { attachClosestEdge, extractClosestEdge } from '@atlaskit/pragmatic-drag-and-drop-hitbox/closest-edge';
import { DropIndicator } from '@atlaskit/pragmatic-drag-and-drop-react-drop-indicator/box';
import { combine } from '@atlaskit/pragmatic-drag-and-drop/combine';
import { draggable, dropTargetForElements, monitorForElements } from '@atlaskit/pragmatic-drag-and-drop/element/adapter';
import { disableNativeDragPreview } from '@atlaskit/pragmatic-drag-and-drop/element/disable-native-drag-preview';
import { pointerOutsideOfPreview } from '@atlaskit/pragmatic-drag-and-drop/element/pointer-outside-of-preview';
import { setCustomNativeDragPreview } from '@atlaskit/pragmatic-drag-and-drop/element/set-custom-native-drag-preview';
import { preventUnhandled } from '@atlaskit/pragmatic-drag-and-drop/prevent-unhandled';
import { useDatasourceAnalyticsEvents } from '../../analytics';
import { GlyphPlaceholder, UnwrapTextIcon, WrapTextIcon } from './custom-icons';
import { issueLikeTableMessages } from './messages';
import { TableHeading } from './styled';
import { getColumnMinWidth, getWidthCss } from './utils';
// eslint-disable-next-line @atlaskit/ui-styling-standard/no-styled -- To migrate as part of go/ui-styling-standard
var DropdownParent = styled.div({
  display: 'flex',
  alignItems: 'center',
  whiteSpace: 'nowrap',
  // eslint-disable-next-line @atlaskit/ui-styling-standard/no-nested-selectors -- Ignored via go/DSP-18766
  '& button': {
    textAlign: 'left' /* By default button center in the middle without props to control it */,
    height: 'auto' /* By default button is not happy with tall (up to lines in our case) content */,
    paddingBlock: "var(--ds-space-0, 0px)",
    paddingLeft: "var(--ds-space-0, 0px)" /* By default button's padding left and right is 8 + 4. We control that 8, so left with 4 that we need.  */,
    paddingRight: "var(--ds-space-0, 0px)"
  }
});
var dropTargetStyles = css({
  position: 'absolute',
  top: 0,
  left: 0,
  width: '100%'
});
var noPointerEventsStyles = css({
  pointerEvents: 'none'
});
var resizerStyles = css({
  '--local-hitbox-width': "var(--ds-space-300, 24px)",
  width: 'var(--local-hitbox-width)',
  cursor: 'col-resize',
  flexGrow: '0',
  position: 'absolute',
  zIndex: 1,
  // we want this to sit on top of adjacent column headers
  right: 'calc(-1 * calc(var(--local-hitbox-width) / 2))',
  top: 0,
  // eslint-disable-next-line @atlaskit/ui-styling-standard/no-unsafe-selectors -- Ignored via go/DSP-18766
  '::before': {
    opacity: 0,
    '--local-line-width': "var(--ds-border-width, 2px)",
    content: '""',
    position: 'absolute',
    background: "var(--ds-border-brand, #0052CC)",
    width: 'var(--local-line-width)',
    inset: 0,
    left: "calc(50% - calc(var(--local-line-width) / 2))",
    transition: 'opacity 0.2s ease'
  },
  // eslint-disable-next-line @atlaskit/ui-styling-standard/no-unsafe-selectors -- Ignored via go/DSP-18766
  ':hover::before': {
    opacity: 1
  }
});
var resizingStyles = css({
  // turning off the resizing cursor as sometimes it can cause the cursor to flicker
  // while resizing. The browser controls the cursor while dragging, but the browser
  // can sometimes bug out.
  cursor: 'unset',
  // eslint-disable-next-line @atlaskit/ui-styling-standard/no-unsafe-selectors -- Ignored via go/DSP-18766
  '::before': {
    opacity: 1
  }
});
var idleState = {
  type: 'idle'
};
var draggingState = {
  type: 'dragging'
};
export var DraggableTableHeadingOld = function DraggableTableHeadingOld(_ref) {
  var children = _ref.children,
    id = _ref.id,
    index = _ref.index,
    tableId = _ref.tableId,
    dndPreviewHeight = _ref.dndPreviewHeight,
    dragPreview = _ref.dragPreview,
    width = _ref.width,
    onWidthChange = _ref.onWidthChange,
    isWrapped = _ref.isWrapped,
    onIsWrappedChange = _ref.onIsWrappedChange;
  var _useDatasourceAnalyti = useDatasourceAnalyticsEvents(),
    fireEvent = _useDatasourceAnalyti.fireEvent;
  var mainHeaderCellRef = useRef(null);
  var columnResizeHandleRef = useRef(null);
  var _useState = useState(idleState),
    _useState2 = _slicedToArray(_useState, 2),
    state = _useState2[0],
    setState = _useState2[1];
  var _useState3 = useState(false),
    _useState4 = _slicedToArray(_useState3, 2),
    isDraggingAnyColumn = _useState4[0],
    setIsDraggingAnyColumn = _useState4[1];
  var _useState5 = useState(null),
    _useState6 = _slicedToArray(_useState5, 2),
    closestEdge = _useState6[0],
    setClosestEdge = _useState6[1];
  var dropTargetRef = useRef(null);
  /**
   * When width is not set (or callback is not set) we assume not resizing is needed.
   * In our case width won't be set for last cell when table container is bigger than sum of all columns
   */
  var resizeIsEnabled = !!onWidthChange && !!width;
  useEffect(function () {
    var cell = mainHeaderCellRef.current;
    invariant(cell);
    return combine(draggable({
      element: cell,
      getInitialData: function getInitialData() {
        return {
          type: 'table-header',
          id: id,
          index: index,
          tableId: tableId
        };
      },
      onGenerateDragPreview: function onGenerateDragPreview(_ref2) {
        var nativeSetDragImage = _ref2.nativeSetDragImage;
        setCustomNativeDragPreview({
          getOffset: pointerOutsideOfPreview({
            x: '18px',
            y: '18px'
          }),
          render: function render(_ref3) {
            var container = _ref3.container;
            // Cause a `react` re-render to create your portal synchronously
            setState({
              type: 'preview',
              container: container
            });
            // In our cleanup function: cause a `react` re-render to create remove your portal
            // Note: you can also remove the portal in `onDragStart`,
            // which is when the cleanup function is called
            return function () {
              return setState(draggingState);
            };
          },
          nativeSetDragImage: nativeSetDragImage
        });
      },
      onDragStart: function onDragStart() {
        setState(draggingState);
      },
      onDrop: function onDrop() {
        setState(idleState);
      }
    }));
  }, [id, index, tableId]);

  // Here we handle drop target, that in our case is absolutely positioned div that covers full width and height
  // of this column (has height of whole table). It sits on top of everything, but has `pointerEvents: 'none'` by default
  useEffect(function () {
    var dropTarget = dropTargetRef.current;
    invariant(dropTarget);
    return dropTargetForElements({
      element: dropTarget,
      getIsSticky: function getIsSticky() {
        return true;
      },
      getData: function getData(_ref4) {
        var input = _ref4.input,
          element = _ref4.element;
        var data = {
          id: id,
          index: index
        };
        return attachClosestEdge(data, {
          input: input,
          element: element,
          allowedEdges: ['left', 'right']
        });
      },
      canDrop: function canDrop(args) {
        return args.source.data.type === 'table-header' && args.source.data.tableId === tableId;
      },
      onDrag: function onDrag(args) {
        if (args.source.data.id !== id) {
          setClosestEdge(extractClosestEdge(args.self.data));
        }
      },
      onDragLeave: function onDragLeave() {
        setClosestEdge(null);
      },
      onDrop: function onDrop() {
        setClosestEdge(null);
      }
    });
  }, [id, index, tableId]);

  // During dragging anywhere we want to remove `pointerEvents: 'none'` from all the drop targets
  useEffect(function () {
    return monitorForElements({
      canMonitor: function canMonitor(_ref5) {
        var source = _ref5.source;
        return source.data.type === 'table-header' && source.data.tableId === tableId;
      },
      onDragStart: function onDragStart() {
        /**
         * Should cause a synchronous re-render.
         */
        setIsDraggingAnyColumn(true);
      },
      onDrop: function onDrop() {
        setIsDraggingAnyColumn(false);
      }
    });
  }, [tableId]);

  // Handling column resizing
  useEffect(function () {
    if (!resizeIsEnabled) {
      return;
    }
    var resizeHandle = columnResizeHandleRef.current;
    invariant(resizeHandle);
    var mainHeaderCell = mainHeaderCellRef.current;
    invariant(mainHeaderCell);
    return draggable({
      element: resizeHandle,
      getInitialData: function getInitialData() {
        // metadata related to currently dragging item (can be read by drop events etc)
        return {
          type: 'column-resize',
          id: id,
          index: index,
          tableId: tableId
        };
      },
      // Is called when dragging started
      onGenerateDragPreview: function onGenerateDragPreview(_ref6) {
        var nativeSetDragImage = _ref6.nativeSetDragImage;
        // We don't show any preview, since column separator (handle) is moving with the cursor
        disableNativeDragPreview({
          nativeSetDragImage: nativeSetDragImage
        });
        // Block drag operations outside `@atlaskit/pragmatic-drag-and-drop`
        preventUnhandled.start();
        setState({
          type: 'resizing',
          initialWidth: width
        });
      },
      onDrag: function onDrag(_ref7) {
        var location = _ref7.location;
        var relativeDistanceX = location.current.input.clientX - location.initial.input.clientX;
        invariant(state.type === 'resizing');
        var initialWidth = state.initialWidth;

        // Set the width of our header being resized
        var proposedWidth = initialWidth + relativeDistanceX;
        if (proposedWidth < getColumnMinWidth(id)) {
          proposedWidth = getColumnMinWidth(id);
        }

        // We update width css directly live
        mainHeaderCell.style.setProperty('width', "".concat(proposedWidth, "px"));
      },
      onDrop: function onDrop() {
        preventUnhandled.stop();
        setState(idleState);
        if (onWidthChange) {
          var cssWidth = +mainHeaderCell.style.getPropertyValue('width').slice(0, -2);
          onWidthChange(cssWidth);
        }
      }
    });
  }, [id, index, onWidthChange, resizeIsEnabled, state, tableId, width]);
  var _useState7 = useState(false),
    _useState8 = _slicedToArray(_useState7, 2),
    buttonHovered = _useState8[0],
    setButtonHovered = _useState8[1];
  var _useState9 = useState(false),
    _useState10 = _slicedToArray(_useState9, 2),
    isDropdownOpen = _useState10[0],
    setIsDropdownOpen = _useState10[1];
  // Width is not set when it is a last cell in a wide table.
  // We make assumption thus that there is enough width for chevron.
  var isWideEnoughToHaveChevron = !width || width > 76;
  var shouldShowTriggerIcon = (buttonHovered || isDropdownOpen) && isWideEnoughToHaveChevron;
  var triggerIcon = useMemo(function () {
    return shouldShowTriggerIcon ? isDropdownOpen ? ChevronUp : ChevronDown : isWideEnoughToHaveChevron ? GlyphPlaceholder : undefined;
  }, [shouldShowTriggerIcon, isDropdownOpen, isWideEnoughToHaveChevron]);
  var getTriggerButton = useCallback(function (_ref8) {
    var triggerRef = _ref8.triggerRef,
      props = _objectWithoutProperties(_ref8, _excluded);
    return jsx(Button, _extends({}, props, {
      testId: "".concat(id, "-column-dropdown"),
      shouldFitContainer: true,
      iconAfter: triggerIcon,
      ref: triggerRef,
      appearance: "subtle",
      spacing: "compact",
      onMouseEnter: function onMouseEnter() {
        return setButtonHovered(true);
      },
      onMouseLeave: function onMouseLeave() {
        return setButtonHovered(false);
      }
    }), children);
  }, [children, id, triggerIcon]);
  var onDropdownOpenChange = useCallback(function (_ref9) {
    var isOpen = _ref9.isOpen;
    return setIsDropdownOpen(isOpen);
  }, []);
  var toggleWrap = useCallback(function () {
    if (!onIsWrappedChange) {
      return;
    }
    var nextIsWrap = !(isWrapped || false);
    if (nextIsWrap) {
      fireEvent('ui.button.clicked.wrap', {});
    } else {
      fireEvent('ui.button.clicked.unwrap', {});
    }
    onIsWrappedChange(nextIsWrap);
  }, [fireEvent, isWrapped, onIsWrappedChange]);
  return jsx(TableHeading, {
    ref: mainHeaderCellRef,
    "data-testid": "".concat(id, "-column-heading"),
    style: _objectSpread({
      // eslint-disable-next-line @atlaskit/ui-styling-standard/enforce-style-prop -- Ignored via go/DSP-18766
      cursor: 'grab'
    }, getWidthCss({
      shouldUseWidth: resizeIsEnabled,
      width: width
    }))
  }, resizeIsEnabled ? jsx("div", {
    ref: columnResizeHandleRef,
    css: [resizerStyles, state.type === 'resizing' && resizingStyles],
    style: {
      height: "".concat(dndPreviewHeight, "px")
    },
    "data-testid": "column-resize-handle"
  }) : null, onIsWrappedChange ? jsx(DropdownParent, null, jsx(DropdownMenu, {
    trigger: getTriggerButton,
    onOpenChange: onDropdownOpenChange,
    placement: 'bottom'
  }, jsx(DropdownItem, {
    elemBefore: isWrapped ? jsx(UnwrapTextIcon, null) : jsx(WrapTextIcon, null),
    testId: "".concat(id, "-column-dropdown-item-toggle-wrapping"),
    onClick: toggleWrap
  }, isWrapped ? jsx(FormattedMessage, issueLikeTableMessages.unwrapText) : jsx(FormattedMessage, issueLikeTableMessages.wrapText)))) : children, jsx("div", {
    ref: dropTargetRef,
    css: [dropTargetStyles, isDraggingAnyColumn ? null : noPointerEventsStyles],
    style: {
      height: "".concat(dndPreviewHeight, "px")
    },
    "data-testid": 'column-drop-target'
  }, closestEdge && jsx(DropIndicator, {
    edge: closestEdge
  })), state.type === 'preview' ? /*#__PURE__*/ReactDOM.createPortal(dragPreview, state.container) : null);
};