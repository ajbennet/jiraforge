import _toConsumableArray from "@babel/runtime/helpers/toConsumableArray";
import _slicedToArray from "@babel/runtime/helpers/slicedToArray";
import _extends from "@babel/runtime/helpers/extends";
import _objectWithoutProperties from "@babel/runtime/helpers/objectWithoutProperties";
import _defineProperty from "@babel/runtime/helpers/defineProperty";
var _excluded = ["shouldRenderToParent", "shouldFitContainer", "children", "appearance", "xcss"];
/**
 * @jsxRuntime classic
 * @jsx jsx
 */
import { forwardRef, Fragment, useMemo, useState } from 'react';
import { css, jsx } from '@emotion/react';
import FocusRing from '@atlaskit/focus-ring';
import { useLayering } from '@atlaskit/layering';
import { fg } from '@atlaskit/platform-feature-flags';
import { Popper } from '@atlaskit/popper';
import { N0, N50A, N60A } from '@atlaskit/theme/colors';
import { layers } from '@atlaskit/theme/constants';
import { CURRENT_SURFACE_CSS_VAR } from '@atlaskit/tokens';
import { RepositionOnUpdate } from './reposition-on-update';
import { useCloseManager } from './use-close-manager';
import { useFocusManager } from './use-focus-manager';
var fullWidthStyles = css({
  width: '100%'
});
var rootStyles = css(_defineProperty(_defineProperty({
  display: 'block',
  boxSizing: 'border-box',
  zIndex: layers.layer(),
  backgroundColor: "var(--ds-surface-overlay, ".concat(N0, ")"),
  borderRadius: "var(--ds-border-radius, 3px)",
  boxShadow: "var(--ds-shadow-overlay, ".concat("0 4px 8px -2px ".concat(N50A, ", 0 0 1px ").concat(N60A), ")"),
  // Resetting text color for portal content.
  // Otherwise, when rendering into the parent (not using a portal),
  // the text color can be inherited from the parent.
  color: "var(--ds-text, #172B4D)"
}, CURRENT_SURFACE_CSS_VAR, "var(--ds-surface-overlay, ".concat(N0, ")")), '&:focus', {
  outline: 'none'
}));
var scrollableStyles = css({
  overflow: 'auto'
});
var blanketStyles = css({
  position: 'fixed',
  inset: 0,
  backgroundColor: "var(--ds-blanket, #091E427D)"
});
var modalStyles = css({
  maxHeight: '50vh',
  position: 'fixed',
  insetBlockStart: "var(--ds-space-050, 4px)",
  insetInline: "var(--ds-space-050, 4px)"
});
var DefaultPopupComponent = /*#__PURE__*/forwardRef(function (props, ref) {
  var shouldRenderToParent = props.shouldRenderToParent,
    shouldFitContainer = props.shouldFitContainer,
    children = props.children,
    appearance = props.appearance,
    xcss = props.xcss,
    htmlAttributes = _objectWithoutProperties(props, _excluded);
  return jsx("div", _extends({
    // Because we're using Emotion local jsx namespace we have to coerce xcss prop to a string.
    // When we're fully on Compiled its local jsx namespace accepts the output of xcss prop.
    // eslint-disable-next-line @atlaskit/ui-styling-standard/no-classname-prop -- This rule still fails because of the TS assertion
    className: xcss,
    css: [rootStyles, appearance === 'UNSAFE_modal-below-sm' && modalStyles, !shouldRenderToParent && scrollableStyles, shouldFitContainer && fullWidthStyles]
  }, htmlAttributes, {
    ref: ref
  }), children);
});
function PopperWrapper(_ref) {
  var xcss = _ref.xcss,
    isOpen = _ref.isOpen,
    id = _ref.id,
    offset = _ref.offset,
    testId = _ref.testId,
    content = _ref.content,
    fallbackPlacements = _ref.fallbackPlacements,
    onClose = _ref.onClose,
    boundary = _ref.boundary,
    rootBoundary = _ref.rootBoundary,
    shouldFlip = _ref.shouldFlip,
    _ref$placement = _ref.placement,
    placement = _ref$placement === void 0 ? 'auto' : _ref$placement,
    _ref$popupComponent = _ref.popupComponent,
    PopupContainer = _ref$popupComponent === void 0 ? DefaultPopupComponent : _ref$popupComponent,
    _ref$autoFocus = _ref.autoFocus,
    autoFocus = _ref$autoFocus === void 0 ? true : _ref$autoFocus,
    triggerRef = _ref.triggerRef,
    shouldUseCaptureOnOutsideClick = _ref.shouldUseCaptureOnOutsideClick,
    shouldRenderToParent = _ref.shouldRenderToParent,
    shouldFitContainer = _ref.shouldFitContainer,
    shouldDisableFocusLock = _ref.shouldDisableFocusLock,
    _ref$shouldReturnFocu = _ref.shouldReturnFocus,
    shouldReturnFocus = _ref$shouldReturnFocu === void 0 ? true : _ref$shouldReturnFocu,
    strategy = _ref.strategy,
    role = _ref.role,
    label = _ref.label,
    titleId = _ref.titleId,
    modifiers = _ref.modifiers,
    shouldFitViewport = _ref.shouldFitViewport,
    _ref$appearance = _ref.appearance,
    appearance = _ref$appearance === void 0 ? 'default' : _ref$appearance;
  var _useState = useState(null),
    _useState2 = _slicedToArray(_useState, 2),
    popupRef = _useState2[0],
    setPopupRef = _useState2[1];
  var _useState3 = useState(null),
    _useState4 = _slicedToArray(_useState3, 2),
    initialFocusRef = _useState4[0],
    setInitialFocusRef = _useState4[1];
  // We have cases where we need to close the Popup on Tab press, e.g. DropdownMenu
  var shouldCloseOnTab = shouldRenderToParent && shouldDisableFocusLock;
  var shouldDisableFocusTrap = role !== 'dialog';
  useFocusManager({
    initialFocusRef: initialFocusRef,
    popupRef: popupRef,
    shouldCloseOnTab: shouldCloseOnTab,
    triggerRef: triggerRef,
    autoFocus: autoFocus,
    shouldDisableFocusTrap: shouldDisableFocusTrap,
    shouldReturnFocus: shouldReturnFocus
  });
  useCloseManager({
    isOpen: isOpen,
    onClose: onClose,
    popupRef: popupRef,
    triggerRef: triggerRef,
    shouldUseCaptureOnOutsideClick: shouldUseCaptureOnOutsideClick,
    shouldCloseOnTab: shouldCloseOnTab,
    autoFocus: autoFocus,
    shouldDisableFocusTrap: shouldDisableFocusTrap,
    shouldRenderToParent: shouldRenderToParent
  });
  var _useLayering = useLayering(),
    currentLevel = _useLayering.currentLevel;
  var mergedModifiers = useMemo(function () {
    return [{
      name: 'flip',
      enabled: shouldFlip,
      options: {
        rootBoundary: rootBoundary,
        boundary: boundary,
        fallbackPlacements: fallbackPlacements
      }
    }].concat(_toConsumableArray(modifiers || []));
  }, [shouldFlip, rootBoundary, boundary, fallbackPlacements, modifiers]);
  return jsx(Popper, {
    placement: placement,
    offset: offset,
    modifiers: mergedModifiers,
    strategy: strategy,
    shouldFitViewport: shouldFitViewport
  }, function (_ref2) {
    var _ref3 = _ref2.ref,
      style = _ref2.style,
      placement = _ref2.placement,
      update = _ref2.update;
    var popupContainer = jsx(PopupContainer, {
      xcss: xcss,
      appearance: appearance,
      id: id,
      "data-ds--level": currentLevel,
      "data-placement": placement,
      "data-testid": testId,
      role: role,
      "aria-label": label,
      "aria-labelledby": titleId,
      ref: function ref(node) {
        if (node) {
          if (typeof _ref3 === 'function') {
            _ref3(node);
          } else {
            _ref3.current = node;
          }
          setPopupRef(node);
        }
      }
      // eslint-disable-next-line @atlaskit/ui-styling-standard/enforce-style-prop -- Ignored via go/DSP-18766
      ,
      style: appearance === 'UNSAFE_modal-below-sm' ? {} : style
      // using tabIndex={-1} would cause a bug where Safari focuses
      // first on the browser address bar when using keyboard
      ,
      tabIndex: autoFocus ? 0 : undefined,
      shouldRenderToParent: shouldRenderToParent,
      shouldFitContainer: shouldFitContainer
    }, jsx(RepositionOnUpdate, {
      update: update
    }, content({
      update: update,
      isOpen: isOpen,
      onClose: onClose,
      setInitialFocusRef: setInitialFocusRef
    })));
    return !initialFocusRef && fg('platform-design-system-apply-popup-wrapper-focus') ? jsx(Fragment, null, jsx(FocusRing, null, popupContainer), appearance === 'UNSAFE_modal-below-sm' && jsx("div", {
      css: blanketStyles
    })) : jsx(Fragment, null, popupContainer, appearance === 'UNSAFE_modal-below-sm' && jsx("div", {
      css: blanketStyles
    }));
  });
}

// eslint-disable-next-line @repo/internal/react/require-jsdoc
export default PopperWrapper;