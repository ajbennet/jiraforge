import { NodeSelection } from '@atlaskit/editor-prosemirror/state';
import { GapCursorSelection } from './gap-cursor/selection';
export var isSelectionAtStartOfNode = function isSelectionAtStartOfNode($pos, parentNode) {
  if (!parentNode) {
    return false;
  }
  for (var i = $pos.depth + 1; i > 0; i--) {
    var node = $pos.node(i);
    if (node && node.eq(parentNode.node)) {
      break;
    }
    if (i > 1 && $pos.before(i) !== $pos.before(i - 1) + 1) {
      return false;
    }
  }
  return true;
};
export var isSelectionAtEndOfNode = function isSelectionAtEndOfNode($pos, parentNode) {
  if (!parentNode) {
    return false;
  }
  for (var i = $pos.depth + 1; i > 0; i--) {
    var node = $pos.node(i);
    if (node && node.eq(parentNode.node)) {
      break;
    }
    if (i > 1 && $pos.after(i) !== $pos.after(i - 1) - 1) {
      return false;
    }
  }
  return true;
};
export function atTheEndOfDoc(state) {
  var selection = state.selection,
    doc = state.doc;
  return doc.nodeSize - selection.$to.pos - 2 === selection.$to.depth;
}
export function atTheBeginningOfDoc(state) {
  var selection = state.selection;
  return selection.$from.pos === selection.$from.depth;
}
export function atTheEndOfBlock(state) {
  var selection = state.selection;
  var $to = selection.$to;
  if (selection instanceof GapCursorSelection) {
    return false;
  }
  if (selection instanceof NodeSelection && selection.node.isBlock) {
    return true;
  }
  return endPositionOfParent($to) === $to.pos + 1;
}
export function atTheBeginningOfBlock(state) {
  var selection = state.selection;
  var $from = selection.$from;
  if (selection instanceof GapCursorSelection) {
    return false;
  }
  if (selection instanceof NodeSelection && selection.node.isBlock) {
    return true;
  }
  return startPositionOfParent($from) === $from.pos;
}
export function startPositionOfParent(resolvedPos) {
  return resolvedPos.start(resolvedPos.depth);
}
export function endPositionOfParent(resolvedPos) {
  return resolvedPos.end(resolvedPos.depth) + 1;
}
export var expandSelectionBounds = function expandSelectionBounds($anchor, $head) {
  var $from = $anchor.min($head);
  var $to = $anchor.max($head);
  var fromDepth = $from.depth;
  var toDepth = $to.depth;
  var selectionStart = fromDepth ? $from.before() : $from.pos;
  var selectionEnd = toDepth ? $to.after() : $to.pos;
  var selectionHasGrandparent = toDepth > 1 && fromDepth > 1;
  var selectionIsAcrossDiffParents = selectionHasGrandparent && !$to.parent.isTextblock && !$to.sameParent($from);
  var selectionIsAcrossTextBlocksWithDiffParents = selectionHasGrandparent && $to.parent.isTextblock && $to.before(toDepth - 1) !== $from.before(fromDepth - 1);
  if (toDepth > fromDepth) {
    // expand end of selection to after the last node
    selectionEnd = fromDepth ? $to.after(fromDepth) : $to.after(1);
  } else if (toDepth < fromDepth) {
    // expand start of selection to before the current node
    selectionStart = toDepth ? $from.before(toDepth) : $from.before(1);
  } else if (selectionIsAcrossDiffParents || selectionIsAcrossTextBlocksWithDiffParents) {
    // when selection from/to share same depth with different parents, hoist up the selection to the parent of the highest depth in the selection
    selectionStart = $from.before(fromDepth - 1);
    selectionEnd = $to.after(toDepth - 1);
  } else if (!$from.node().inlineContent) {
    // when selection might be a Node selection, return what was passed in
    return {
      $anchor: $anchor,
      $head: $head
    };
  }
  var $expandedFrom = $anchor.doc.resolve(selectionStart);
  var $expandedTo = $anchor.doc.resolve(selectionEnd);
  return {
    $anchor: $anchor === $from ? $expandedFrom : $expandedTo,
    $head: $head === $to ? $expandedTo : $expandedFrom
  };
};