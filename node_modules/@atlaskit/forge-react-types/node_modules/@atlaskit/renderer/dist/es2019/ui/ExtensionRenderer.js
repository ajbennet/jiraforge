/**
 * @jsxRuntime classic
 * @jsx jsx
 */
// eslint-disable-next-line @atlaskit/ui-styling-standard/use-compiled -- Ignored via go/DSP-18766
import { css, jsx } from '@emotion/react';
import React from 'react';
import memoizeOne from 'memoize-one';
import { getNodeRenderer } from '@atlaskit/editor-common/extensions';
import { WithProviders } from '@atlaskit/editor-common/provider-factory';
import { getExtensionRenderer } from '@atlaskit/editor-common/utils';
const inlineExtensionStyle = css({
  display: 'inline-block',
  maxWidth: '100%',
  verticalAlign: 'middle',
  // es-lint-disable-next-line @atlaskit/design-system/ensure-design-token-usage
  margin: `1px 1px ${"var(--ds-space-050, 4px)"}`,
  // eslint-disable-next-line @atlaskit/ui-styling-standard/no-nested-selectors -- Ignored via go/DSP-18766
  '& .rich-media-item': {
    maxWidth: '100%'
  }
});
export default function ExtensionRenderer(props) {
  const {
    extensionHandlers,
    rendererContext,
    extensionType,
    extensionKey,
    parameters,
    content,
    text,
    type,
    localId,
    marks,
    actions,
    children
  } = props;
  const isMounted = React.useRef(true);
  const localGetNodeRenderer = React.useMemo(() => memoizeOne(getNodeRenderer), []);
  const [extensionProvider, setExtensionProvider] = React.useState(null);

  // Ignored via go/ees005
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  const handleProvider = React.useCallback((name, providerPromise) => {
    providerPromise && providerPromise.then(provider => {
      if (isMounted.current) {
        setExtensionProvider(provider);
      }
    });
  }, []);
  const renderExtensionNode = React.useCallback(extensionProvider => {
    var _marks$find, _marks$find$attrs;
    const fragmentLocalId = marks === null || marks === void 0 ? void 0 : (_marks$find = marks.find(m => m.type.name === 'fragment')) === null || _marks$find === void 0 ? void 0 : (_marks$find$attrs = _marks$find.attrs) === null || _marks$find$attrs === void 0 ? void 0 : _marks$find$attrs.localId;
    const node = {
      type,
      extensionKey,
      extensionType,
      parameters,
      content: content || text,
      localId,
      fragmentLocalId
    };
    let result = null;
    try {
      if (extensionHandlers && extensionHandlers[extensionType]) {
        const render = getExtensionRenderer(extensionHandlers[extensionType]);
        result = render(node, rendererContext.adDoc);
      }
      if (!result && extensionProvider) {
        const NodeRenderer = localGetNodeRenderer(extensionProvider, extensionType, extensionKey);
        if (node.type === 'multiBodiedExtension') {
          result = jsx(NodeRenderer, {
            node: node,
            actions: actions
          });
        } else if (node.type === 'inlineExtension') {
          result = jsx(InlineNodeRendererWrapper, null, jsx(NodeRenderer, {
            node: node
          }));
        } else {
          result = jsx(NodeRenderer, {
            node: node
          });
        }
      }
    } catch (e) {
      /** We don't want this error to block renderer */
      /** We keep rendering the default content */
    }
    return children({
      result
    });
  }, [actions, children, content, extensionHandlers, extensionKey, extensionType, localGetNodeRenderer, localId, marks, parameters, rendererContext === null || rendererContext === void 0 ? void 0 : rendererContext.adDoc, text, type]);
  const setupAndRenderExtensionNode = React.useCallback(providers => {
    if (!extensionProvider && providers.extensionProvider) {
      handleProvider('extensionProvider', providers.extensionProvider);
    }
    return renderExtensionNode(extensionProvider);
  }, [extensionProvider, handleProvider, renderExtensionNode]);
  React.useEffect(() => {
    isMounted.current = true;
    return () => {
      isMounted.current = false;
    };
  }, []);
  if (!props.providers) {
    return setupAndRenderExtensionNode({});
  }
  return jsx(WithProviders, {
    providers: ['extensionProvider'],
    providerFactory: props.providers,
    renderNode: setupAndRenderExtensionNode
  });
}
const InlineNodeRendererWrapper = ({
  children
}) => {
  return (
    // eslint-disable-next-line @atlaskit/ui-styling-standard/no-classname-prop -- Ignored via go/DSP-18766
    jsx("div", {
      className: "inline-extension-renderer",
      css: inlineExtensionStyle
    }, children)
  );
};