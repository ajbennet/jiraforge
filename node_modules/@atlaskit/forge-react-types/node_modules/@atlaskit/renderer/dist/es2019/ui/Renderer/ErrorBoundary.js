import _defineProperty from "@babel/runtime/helpers/defineProperty";
import React from 'react';
import { ACTION, EVENT_TYPE } from '@atlaskit/editor-common/analytics';
import { FabricChannel } from '@atlaskit/analytics-listeners/types';
import { logException } from '@atlaskit/editor-common/monitoring';
import { PLATFORM } from '../../analytics/events';
import uuid from 'uuid';
// Ignored via go/ees005
// eslint-disable-next-line @repo/internal/react/no-class-components
export class ErrorBoundary extends React.Component {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "state", {
      errorCaptured: false,
      domError: false
    });
  }
  fireAnalyticsEvent(event) {
    const {
      createAnalyticsEvent
    } = this.props;
    if (createAnalyticsEvent) {
      const channel = FabricChannel.editor;
      createAnalyticsEvent(event).fire(channel);
    }
  }
  hasFallback() {
    return typeof this.props.fallbackComponent !== 'undefined';
  }
  shouldRecover() {
    return this.hasFallback() && this.state.errorCaptured;
  }
  componentDidCatch(error, errorInfo) {
    var _this$props$additiona;
    const additionalInfo = (_this$props$additiona = this.props.additionalInfo) !== null && _this$props$additiona !== void 0 ? _this$props$additiona : '';
    this.fireAnalyticsEvent({
      action: ACTION.CRASHED,
      actionSubject: this.props.component,
      actionSubjectId: this.props.componentId,
      eventType: EVENT_TYPE.OPERATIONAL,
      attributes: {
        platform: PLATFORM.WEB,
        errorMessage: `${additionalInfo}${error === null || error === void 0 ? void 0 : error.message}`,
        componentStack: (errorInfo === null || errorInfo === void 0 ? void 0 : errorInfo.componentStack) || undefined,
        errorRethrown: Boolean(this.props.rethrowError)
      }
    });
    logException(error, {
      location: 'renderer'
    });
    // Ignored via go/ees005
    // eslint-disable-next-line require-unicode-regexp
    const pattern = /Failed to execute.*on 'Node'.*/;
    const matchesPattern = pattern.test(error.message);
    if (matchesPattern) {
      this.fireAnalyticsEvent({
        action: ACTION.CAUGHT_DOM_ERROR,
        actionSubject: this.props.component,
        actionSubjectId: this.props.componentId,
        eventType: EVENT_TYPE.OPERATIONAL,
        attributes: {
          platform: PLATFORM.WEB,
          errorMessage: `${additionalInfo}${error === null || error === void 0 ? void 0 : error.message}`
        }
      });
      this.setState(() => ({
        domError: true
      }));
    }
    if (this.hasFallback()) {
      this.setState({
        errorCaptured: true
      }, () => {
        if (this.props.rethrowError) {
          throw error;
        }
      });
    }
  }
  render() {
    if (this.state.domError) {
      return /*#__PURE__*/React.createElement(React.Fragment, {
        key: uuid()
      }, this.props.children);
    }
    if (this.shouldRecover()) {
      return this.props.fallbackComponent;
    }
    return this.props.children;
  }
}