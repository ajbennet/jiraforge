import React, { createContext, useCallback, useContext, useMemo, useReducer } from 'react';
function reducer(state, action) {
  switch (action.type) {
    case 'clear':
      if (!!state.range || !!state.type) {
        return {
          range: null,
          draftRange: null,
          type: null
        };
      }
      return state;
    case 'clearSelection':
      if (state.type === 'selection') {
        return {
          ...state,
          range: null,
          type: null
        };
      }
      return state;
    case 'clearDraftSelection':
      if (state.type === 'selection') {
        return {
          ...state,
          draftRange: null
        };
      }
      return state;
    case 'clearDraftHover':
      if (state.type === 'hover') {
        return {
          ...state,
          draftRange: null
        };
      }
      return state;
    case 'clearHover':
      if (state.type === 'hover') {
        return {
          range: null,
          draftRange: null,
          type: null
        };
      }
      return state;
    case 'setSelection':
      if (state.range !== action.range || state.type !== 'selection') {
        return {
          ...state,
          range: action.range,
          type: 'selection'
        };
      }
      return state;
    case 'setHover':
      if (state.range !== action.range || state.type !== 'hover') {
        return {
          ...state,
          range: action.range,
          type: 'hover'
        };
      }
      return state;
    case 'setDraftSelection':
      if (state.draftRange !== action.draftRange || state.type !== 'selection') {
        return {
          range: null,
          draftRange: action.draftRange,
          type: null
        };
      }
      return state;
    case 'setDraftHover':
      if (state.draftRange !== action.draftRange || state.type !== 'hover') {
        return {
          ...state,
          draftRange: action.draftRange
        };
      }
      return state;
  }
}
const AnnotationRangeStateContext = /*#__PURE__*/createContext({
  range: null,
  draftRange: null,
  type: null
});
const AnnotationRangeDispatchContext = /*#__PURE__*/createContext({
  clearRange: () => {},
  clearSelectionRange: () => {},
  clearDraftRange: () => {},
  clearHoverRange: () => {},
  setRange: () => {},
  setDraftRange: () => {}
});
export const AnnotationRangeProvider = ({
  children,
  allowCommentsOnMedia
}) => {
  const [{
    range,
    draftRange,
    type
  }, dispatch] = useReducer(reducer, {
    range: null,
    draftRange: null,
    type: null
  });
  const clearRange = useCallback(() => dispatch({
    type: 'clear'
  }), []);
  const clearSelectionRange = useCallback(() => dispatch({
    type: 'clearSelection'
  }), []);
  const clearDraftRange = useCallback(type => {
    if (type === 'hover') {
      dispatch({
        type: 'clearDraftHover'
      });
      return;
    }
    dispatch({
      type: 'clearDraftSelection'
    });
  }, []);
  const clearHoverRange = useCallback(() => dispatch({
    type: 'clearHover'
  }), []);
  const setRange = useCallback(range => dispatch({
    type: 'setSelection',
    range
  }), []);
  const setDraftRange = useCallback((range, type) => {
    if (type === 'hover') {
      dispatch({
        type: 'setDraftHover',
        draftRange: range
      });
      return;
    }
    dispatch({
      type: 'setDraftSelection',
      draftRange: range
    });
  }, []);
  const setHoverTarget = useCallback(target => {
    // the HoverComponent expects an element deeply nested inside media, these classes work with the current implementation
    const mediaNode = target.querySelector('.media-card-inline-player, .media-file-card-view');
    if (!mediaNode) {
      return;
    }
    const range = document.createRange();
    range.setStartBefore(mediaNode);
    range.setEndAfter(mediaNode);
    dispatch({
      type: 'setHover',
      range
    });
  }, []);
  const stateData = useMemo(() => ({
    range,
    draftRange,
    type
  }), [range, draftRange, type]);
  const dispatchData = useMemo(() => ({
    clearRange,
    clearSelectionRange,
    clearDraftRange,
    clearHoverRange,
    setRange,
    setDraftRange,
    setHoverTarget: !!allowCommentsOnMedia ? setHoverTarget : undefined
  }), [allowCommentsOnMedia, clearRange, clearSelectionRange, clearDraftRange, clearHoverRange, setRange, setDraftRange, setHoverTarget]);
  return /*#__PURE__*/React.createElement(AnnotationRangeStateContext.Provider, {
    value: stateData
  }, /*#__PURE__*/React.createElement(AnnotationRangeDispatchContext.Provider, {
    value: dispatchData
  }, children));
};
export const useAnnotationRangeState = () => {
  return useContext(AnnotationRangeStateContext);
};
export const useAnnotationRangeDispatch = () => {
  return useContext(AnnotationRangeDispatchContext);
};