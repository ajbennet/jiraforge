import _extends from "@babel/runtime/helpers/extends";
import _defineProperty from "@babel/runtime/helpers/defineProperty";
import React from 'react';
import { MarkType } from '@atlaskit/editor-prosemirror/model';
import { editorExperiment } from '@atlaskit/tmp-editor-statsig/experiments';
import { isNestedHeaderLinksEnabled } from './utils/links';
import { Doc, DocWithSelectAllTrap, mergeTextNodes, isTextWrapper, isTextNode, toReact } from './nodes';
import TextWrapperComponent from './nodes/text-wrapper';
import { toReact as markToReact, isAnnotationMark } from './marks';
import { getMarksByOrder, isSameMark } from '@atlaskit/editor-common/validator';
import { calcTableColumnWidths, getColumnWidths } from '@atlaskit/editor-common/utils';
import { getText } from '../utils';
import { findChildrenByType } from '@atlaskit/editor-prosemirror/utils';
import { fg } from '@atlaskit/platform-feature-flags';
import { insideBlockNode, insideBreakoutLayout, insideMultiBodiedExtension, insideTable } from './renderer-node';
import { isCodeMark } from './marks/code';
import { segmentText } from './utils/segment-text';
import { renderTextSegments } from './utils/render-text-segments';
function mergeMarks(marksAndNodes) {
  return marksAndNodes.reduce((acc, markOrNode) => {
    const prev = acc.length && acc[acc.length - 1] || null;
    if (markOrNode.type instanceof MarkType && prev && prev.type instanceof MarkType && Array.isArray(prev.content) && isSameMark(prev, markOrNode)) {
      prev.content = mergeMarks(prev.content.concat(markOrNode.content));
    } else {
      acc.push(markOrNode);
    }
    return acc;
  }, []);
}
export default class ReactSerializer {
  constructor(init) {
    _defineProperty(this, "headingIds", []);
    /**
     * The reason we have this extra array here is because we need to generate the same unique
     * heading id for 2 different nodes: headers and expands (check the implementation of
     * `getUniqueHeadingId` for more info).
     *
     * We will eventually need to refactor the current approach to generate unique ids
     * for headers under this ticket -> https://product-fabric.atlassian.net/browse/ED-9668
     */
    _defineProperty(this, "expandHeadingIds", []);
    _defineProperty(this, "allowCopyToClipboard", false);
    _defineProperty(this, "allowWrapCodeBlock", false);
    _defineProperty(this, "allowPlaceholderText", true);
    _defineProperty(this, "allowCustomPanels", false);
    _defineProperty(this, "surroundTextNodesWithTextWrapper", false);
    _defineProperty(this, "allowAnnotations", false);
    _defineProperty(this, "serializeFragmentChild", (node, {
      index,
      parentInfo
    }) => {
      const pos = this.startPos;
      const currentPath = parentInfo && parentInfo.path || [];
      const parentIsIncompleteTask = node.type.name === 'taskItem' && node.attrs.state !== 'DONE';
      const nodeKey = `${node.type.name}__${this.startPos}`;
      const serializedContent = this.serializeFragment(node.content, this.getNodeProps(node, parentInfo), toReact(node, {
        allowSelectAllTrap: this.allowSelectAllTrap,
        allowWindowedCodeBlock: this.allowWindowedCodeBlock
      }, this.nodeComponents), nodeKey, {
        parentIsIncompleteTask,
        path: [...currentPath, node],
        pos: this.startPos
      });
      this.startPos = pos + node.nodeSize;
      const marks = node.marks ? [...node.marks] : [];
      const isMedia = node.type.name === 'media';
      const shouldSkipBorderMark = mark => currentPath.some(n => {
        var _n$type;
        return ((_n$type = n.type) === null || _n$type === void 0 ? void 0 : _n$type.name) !== 'mediaSingle';
      }) && isMedia && mark.type.name === 'border';
      const shouldSkipLinkMark = mark => this.allowMediaLinking !== true && isMedia && mark.type.name === 'link';
      return marks.reduceRight((content, mark) => {
        if (shouldSkipLinkMark(mark) || shouldSkipBorderMark(mark)) {
          return content;
        }
        return this.renderMark(markToReact(mark), this.withMediaMarkProps(node, mark, this.getMarkProps(mark, [], node)), `${mark.type.name}-${index}`, content);
      }, serializedContent);
    });
    // Ignored via go/ees005
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    // Ignored via go/ees005
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    _defineProperty(this, "withMediaMarkProps", (node, mark, defaultProps) => {
      if (mark.type.name === 'link' && node.type.name === 'media') {
        return {
          ...defaultProps,
          isMediaLink: true
        };
      }
      if (node.type.name === 'mediaInline' && mark.type.name === 'annotation') {
        return {
          ...defaultProps,
          isMediaInline: true
        };
      }
      return defaultProps;
    });
    _defineProperty(this, "getUnsupportedContentProps", node => {
      return {
        node,
        dispatchAnalyticsEvent: this.fireAnalyticsEvent
      };
    });
    _defineProperty(this, "getAnnotationMarkProps", (mark, marksParentPath) => {
      const annotationParentIds = (marksParentPath || []).reduce((acc, parent) => {
        if (isAnnotationMark(parent)) {
          return [...acc, parent.attrs.id];
        }
        return acc;
      }, []);
      return {
        id: mark.attrs.id,
        annotationType: mark.attrs.annotationType,
        annotationParentIds,
        allowAnnotations: this.allowAnnotations,
        dataAttributes: {
          'data-renderer-mark': true
        }
      };
    });
    _defineProperty(this, "getMarkProps", (mark, marksParentPath, node) => {
      if (isAnnotationMark(mark)) {
        return this.getAnnotationMarkProps(mark, marksParentPath);
      }
      const {
        key,
        ...otherAttrs
      } = mark.attrs;
      const extraProps = {
        isInline: node === null || node === void 0 ? void 0 : node.isInline
      };

      // currently the only mark which has custom props is the code mark
      const markSpecificProps = isCodeMark(mark) ? {
        // The appearance being mobile indicates we are in an renderer being
        // rendered by mobile bridge in a web view.
        // The tooltip is likely to have unexpected behaviour there, with being cut
        // off, so we disable it. This is also to keep the behaviour consistent with
        // the rendering in the mobile Native Renderer.
        codeBidiWarningTooltipEnabled: false
      } : {};
      const props = {
        eventHandlers: this.eventHandlers,
        fireAnalyticsEvent: this.fireAnalyticsEvent,
        markKey: key,
        ...otherAttrs,
        ...extraProps,
        ...markSpecificProps,
        dataAttributes: {
          'data-renderer-mark': true
        }
      };
      return props;
    });
    if (editorExperiment('comment_on_bodied_extensions', true)) {
      this.initStartPos = init.startPos || 1;
      this.startPos = init.startPos || 1;
    } else {
      this.initStartPos = 1;
      this.startPos = 1;
    }
    this.providers = init.providers;
    this.eventHandlers = init.eventHandlers;
    this.extensionHandlers = init.extensionHandlers;
    this.portal = init.portal;
    this.rendererContext = init.objectContext;
    this.appearance = init.appearance;
    this.disableHeadingIDs = init.disableHeadingIDs;
    this.disableActions = init.disableActions;
    this.allowHeadingAnchorLinks = init.allowHeadingAnchorLinks;
    this.allowCopyToClipboard = init.allowCopyToClipboard;
    this.allowWrapCodeBlock = init.allowWrapCodeBlock;
    this.allowPlaceholderText = init.allowPlaceholderText;
    this.allowCustomPanels = init.allowCustomPanels;
    this.allowColumnSorting = init.allowColumnSorting;
    this.fireAnalyticsEvent = init.fireAnalyticsEvent;
    this.shouldOpenMediaViewer = init.shouldOpenMediaViewer;
    this.allowAltTextOnImages = init.allowAltTextOnImages;
    this.stickyHeaders = init.stickyHeaders;
    this.allowMediaLinking = init.allowMediaLinking;
    this.allowAnnotations = Boolean(init.allowAnnotations);
    this.surroundTextNodesWithTextWrapper = Boolean(init.surroundTextNodesWithTextWrapper);
    this.media = init.media;
    this.emojiResourceConfig = init.emojiResourceConfig;
    this.smartLinks = init.smartLinks;
    this.allowSelectAllTrap = init.allowSelectAllTrap;
    this.nodeComponents = init.nodeComponents;
    this.allowWindowedCodeBlock = init.allowWindowedCodeBlock;
    this.isInsideOfInlineExtension = init.isInsideOfInlineExtension;
    this.textHighlighter = init.textHighlighter;
    this.allowTableAlignment = init.allowTableAlignment;
    this.allowTableResizing = init.allowTableResizing;
  }
  resetState() {
    this.headingIds = [];
    this.expandHeadingIds = [];
    this.startPos = this.initStartPos;
  }
  getNodeProps(node, parentInfo) {
    const path = parentInfo ? parentInfo.path : undefined;
    switch (node.type.name) {
      case 'date':
        return this.getDateProps(node, parentInfo, path);
      case 'hardBreak':
        return this.getHardBreakProps(node, path);
      case 'heading':
        return this.getHeadingProps(node, path);
      case 'media':
        return this.getMediaProps(node, path);
      case 'emoji':
        return this.getEmojiProps(node);
      case 'mediaGroup':
        return this.getMediaGroupProps(node);
      case 'mediaInline':
        return this.getMediaInlineProps(node);
      case 'mediaSingle':
        return this.getMediaSingleProps(node, path);
      case 'table':
        return this.getTableProps(node, path);
      case 'tableHeader':
      case 'tableRow':
        return this.getTableChildrenProps(node);
      case 'taskItem':
        return this.getTaskItemProps(node, path);
      case 'embedCard':
        return this.getEmbedCardProps(node, path);
      case 'blockCard':
        return this.getBlockCardProps(node, path);
      case 'expand':
        return this.getExpandProps(node, path);
      case 'unsupportedBlock':
      case 'unsupportedInline':
        return this.getUnsupportedContentProps(node);
      case 'codeBlock':
        return this.getCodeBlockProps(node);
      case 'panel':
        return this.getPanelProps(node);
      default:
        return this.getProps(node, path);
    }
  }
  serializeFragment(fragment,
  // Ignored via go/ees005
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  props = {},
  // Ignored via go/ees005
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  target = this.allowSelectAllTrap ? DocWithSelectAllTrap : Doc, key = 'root-0', parentInfo) {
    // This makes sure that we reset internal state on re-render.
    if (key === 'root-0') {
      this.resetState();
    }
    return this.renderNode(target, props, key, ReactSerializer.getChildNodes(fragment).map((node, index) => {
      if (isTextWrapper(node)) {
        return this.serializeTextWrapper(node.content, {
          index,
          parentInfo
        });
      }
      return this.serializeFragmentChild(node, {
        index,
        parentInfo
      });
    }));
  }
  serializeTextWrapper(content, {
    index,
    parentInfo
  }) {
    const currentPath = parentInfo && parentInfo.path || [];
    const nodePosition = parentInfo && parentInfo.pos || 1;
    return ReactSerializer.buildMarkStructure(content).map((mark, index) => {
      return this.serializeMark({
        mark,
        parentNode: {
          path: currentPath,
          pos: nodePosition
        },
        parentMark: {
          path: [mark]
        }
      });
    });
  }
  serializeMark({
    mark,
    parentNode,
    parentMark
  }) {
    if (!isTextNode(mark)) {
      const serializeContent = (childMark, index) => this.serializeMark({
        mark: childMark,
        parentNode,
        parentMark: {
          path: [...parentMark.path, childMark]
        }
      });

      // Ignored via go/ees005
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      const content = (mark.content || []).map(serializeContent);
      const markKey = `${mark.type.name}-component__${this.startPos}__${parentMark.path.length}`;
      return this.renderMark(markToReact(mark), this.getMarkProps(mark, parentMark.path), markKey, content);
    }
    const startPos = this.startPos;
    const endPos = startPos + mark.nodeSize;
    this.startPos = endPos;
    const textKey = `text-wrapper_${this.startPos}`;
    if (this.surroundTextNodesWithTextWrapper) {
      const parentDepth = Math.max(parentNode.path.length - 1, 0);
      return /*#__PURE__*/React.createElement(TextWrapperComponent, {
        key: textKey,
        startPos: startPos + parentDepth,
        endPos: endPos + parentDepth,
        textHighlighter: this.textHighlighter,
        marks: mark.marks
      }, mark.text);
    }
    const segments = segmentText(mark.text, this.textHighlighter);
    return renderTextSegments(segments, this.textHighlighter, mark.marks, startPos);
  }
  renderNode(
  // Ignored via go/ees005
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  NodeComponent,
  // Ignored via go/ees005
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  props, key,
  // Ignored via go/ees005
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  content) {
    return (
      /*#__PURE__*/
      // Ignored via go/ees005
      // eslint-disable-next-line react/jsx-props-no-spreading
      React.createElement(NodeComponent, _extends({
        key: key
      }, props), content)
    );
  }
  renderMark(
  // Ignored via go/ees005
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  MarkComponent, props, key,
  // Ignored via go/ees005
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  content) {
    return (
      /*#__PURE__*/
      // Ignored via go/ees005
      // eslint-disable-next-line react/jsx-props-no-spreading
      React.createElement(MarkComponent, _extends({
        key: key
      }, props), content)
    );
  }
  getTableChildrenProps(node) {
    return {
      ...this.getProps(node),
      allowColumnSorting: this.allowColumnSorting
    };
  }
  getTableProps(node, path = []) {
    const isInsideOfBlockNode = insideBlockNode(path, node.type.schema);
    const isInsideMultiBodiedExtension = insideMultiBodiedExtension(path, node.type.schema);
    const isInsideOfTable = insideTable(path, node.type.schema);

    // TODO: https://product-fabric.atlassian.net/browse/CEMS-1048
    const stickyHeaders = !isInsideOfTable && !insideBreakoutLayout(path) ? this.stickyHeaders : undefined;
    return {
      ...this.getProps(node),
      allowColumnSorting: this.allowColumnSorting,
      columnWidths:
      // When allowTableResizing is enabled, the number of columns is required to render
      // the same scaling logic as editor. Some tables can have unequal rows, so the entire
      // table needs to be scanned.
      this.allowTableResizing && fg('platform_editor_table_col_calculation_fix') ? getColumnWidths(node) : calcTableColumnWidths(node),
      tableNode: node,
      stickyHeaders,
      isInsideOfBlockNode,
      isInsideOfTable,
      isInsideMultiBodiedExtension,
      allowTableAlignment: this.allowTableAlignment,
      allowTableResizing: this.allowTableResizing
    };
  }
  getDateProps(node, parentInfo, path = []) {
    return {
      timestamp: node.attrs && node.attrs.timestamp,
      parentIsIncompleteTask: parentInfo && parentInfo.parentIsIncompleteTask,
      dataAttributes: {
        // We need to account for depth (path.length gives up depth) here
        // but depth doesnt increment the pos, only accounted for.
        'data-renderer-start-pos': this.startPos + path.length
      }
    };
  }
  getMediaSingleProps(node, path = []) {
    const {
      marks: {
        link
      }
    } = node.type.schema;
    const isInsideOfBlockNode = insideBlockNode(path, node.type.schema);
    const isLinkMark = mark => mark.type === link;
    const childHasLink = node.firstChild && node.firstChild.marks.filter(m => isLinkMark(m) || this.allowMediaLinking === true).length;
    return {
      ...this.getProps(node, path),
      isInsideOfBlockNode,
      childHasLink,
      allowCaptions: this.media && this.media.allowCaptions,
      featureFlags: this.media && this.media.featureFlags
    };
  }
  getMediaProps(node, path = []) {
    var _this$media;
    const {
      marks: {
        annotation,
        link,
        border
      }
    } = node.type.schema;
    const isChildOfMediaSingle = path.some(n => {
      var _n$type2;
      return ((_n$type2 = n.type) === null || _n$type2 === void 0 ? void 0 : _n$type2.name) === 'mediaSingle';
    });
    const isAnnotationMark = mark => mark.type === annotation;
    const isLinkMark = mark => mark.type === link;
    const isBorderMark = mark => isChildOfMediaSingle && mark.type === border;
    return {
      ...this.getProps(node, path),
      marks: node.marks.filter(m => !isLinkMark(m) || this.allowMediaLinking === true),
      isLinkMark,
      isBorderMark,
      isAnnotationMark,
      allowAltTextOnImages: this.allowAltTextOnImages,
      featureFlags: this.media && this.media.featureFlags,
      shouldOpenMediaViewer: this.shouldOpenMediaViewer,
      ssr: (_this$media = this.media) === null || _this$media === void 0 ? void 0 : _this$media.ssr,
      // surroundTextNodesWithTextWrapper checks inlineComment.allowDraftMode
      allowAnnotationsDraftMode: this.surroundTextNodesWithTextWrapper
    };
  }
  getEmojiProps(node) {
    return {
      ...this.getProps(node),
      resourceConfig: this.emojiResourceConfig
    };
  }
  getEmbedCardProps(node, path = []) {
    const isInsideOfBlockNode = insideBlockNode(path, node.type.schema);
    return {
      ...this.getProps(node),
      isInsideOfBlockNode
    };
  }
  getBlockCardProps(node, path = []) {
    return {
      ...this.getProps(node),
      isNodeNested: path.length > 0
    };
  }
  getMediaGroupProps(node) {
    var _this$media2, _this$media3;
    return {
      ...this.getProps(node),
      shouldOpenMediaViewer: this.shouldOpenMediaViewer,
      allowAltTextOnImages: this.allowAltTextOnImages,
      featureFlags: this.media && this.media.featureFlags,
      enableDownloadButton: (_this$media2 = this.media) === null || _this$media2 === void 0 ? void 0 : _this$media2.enableDownloadButton,
      ssr: (_this$media3 = this.media) === null || _this$media3 === void 0 ? void 0 : _this$media3.ssr
    };
  }
  getMediaInlineProps(node) {
    var _this$media4;
    return {
      ...this.getProps(node),
      ssr: (_this$media4 = this.media) === null || _this$media4 === void 0 ? void 0 : _this$media4.ssr
    };
  }
  getTaskItemProps(node, path = []) {
    return {
      ...this.getProps(node, path),
      disabled: this.disableActions
    };
  }
  getHardBreakProps(node, path = []) {
    let forceNewLine = false;
    const parentNode = path.length > 0 ? path[path.length - 1] : null;
    if (parentNode && parentNode.lastChild === node) {
      forceNewLine = true;
    }
    return {
      ...this.getProps(node),
      forceNewLine
    };
  }
  getCodeBlockProps(node) {
    // The appearance being mobile indicates we are in an renderer being
    // rendered by mobile bridge in a web view.
    // The tooltip is likely to have unexpected behaviour there, with being cut
    // off, so we disable it. This is also to keep the behaviour consistent with
    // the rendering in the mobile Native Renderer.
    const codeBidiWarningTooltipEnabled = false;
    return {
      ...this.getProps(node),
      text: node.textContent,
      codeBidiWarningTooltipEnabled
    };
  }
  getPanelProps(node) {
    return {
      ...this.getProps(node),
      allowCustomPanels: this.allowCustomPanels
    };
  }
  getProps(node, path = []) {
    const startPos = this.startPos + path.length;
    return {
      text: node.text,
      providers: this.providers,
      eventHandlers: this.eventHandlers,
      extensionHandlers: this.extensionHandlers,
      portal: this.portal,
      rendererContext: this.rendererContext,
      serializer: this,
      content: node.content ? node.content.toJSON() : undefined,
      allowHeadingAnchorLinks: this.allowHeadingAnchorLinks,
      allowCopyToClipboard: this.allowCopyToClipboard,
      allowWrapCodeBlock: this.allowWrapCodeBlock,
      allowPlaceholderText: this.allowPlaceholderText,
      rendererAppearance: this.appearance,
      fireAnalyticsEvent: this.fireAnalyticsEvent,
      nodeType: node.type.name,
      marks: node.marks,
      smartLinks: this.smartLinks,
      isInsideOfInlineExtension: this.isInsideOfInlineExtension,
      dataAttributes: {
        // We need to account for depth (path.length gives up depth) here
        // but depth doesnt increment the pos, only accounted for.
        'data-renderer-start-pos': startPos
      },
      startPos,
      path,
      ...node.attrs
    };
  }
  headingAnchorSupported(path = []) {
    const isImmediateParent = (path, nodeName) => {
      return path.length > 0 && path[path.length - 1].type.name === nodeName;
    };
    return isNestedHeaderLinksEnabled(this.allowHeadingAnchorLinks) || path.length === 0 || isImmediateParent(path, 'layoutColumn');
  }
  getHeadingProps(node, path = []) {
    return {
      ...this.getProps(node, path),
      content: node.content ? node.content.toJSON() : undefined,
      headingId: this.getHeadingId(node, this.headingIds),
      showAnchorLink: this.appearance !== 'comment' && this.allowHeadingAnchorLinks && !this.disableHeadingIDs && this.headingAnchorSupported(path)
    };
  }
  getExpandProps(node, path = []) {
    if (!isNestedHeaderLinksEnabled(this.allowHeadingAnchorLinks)) {
      return this.getProps(node);
    }
    const nestedHeaderIds = findChildrenByType(node, node.type.schema.nodes.heading).map(({
      node
    }) => this.getHeadingId(node, this.expandHeadingIds));
    return {
      ...this.getProps(node),
      nestedHeaderIds
    };
  }

  // The return value of this function is NOT url encoded,
  // In HTML5 standard, id can contain any characters, encoding is no necessary.
  // Plus we trying to avoid double encoding, therefore we leave the value as is.
  // Remember to use encodeURIComponent when generating url from the id value.
  getHeadingId(node, headingIds) {
    if (this.disableHeadingIDs || !node.content.size) {
      return;
    }

    // We are not use node.textContent here, because we would like to handle cases where
    // headings only contain inline blocks like emoji, status and date.
    // Ignored via go/ees005
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const nodeContent = node.content.toJSON()
    // Ignored via go/ees005
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    .reduce((acc, node) => acc.concat(getText(node) || ''), '').trim()
    // Ignored via go/ees005
    // eslint-disable-next-line require-unicode-regexp
    .replace(/\s/g, '-');
    if (!nodeContent) {
      return;
    }
    return this.getUniqueHeadingId(nodeContent, headingIds);
  }
  getUniqueHeadingId(baseId, headingIds, counter = 0) {
    if (counter === 0 && headingIds.indexOf(baseId) === -1) {
      headingIds.push(baseId);
      return baseId;
    } else if (counter !== 0) {
      const headingId = `${baseId}.${counter}`;
      if (headingIds.indexOf(headingId) === -1) {
        headingIds.push(headingId);
        return headingId;
      }
    }
    return this.getUniqueHeadingId(baseId, headingIds, ++counter);
  }
  static getChildNodes(fragment) {
    const children = [];
    fragment.forEach(node => {
      children.push(node);
    });
    return mergeTextNodes(children);
  }
  static getMarks(node) {
    if (!node.marks || node.marks.length === 0) {
      return [];
    }
    return getMarksByOrder(node.marks);
  }
  static buildMarkStructure(content) {
    return mergeMarks(content.map(node => {
      const nodeMarks = this.getMarks(node);
      if (nodeMarks.length === 0) {
        return node;
      }
      return nodeMarks.reverse().reduce((acc, mark) => {
        const {
          eq
        } = mark;
        return {
          ...mark,
          eq,
          content: [acc]
        };
        // Ignored via go/ees005
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
      }, node);
    }));
  }

  // TODO: ED-9004 Remove unused ReactSerializer.fromSchema in renderer
  // https://sourcegraph-frontend.internal.shared-prod.us-west-2.kitt-inf.net/search?q=ReactSerializer.fromSchema&patternType=literal
  static fromSchema(_, init) {
    if (process.env.NODE_ENV !== 'production') {
      // eslint-disable-next-line no-console
      console.warn('ReactSerializer.fromSchema is deprecated. Please use the constructor instead via new ReactSerializer()');
    }
    return new ReactSerializer(init);
  }
}