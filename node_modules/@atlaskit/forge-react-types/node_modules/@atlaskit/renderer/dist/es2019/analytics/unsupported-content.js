import { getUnsupportedContentLevelData, getAnalyticsAppearance } from '@atlaskit/editor-common/utils';
import { ACTION, ACTION_SUBJECT, EVENT_TYPE } from '@atlaskit/editor-common/analytics';
import { PLATFORM } from './events';

// Ignored via go/ees005
// eslint-disable-next-line @typescript-eslint/no-explicit-any

const rendersMap = {};
const processLevelsAndTrack = (item, thresholds, dispatchAnalyticsEvent) => {
  try {
    const {
      severity,
      percentage,
      counts: {
        supportedNodes,
        unsupportedNodes,
        unsupportedNodeTypeCount
      }
    } = getUnsupportedContentLevelData(item.doc, thresholds);
    dispatchAnalyticsEvent({
      action: ACTION.UNSUPPORTED_CONTENT_LEVELS_TRACKING_SUCCEEDED,
      actionSubject: ACTION_SUBJECT.RENDERER,
      attributes: {
        appearance: getAnalyticsAppearance(item.appearance),
        platform: PLATFORM.WEB,
        unsupportedContentLevelSeverity: severity,
        unsupportedContentLevelPercentage: percentage,
        unsupportedNodesCount: unsupportedNodes,
        supportedNodesCount: supportedNodes,
        unsupportedNodeTypeCount: unsupportedNodeTypeCount
      },
      eventType: EVENT_TYPE.OPERATIONAL
    });
  } catch (err) {
    dispatchAnalyticsEvent({
      action: ACTION.UNSUPPORTED_CONTENT_LEVELS_TRACKING_ERRORED,
      actionSubject: ACTION_SUBJECT.RENDERER,
      attributes: {
        platform: PLATFORM.WEB,
        error: err instanceof Error ? err.message : String(err)
      },
      eventType: EVENT_TYPE.OPERATIONAL
    });
  }
};
const schedule = fn => {
  // Ignored via go/ees005
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  if (typeof window.requestIdleCallback === 'function') {
    // Ignored via go/ees005
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    window.requestIdleCallback(fn);
  } else {
    setTimeout(fn, 0);
  }
};
const DEFAULT_SAMPLING_RATE = 100;
export const trackUnsupportedContentLevels = (item, trackingOptions, dispatchAnalyticsEvent) => {
  var _item$appearance;
  const {
    thresholds,
    samplingRates
  } = trackingOptions;
  const appearance = (_item$appearance = item.appearance) !== null && _item$appearance !== void 0 ? _item$appearance : 'unknown';
  if (!rendersMap[appearance]) {
    rendersMap[appearance] = new Set();
  }

  // bail out if already processed a render from a given renderer instance
  const didProcessRenderer = rendersMap[appearance].has(item.rendererId);
  if (didProcessRenderer) {
    return;
  }

  // otherwise track the render
  rendersMap[appearance].add(item.rendererId);
  const sampleRate = samplingRates && samplingRates[appearance] || DEFAULT_SAMPLING_RATE;

  // sample from the first available tracked render
  if (rendersMap[appearance].size === 1) {
    schedule(() => processLevelsAndTrack(item, thresholds, dispatchAnalyticsEvent));
  }
  // cleanup/refresh tracked renders at the sampling rate
  if (rendersMap[appearance].size % sampleRate === 0) {
    rendersMap[appearance] = new Set();
  }
};