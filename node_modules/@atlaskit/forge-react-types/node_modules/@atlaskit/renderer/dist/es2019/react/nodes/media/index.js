import _defineProperty from "@babel/runtime/helpers/defineProperty";
import _extends from "@babel/runtime/helpers/extends";
/**
 * @jsxRuntime classic
 * @jsx jsx
 * @jsxFrag
 */

import React, { PureComponent, Fragment, useEffect, useState, useMemo } from 'react';
// eslint-disable-next-line @atlaskit/ui-styling-standard/use-compiled -- Ignored via go/DSP-18766
import { jsx, css } from '@emotion/react';
import { AnalyticsContext } from '@atlaskit/analytics-next';
import { MEDIA_CONTEXT } from '@atlaskit/analytics-namespaced-context';
import { WithProviders } from '@atlaskit/editor-common/provider-factory';
import { MediaBorderGapFiller } from '@atlaskit/editor-common/ui';
import { MediaCard } from '../../../ui/MediaCard';
import { AnnotationMarkStates } from '@atlaskit/adf-schema';
import { hexToEditorBorderPaletteColor } from '@atlaskit/editor-palette';
import { getEventHandler } from '../../../utils';
import { ACTION, ACTION_SUBJECT, ACTION_SUBJECT_ID, EVENT_TYPE, VIEW_METHOD } from '@atlaskit/editor-common/analytics';
import { fg } from '@atlaskit/platform-feature-flags';
import { MODE, PLATFORM } from '../../../analytics/events';
import AnnotationComponent from '../../marks/annotation';
import { AnnotationsDraftContext } from '../../../ui/annotations/context';
import { CommentBadge as CommentBadgeComponent, CommentBadgeNext, ExternalImageBadge, MediaBadges } from '@atlaskit/editor-common/media-single';
import { injectIntl } from 'react-intl-next';
import { useInlineCommentsFilter } from '../../../ui/annotations/hooks/use-inline-comments-filter';
import { useInlineCommentSubscriberContext } from '../../../ui/annotations/hooks/use-inline-comment-subscriber';
import { AnnotationUpdateEvent } from '@atlaskit/editor-common/types';
import { editorExperiment } from '@atlaskit/tmp-editor-statsig/experiments';
// eslint-disable-next-line @atlaskit/design-system/no-css-tagged-template-expression, @atlaskit/design-system/consistent-css-prop-usage -- Ignored via go/DSP-18766
const linkStyle = css`
	position: absolute;
	background: transparent;
	top: 0;
	right: 0;
	bottom: 0;
	left: 0;
	cursor: pointer;
	width: 100% !important;
	height: 100% !important;
`;

// eslint-disable-next-line @atlaskit/design-system/no-css-tagged-template-expression -- Ignored via go/DSP-18766
const borderStyle = (color, width) => css`
	position: absolute;
	width: 100% !important;
	height: 100% !important;
	border-radius: ${width}px;
	box-shadow: 0 0 0 ${width}px ${color};
`;
const MediaBorder = ({
  mark,
  children
}) => {
  var _mark$attrs$color, _mark$attrs$size;
  if (!mark) {
    return jsx(Fragment, null, children);
  }
  const borderColor = (_mark$attrs$color = mark === null || mark === void 0 ? void 0 : mark.attrs.color) !== null && _mark$attrs$color !== void 0 ? _mark$attrs$color : '';
  const borderWidth = (_mark$attrs$size = mark === null || mark === void 0 ? void 0 : mark.attrs.size) !== null && _mark$attrs$size !== void 0 ? _mark$attrs$size : 0;
  const paletteColorValue = hexToEditorBorderPaletteColor(borderColor) || borderColor;
  return jsx("div", {
    "data-mark-type": "border",
    "data-color": borderColor,
    "data-size": borderWidth
    // eslint-disable-next-line @atlaskit/design-system/consistent-css-prop-usage -- Ignored via go/DSP-18766
    ,
    css: borderStyle(paletteColorValue, borderWidth)
  }, jsx(MediaBorderGapFiller, {
    borderColor: borderColor
  }), children);
};
const MediaLink = ({
  mark,
  children,
  onClick
}) => {
  if (!mark) {
    return jsx(Fragment, null, children);
  }
  const linkHref = mark === null || mark === void 0 ? void 0 : mark.attrs.href;
  return jsx("a", {
    href: linkHref,
    rel: "noreferrer noopener",
    onClick: onClick,
    "data-block-link": linkHref,
    css: linkStyle
  }, children);
};
const MediaAnnotation = ({
  mark,
  children
}) => {
  if (!mark) {
    return jsx(Fragment, null, children);
  }
  return jsx(AnnotationComponent, {
    id: mark.attrs.id,
    annotationType: mark.attrs.annotationType,
    dataAttributes: {
      'data-renderer-mark': true,
      'data-block-mark': true
    }
    // This should be fine being empty [] since the serializer serializeFragmentChild getMarkProps call always passes
    ,
    annotationParentIds: [],
    allowAnnotations: true,
    useBlockLevel: true
  }, children);
};
const MediaAnnotations = ({
  marks = [],
  children
}) => {
  // Early Exit
  if (marks.length === 0) {
    return jsx(Fragment, null, children);
  }

  // Recursive marks
  const currentMark = marks[0];
  const otherMarks = marks.slice(1);
  return jsx(Fragment, null, jsx(MediaAnnotation, {
    key: currentMark.attrs.id,
    mark: currentMark
  }, otherMarks.length ? jsx(MediaAnnotations, {
    marks: otherMarks
  }, children) : jsx(Fragment, null, children)));
};
const CommentBadge = injectIntl(CommentBadgeComponent);
const CommentBadgeWrapper = ({
  marks,
  mediaSingleElement,
  isDrafting = false,
  ...rest
}) => {
  var _marks$map;
  const [status, setStatus] = useState('default');
  const [entered, setEntered] = useState(false);
  const updateSubscriber = useInlineCommentSubscriberContext();
  const activeParentIds = useInlineCommentsFilter({
    annotationIds: (_marks$map = marks === null || marks === void 0 ? void 0 : marks.map(mark => mark.attrs.id)) !== null && _marks$map !== void 0 ? _marks$map : [''],
    filter: {
      state: AnnotationMarkStates.ACTIVE
    }
  });
  useEffect(() => {
    const observer = new MutationObserver(mutationList => {
      mutationList.forEach(mutation => {
        const parentNode = mutation.target.parentNode;
        if (mutation.attributeName === 'data-has-focus') {
          const isMediaCaption = parentNode === null || parentNode === void 0 ? void 0 : parentNode.closest('[data-media-caption="true"]');
          const elementHasFocus = (parentNode === null || parentNode === void 0 ? void 0 : parentNode.querySelector('[data-has-focus="true"]')) && !isMediaCaption;
          elementHasFocus ? setStatus('active') : setStatus('default');
        }
      });
    });
    if (mediaSingleElement) {
      observer.observe(mediaSingleElement, {
        attributes: true,
        subtree: true,
        attributeFilter: ['data-has-focus']
      });
    }
    return () => {
      observer.disconnect();
    };
  }, [mediaSingleElement, setStatus]);
  if (!isDrafting && !activeParentIds.length) {
    return null;
  }
  const onClick = e => {
    e.preventDefault();
    if (updateSubscriber) {
      updateSubscriber.emit(AnnotationUpdateEvent.ON_ANNOTATION_CLICK, {
        annotationIds: activeParentIds,
        // Ignored via go/ees005
        // eslint-disable-next-line @atlaskit/editor/no-as-casting
        eventTarget: e.target,
        // use mediaSingle here to align with annotation viewed event dispatched in editor
        eventTargetType: 'mediaSingle',
        viewMethod: VIEW_METHOD.BADGE
      });
    }
  };
  return jsx(CommentBadge, _extends({
    onMouseEnter: () => setEntered(true),
    onMouseLeave: () => setEntered(false),
    status: entered ? 'entered' : status,
    onClick: onClick
    // Ignored via go/ees005
    // eslint-disable-next-line react/jsx-props-no-spreading
  }, rest));
};

/**
 * Remove CommentBadgeWrapper component above
 * and rename CommentBadgeNextWrapper to CommentBadgeWrapper
 * when clean up platform_editor_add_media_from_url feature flag
 */

const CommentBadgeNextWrapper = ({
  marks,
  mediaSingleElement,
  isDrafting = false,
  ...rest
}) => {
  var _marks$map2;
  const [status, setStatus] = useState('default');
  const [entered, setEntered] = useState(false);
  const updateSubscriber = useInlineCommentSubscriberContext();
  const activeParentIds = useInlineCommentsFilter({
    annotationIds: (_marks$map2 = marks === null || marks === void 0 ? void 0 : marks.map(mark => mark.attrs.id)) !== null && _marks$map2 !== void 0 ? _marks$map2 : [''],
    filter: {
      state: AnnotationMarkStates.ACTIVE
    }
  });
  useEffect(() => {
    const observer = new MutationObserver(mutationList => {
      mutationList.forEach(mutation => {
        const parentNode = mutation.target.parentNode;
        if (mutation.attributeName === 'data-has-focus') {
          const isMediaCaption = parentNode === null || parentNode === void 0 ? void 0 : parentNode.closest('[data-media-caption="true"]');
          const elementHasFocus = (parentNode === null || parentNode === void 0 ? void 0 : parentNode.querySelector('[data-has-focus="true"]')) && !isMediaCaption;
          elementHasFocus ? setStatus('active') : setStatus('default');
        }
      });
    });
    if (mediaSingleElement) {
      observer.observe(mediaSingleElement, {
        attributes: true,
        subtree: true,
        attributeFilter: ['data-has-focus']
      });
    }
    return () => {
      observer.disconnect();
    };
  }, [mediaSingleElement, setStatus]);
  if (!isDrafting && !activeParentIds.length) {
    return null;
  }
  const onClick = e => {
    e.preventDefault();
    if (updateSubscriber) {
      updateSubscriber.emit(AnnotationUpdateEvent.ON_ANNOTATION_CLICK, {
        annotationIds: activeParentIds,
        // Ignored via go/ees005
        // eslint-disable-next-line @atlaskit/editor/no-as-casting
        eventTarget: e.target,
        // use mediaSingle here to align with annotation viewed event dispatched in editor
        eventTargetType: 'mediaSingle',
        viewMethod: VIEW_METHOD.BADGE
      });
    }
  };
  return jsx(CommentBadgeNext, _extends({
    onMouseEnter: () => setEntered(true),
    onMouseLeave: () => setEntered(false),
    status: entered ? 'entered' : status,
    onClick: onClick,
    mediaSingleElement: mediaSingleElement
    // Ignored via go/ees005
    // eslint-disable-next-line react/jsx-props-no-spreading
  }, rest));
};

// Ignored via go/ees005
// eslint-disable-next-line @repo/internal/react/no-class-components
class Media extends PureComponent {
  constructor(props) {
    super(props);
    _defineProperty(this, "renderCard", (providers = {}) => {
      const {
        contextIdentifierProvider
      } = providers;
      const {
        allowAltTextOnImages,
        alt,
        featureFlags,
        shouldOpenMediaViewer: allowMediaViewer,
        enableDownloadButton,
        ssr,
        width,
        height,
        mediaSingleElement,
        isDrafting = false
      } = this.props;
      const annotationMarks = this.props.isAnnotationMark ? this.props.marks.filter(this.props.isAnnotationMark) : undefined;
      const borderMark = this.props.marks.find(this.props.isBorderMark);
      const linkMark = this.props.marks.find(this.props.isLinkMark);
      const linkHref = linkMark === null || linkMark === void 0 ? void 0 : linkMark.attrs.href;
      const eventHandlers = linkHref ? undefined : this.props.eventHandlers;
      const shouldOpenMediaViewer = !linkHref && allowMediaViewer;
      const isInPageInclude = mediaSingleElement === null || mediaSingleElement === void 0 ? void 0 : mediaSingleElement.closest('[data-node-type="include"]');
      const isIncludeExcerpt = !!(mediaSingleElement !== null && mediaSingleElement !== void 0 && mediaSingleElement.closest('.ak-excerpt-include'));
      const showCommentBadge = !!annotationMarks && !isInPageInclude && !isIncludeExcerpt;
      const shouldShowExternalMediaBadge = this.props.type === 'external';
      return jsx(MediaLink, {
        mark: linkMark,
        onClick: this.handleMediaLinkClickFn
      }, jsx(MediaAnnotations, {
        marks: annotationMarks
      }, jsx(MediaBorder, {
        mark: borderMark
      }, jsx(AnalyticsContext, {
        data: {
          [MEDIA_CONTEXT]: {
            border: !!borderMark
          }
        }
      }, editorExperiment('add-media-from-url', true) && jsx(MediaBadges, {
        mediaElement: mediaSingleElement,
        mediaWidth: width,
        mediaHeight: height,
        useMinimumZIndex: true
      }, ({
        badgeSize,
        visible
      }) => jsx(React.Fragment, null, fg('platform_editor_hide_external_media_badge') ? visible && jsx(ExternalImageBadge, {
        badgeSize: badgeSize,
        type: this.props.type,
        url: this.props.type === 'external' ? this.props.url : undefined
      }) : shouldShowExternalMediaBadge && jsx(ExternalImageBadge, {
        badgeSize: badgeSize
      }), showCommentBadge && jsx(CommentBadgeNextWrapper, {
        marks: annotationMarks,
        mediaSingleElement: mediaSingleElement,
        isDrafting: isDrafting,
        badgeSize: badgeSize
      }))), !editorExperiment('add-media-from-url', true) && showCommentBadge && jsx(CommentBadgeWrapper, {
        marks: annotationMarks,
        mediaSingleElement: mediaSingleElement,
        width: width,
        height: height,
        isDrafting: isDrafting
      }), jsx(MediaCard, _extends({
        contextIdentifierProvider: contextIdentifierProvider
        // Ignored via go/ees005
        // eslint-disable-next-line react/jsx-props-no-spreading
      }, this.props, {
        shouldOpenMediaViewer: shouldOpenMediaViewer,
        eventHandlers: eventHandlers,
        alt: allowAltTextOnImages ? alt : undefined,
        featureFlags: featureFlags,
        shouldEnableDownloadButton: enableDownloadButton,
        ssr: ssr
      }))))));
    });
    _defineProperty(this, "handleMediaLinkClick", event => {
      const {
        fireAnalyticsEvent,
        isLinkMark,
        marks
      } = this.props;
      if (fireAnalyticsEvent) {
        fireAnalyticsEvent({
          action: ACTION.VISITED,
          actionSubject: ACTION_SUBJECT.MEDIA,
          actionSubjectId: ACTION_SUBJECT_ID.LINK,
          eventType: EVENT_TYPE.TRACK,
          attributes: {
            platform: PLATFORM.WEB,
            mode: MODE.RENDERER
          }
        });
      }
      const linkMark = this.props.marks.find(this.props.isLinkMark);
      const linkHref = linkMark === null || linkMark === void 0 ? void 0 : linkMark.attrs.href;
      const handler = getEventHandler(this.props.eventHandlers, 'link');
      if (handler) {
        const linkMark = marks.find(isLinkMark);
        handler(event, linkMark && linkHref);
      }
    });
    this.handleMediaLinkClickFn = this.handleMediaLinkClick.bind(this);
  }
  render() {
    const {
      providers
    } = this.props;
    if (!providers) {
      return this.renderCard();
    }
    return jsx(WithProviders, {
      providers: ['mediaProvider', 'contextIdentifierProvider'],
      providerFactory: providers,
      renderNode: this.renderCard
    });
  }
}
const MediaWithDraftAnnotation = props => {
  const draftPosition = React.useContext(AnnotationsDraftContext);
  const {
    dataAttributes
  } = props;
  const pos = dataAttributes && dataAttributes['data-renderer-start-pos'];
  const [position, setPosition] = useState();
  const [shouldApplyDraftAnnotation, setShouldApplyDraftAnnotation] = useState(false);
  useEffect(() => {
    var _draftPosition$from;
    if (pos === undefined) {
      return;
    }
    const posToCheck = ((_draftPosition$from = draftPosition === null || draftPosition === void 0 ? void 0 : draftPosition.from) !== null && _draftPosition$from !== void 0 ? _draftPosition$from : 0) + 1;
    if (draftPosition !== null && posToCheck === pos) {
      setShouldApplyDraftAnnotation(true);
      setPosition(posToCheck);
    } else if (draftPosition === null && shouldApplyDraftAnnotation) {
      setShouldApplyDraftAnnotation(false);
      setPosition(undefined);
    }
  }, [draftPosition, pos, shouldApplyDraftAnnotation]);
  const applyDraftAnnotation = props.allowAnnotationsDraftMode && shouldApplyDraftAnnotation && position !== undefined;
  const dataAttributesWithDraftAnnotation = useMemo(() => applyDraftAnnotation ? {
    ...dataAttributes,
    'data-annotation-draft-mark': true,
    'data-renderer-mark': true
  } : dataAttributes, [applyDraftAnnotation, dataAttributes]);
  return jsx(Media
  // Ignored via go/ees005
  // eslint-disable-next-line react/jsx-props-no-spreading
  , _extends({}, props, {
    dataAttributes: dataAttributesWithDraftAnnotation,
    isDrafting: shouldApplyDraftAnnotation
  }));
};
export default MediaWithDraftAnnotation;