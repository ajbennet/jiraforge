import _extends from "@babel/runtime/helpers/extends";
import _defineProperty from "@babel/runtime/helpers/defineProperty";
/**
 * @jsxRuntime classic
 * @jsx jsx
 */
import React, { Fragment, PureComponent, useCallback, useContext, useEffect, useLayoutEffect, useMemo, useRef } from 'react';
// eslint-disable-next-line @atlaskit/ui-styling-standard/use-compiled -- Ignored via go/DSP-18766
import { getSchemaBasedOnStage } from '@atlaskit/adf-schema/schema-default';
import { ProviderFactory, ProviderFactoryProvider } from '@atlaskit/editor-common/provider-factory';
import { BaseTheme, IntlErrorBoundary, UnsupportedBlock, WidthProvider, WithCreateAnalyticsEvent } from '@atlaskit/editor-common/ui';
import { editorExperiment } from '@atlaskit/tmp-editor-statsig/experiments';
// eslint-disable-next-line @atlaskit/ui-styling-standard/use-compiled -- Ignored via go/DSP-18766
import { css, jsx } from '@emotion/react';
import { browser } from '@atlaskit/editor-common/browser';
import { startMeasure, stopMeasure } from '@atlaskit/editor-common/performance-measures';
import { getDistortedDurationMonitor } from '@atlaskit/editor-common/performance/measure-render';
import { getResponseEndTime } from '@atlaskit/editor-common/performance/navigation';
import { getAnalyticsAppearance, getAnalyticsEventSeverity, shouldForceTracking } from '@atlaskit/editor-common/utils';
import { fg } from '@atlaskit/platform-feature-flags';
import { FabricChannel } from '@atlaskit/analytics-listeners/types';
import { FabricEditorAnalyticsContext } from '@atlaskit/analytics-namespaced-context';
import { ACTION, ACTION_SUBJECT, EVENT_TYPE } from '@atlaskit/editor-common/analytics';
import { normalizeFeatureFlags } from '@atlaskit/editor-common/normalize-feature-flags';
import { akEditorFullPageDefaultFontSize } from '@atlaskit/editor-shared-styles';
import memoizeOne from 'memoize-one';
import uuid from 'uuid/v4';
import { ReactSerializer, renderDocument } from '../../';
import AnalyticsContext from '../../analytics/analyticsContext';
import { MODE, PLATFORM } from '../../analytics/events';
import { EditorMediaClientProvider } from '../../react/utils/EditorMediaClientProvider';
import { getActiveHeadingId, isNestedHeaderLinksEnabled } from '../../react/utils/links';
import { RendererContextProvider, useRendererContext } from '../../renderer-context';
import { findInTree } from '../../utils';
import { RendererContext as ActionsContext, RendererActionsContext } from '../RendererActionsContext';
import { Provider as SmartCardStorageProvider } from '../SmartCardStorage';
import { ActiveHeaderIdProvider } from '../active-header-id-provider';
import { AnnotationsPositionContext, AnnotationsWrapper } from '../annotations';
import { ErrorBoundary } from './ErrorBoundary';
import { BreakoutSSRInlineScript } from './breakout-ssr';
import { isInteractiveElement } from './click-to-edit';
import { countNodes } from './count-nodes';
import { TELEPOINTER_ID, rendererStyles } from './style';
import { TruncatedWrapper } from './truncated-wrapper';
import { ValidationContext } from './ValidationContext';
export const NORMAL_SEVERITY_THRESHOLD = 2000;
export const DEGRADED_SEVERITY_THRESHOLD = 3000;
const packageName = "@atlaskit/renderer";
const packageVersion = "112.15.0";
const setAsQueryContainerStyles = css({
  containerName: 'ak-renderer-wrapper',
  containerType: 'inline-size',
  contain: 'layout style inline-size'
});

/**
 * Exported due to enzyme test reliance on this component.
 */
// eslint-disable-next-line @repo/internal/react/no-class-components
export class __RendererClassComponent extends PureComponent {
  constructor(props) {
    super(props);
    /**
     * This is used in measuring the Renderer Mount time and is then
     * deleted once that measurement occurs.
     */
    _defineProperty(this, "renderedMeasurementDistortedDurationMonitor", getDistortedDurationMonitor());
    _defineProperty(this, "createRendererContext", memoizeOne((featureFlags, isTopLevelRenderer) => {
      const normalizedFeatureFlags = normalizeFeatureFlags(featureFlags);
      return {
        featureFlags: normalizedFeatureFlags,
        // The context is uninitialized at the top level. In nested levels it's all false
        isTopLevelRenderer: isTopLevelRenderer === undefined
      };
    }));
    _defineProperty(this, "fireAnalyticsEvent", event => {
      const {
        createAnalyticsEvent
      } = this.props;
      if (createAnalyticsEvent) {
        const channel = FabricChannel.editor;
        createAnalyticsEvent(event).fire(channel);
      }
    });
    _defineProperty(this, "getSchema", memoizeOne((schema, adfStage) => {
      if (schema) {
        return schema;
      }
      return getSchemaBasedOnStage(adfStage);
    }));
    _defineProperty(this, "onMouseDownEditView", () => {
      // When the user is deselecting text on the screen by clicking, if they are clicking outside
      // the current selection, by the time the onclick handler is called the window.getSelection()
      // value will already be cleared.
      // The mousedown callback is called before the selection is cleared.
      const windowSelection = window.getSelection();
      this.mouseDownSelection = windowSelection !== null ? windowSelection.toString() : undefined;
    });
    _defineProperty(this, "handleMouseTripleClickInTables", event => {
      var _parentElement, _parentElement2;
      if (browser.ios || browser.android) {
        return;
      }
      const badBrowser = browser.chrome || browser.safari;
      const tripleClick = event.detail >= 3;
      if (!(badBrowser && tripleClick)) {
        return;
      }
      const selection = window.getSelection();
      if (!selection) {
        return;
      }
      const {
        type,
        anchorNode,
        focusNode
      } = selection;
      const rangeSelection = Boolean(type === 'Range' && anchorNode && focusNode);
      if (!rangeSelection) {
        return;
      }
      // Ignored via go/ees005
      // eslint-disable-next-line @atlaskit/editor/no-as-casting
      const target = event.target;
      const tableCell = target.closest('td,th');
      const clickedInCell = Boolean(tableCell);
      if (!clickedInCell) {
        return;
      }
      // Ignored via go/ees005
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const anchorInCell = tableCell.contains(anchorNode);
      // Ignored via go/ees005
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const focusInCell = tableCell.contains(focusNode);
      const selectionStartsOrEndsOutsideClickedCell = !(anchorInCell && focusInCell);
      if (!selectionStartsOrEndsOutsideClickedCell) {
        return;
      }
      // If selection starts or ends in a different cell than the clicked cell,
      // we select the node inside the clicked cell (or if both are in a different
      // cell, we select the cell's contents instead). We want to select the nearest
      // parent block, so that a whole line of text/content is selected (rather than
      // selecting a span that would select one specific chunk of text).
      const elementToSelect = anchorInCell ? // Ignored via go/ees005
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      (_parentElement = anchorNode.parentElement) === null || _parentElement === void 0 ? void 0 : _parentElement.closest('div,p') : focusInCell ? // Ignored via go/ees005
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      (_parentElement2 = focusNode.parentElement) === null || _parentElement2 === void 0 ? void 0 : _parentElement2.closest('div,p') : tableCell;
      if (elementToSelect) {
        selection.selectAllChildren(elementToSelect);
      }
    });
    this.providerFactory = props.dataProviders || new ProviderFactory();
    this.serializer = new ReactSerializer(this.deriveSerializerProps(props));
    this.editorRef = props.innerRef || /*#__PURE__*/React.createRef();
    this.id = uuid();
    startMeasure(`Renderer Render Time: ${this.id}`);
  }
  anchorLinkAnalytics() {
    const hash = window.location.hash && decodeURIComponent(window.location.hash.slice(1));
    const {
      disableHeadingIDs
    } = this.props;
    if (!disableHeadingIDs && hash && this.editorRef && this.editorRef.current instanceof HTMLElement) {
      const anchorLinkElement = document.getElementById(hash);
      // We are not use this.editorRef.querySelector here, instead we have this.editorRef.contains
      // because querySelector might fail if there are special characters in hash, and CSS.escape is still experimental.
      if (anchorLinkElement && this.editorRef.current.contains(anchorLinkElement)) {
        this.fireAnalyticsEvent({
          action: ACTION.VIEWED,
          actionSubject: ACTION_SUBJECT.ANCHOR_LINK,
          attributes: {
            platform: PLATFORM.WEB,
            mode: MODE.RENDERER
          },
          eventType: EVENT_TYPE.UI
        });
      }
    }
  }
  componentDidMount() {
    this.fireAnalyticsEvent({
      action: ACTION.STARTED,
      actionSubject: ACTION_SUBJECT.RENDERER,
      attributes: {
        platform: PLATFORM.WEB
      },
      eventType: EVENT_TYPE.UI
    });
    this.rafID = requestAnimationFrame(() => {
      stopMeasure(`Renderer Render Time: ${this.id}`, duration => {
        var _analyticsEventSeveri, _analyticsEventSeveri2, _this$props, _this$props$analytics;
        const {
          analyticsEventSeverityTracking
        } = this.props;
        const forceSeverityTracking = typeof analyticsEventSeverityTracking === 'undefined' && shouldForceTracking();
        const severity = !!forceSeverityTracking || analyticsEventSeverityTracking !== null && analyticsEventSeverityTracking !== void 0 && analyticsEventSeverityTracking.enabled ? getAnalyticsEventSeverity(duration, (_analyticsEventSeveri = analyticsEventSeverityTracking === null || analyticsEventSeverityTracking === void 0 ? void 0 : analyticsEventSeverityTracking.severityNormalThreshold) !== null && _analyticsEventSeveri !== void 0 ? _analyticsEventSeveri : NORMAL_SEVERITY_THRESHOLD, (_analyticsEventSeveri2 = analyticsEventSeverityTracking === null || analyticsEventSeverityTracking === void 0 ? void 0 : analyticsEventSeverityTracking.severityDegradedThreshold) !== null && _analyticsEventSeveri2 !== void 0 ? _analyticsEventSeveri2 : DEGRADED_SEVERITY_THRESHOLD) : undefined;

        // ED-16320: Check for explicit disable so that by default
        // it will still be enabled as it currently is. Then we can
        // progressively opt out synthetic tenants.
        const isTTRTrackingExplicitlyDisabled = ((_this$props = this.props) === null || _this$props === void 0 ? void 0 : (_this$props$analytics = _this$props.analyticsEventSeverityTracking) === null || _this$props$analytics === void 0 ? void 0 : _this$props$analytics.enabled) === false;
        if (!isTTRTrackingExplicitlyDisabled) {
          this.fireAnalyticsEvent({
            action: ACTION.RENDERED,
            actionSubject: ACTION_SUBJECT.RENDERER,
            attributes: {
              platform: PLATFORM.WEB,
              duration,
              distortedDuration:
              // Ignored via go/ees005
              // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
              this.renderedMeasurementDistortedDurationMonitor.distortedDuration,
              ttfb: getResponseEndTime(),
              nodes: countNodes(this.props.document),
              severity
            },
            eventType: EVENT_TYPE.OPERATIONAL
          });
        }

        // Ignored via go/ees005
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        this.renderedMeasurementDistortedDurationMonitor.cleanup();
        delete this.renderedMeasurementDistortedDurationMonitor;
      });
      this.anchorLinkAnalytics();
    });
  }

  // Ignored via go/ees005
  // eslint-disable-next-line react/no-unsafe
  UNSAFE_componentWillReceiveProps(nextProps) {
    const nextMedia = nextProps.media || {};
    const media = this.props.media || {};
    if (nextProps.portal !== this.props.portal || nextProps.appearance !== this.props.appearance || nextProps.stickyHeaders !== this.props.stickyHeaders || nextProps.disableActions !== this.props.disableActions || nextProps.allowCustomPanels !== this.props.allowCustomPanels || nextProps.extensionHandlers !== this.props.extensionHandlers || nextProps.allowHeadingAnchorLinks !== this.props.allowHeadingAnchorLinks || nextMedia.allowLinking !== media.allowLinking) {
      this.serializer = new ReactSerializer(this.deriveSerializerProps(nextProps));
    }
  }
  deriveSerializerProps(props) {
    // if just passed a boolean, change shape into object to simplify type
    const stickyHeaders = props.stickyHeaders ? props.stickyHeaders === true ? {} : props.stickyHeaders : undefined;
    const {
      annotationProvider
    } = props;
    const allowAnnotationsDraftMode = Boolean(annotationProvider && annotationProvider.inlineComment && annotationProvider.inlineComment.allowDraftMode);
    const {
      featureFlags
    } = this.createRendererContext(props.featureFlags, props.isTopLevelRenderer);
    return {
      startPos: props.startPos,
      providers: this.providerFactory,
      eventHandlers: props.eventHandlers,
      extensionHandlers: props.extensionHandlers,
      portal: props.portal,
      objectContext: {
        adDoc: props.document,
        schema: props.schema,
        ...props.rendererContext
      },
      appearance: props.appearance,
      disableHeadingIDs: props.disableHeadingIDs,
      disableActions: props.disableActions,
      allowHeadingAnchorLinks: props.allowHeadingAnchorLinks,
      allowColumnSorting: props.allowColumnSorting,
      fireAnalyticsEvent: this.fireAnalyticsEvent,
      shouldOpenMediaViewer: props.shouldOpenMediaViewer,
      allowAltTextOnImages: props.allowAltTextOnImages,
      stickyHeaders,
      allowMediaLinking: props.media && props.media.allowLinking,
      surroundTextNodesWithTextWrapper: allowAnnotationsDraftMode,
      media: props.media,
      emojiResourceConfig: props.emojiResourceConfig,
      smartLinks: props.smartLinks,
      allowCopyToClipboard: props.allowCopyToClipboard,
      allowWrapCodeBlock: props.allowWrapCodeBlock,
      allowCustomPanels: props.allowCustomPanels,
      allowAnnotations: props.allowAnnotations,
      allowSelectAllTrap: props.allowSelectAllTrap,
      allowPlaceholderText: props.allowPlaceholderText,
      nodeComponents: props.nodeComponents,
      // does not currently support SSR, should not be enabled in environments where Renderer is SSR-ed
      allowWindowedCodeBlock: featureFlags === null || featureFlags === void 0 ? void 0 : featureFlags.allowWindowedCodeBlock,
      isInsideOfInlineExtension: props.isInsideOfInlineExtension,
      textHighlighter: props.UNSTABLE_textHighlighter,
      allowTableAlignment: props.UNSTABLE_allowTableAlignment,
      allowTableResizing: props.UNSTABLE_allowTableResizing
    };
  }
  render() {
    const {
      document: adfDocument,
      onComplete,
      onError,
      appearance,
      allowAnnotations,
      adfStage,
      truncated,
      maxHeight,
      fadeOutHeight,
      enableSsrInlineScripts,
      noOpSSRInlineScript,
      allowHeadingAnchorLinks,
      allowPlaceholderText,
      allowColumnSorting,
      allowCopyToClipboard,
      allowWrapCodeBlock,
      allowCustomPanels,
      media,
      skipValidation
    } = this.props;
    const rendererContext = this.createRendererContext(this.props.featureFlags, this.props.isTopLevelRenderer);
    const allowNestedHeaderLinks = isNestedHeaderLinksEnabled(allowHeadingAnchorLinks);
    /**
     * Handle clicks inside renderer. If the click isn't on media, in the media picker, or on a
     * link, call the onUnhandledClick eventHandler (which in Jira for example, may switch the
     * renderer out for the editor).
     * @param event Click event anywhere inside renderer
     */
    const handleWrapperOnClick = event => {
      var _this$props$eventHand;
      // Ignored via go/ees005
      // eslint-disable-next-line @atlaskit/editor/no-as-casting
      const targetElement = event.target;

      // ED-14862: When a user triple clicks to select a line of content inside a
      // a table cell, but the browser incorrectly moves the selection start or end into
      // a different table cell, we manually set the selection back to within the original
      // table cell the user intended to target
      this.handleMouseTripleClickInTables(event);
      if (!((_this$props$eventHand = this.props.eventHandlers) !== null && _this$props$eventHand !== void 0 && _this$props$eventHand.onUnhandledClick)) {
        return;
      }
      if (!(targetElement instanceof window.Element)) {
        return;
      }

      // Ignored via go/ees005
      // eslint-disable-next-line @atlaskit/editor/no-as-casting
      const rendererWrapper = event.currentTarget;

      // Check if the click was on an interactive element
      const isInteractiveElementInTree = findInTree(targetElement, rendererWrapper, isInteractiveElement);
      if (isInteractiveElementInTree) {
        return;
      }

      // Ensure that selecting text in the renderer doesn't trigger onUnhandledClick
      // This logic originated in jira-frontend:
      // src/packages/issue/issue-view/src/views/field/rich-text/rich-text-inline-edit-view.js

      // The selection is required to be checked in `onMouseDown` and here. If not here, a new
      // selection isn't reported; if not in `onMouseDown`, a click outside the selection will
      // return an empty selection, which will erroneously fire onUnhandledClick.
      const windowSelection = window.getSelection();
      const selection = windowSelection !== null ? windowSelection.toString() : undefined;
      const hasSelection = selection && selection.length !== 0;
      const hasSelectionMouseDown = this.mouseDownSelection && this.mouseDownSelection.length !== 0;
      const allowEditBasedOnSelection = !hasSelection && !hasSelectionMouseDown;
      if (allowEditBasedOnSelection) {
        this.props.eventHandlers.onUnhandledClick(event);
      }
    };
    try {
      var _rendererContext$feat;
      const schema = this.getSchema(this.props.schema, this.props.adfStage);
      const {
        result,
        stat,
        pmDoc
      } = renderDocument(adfDocument, this.serializer, schema, adfStage, this.props.useSpecBasedValidator, this.id, this.fireAnalyticsEvent, this.props.unsupportedContentLevelsTracking, this.props.appearance, this.props.includeNodesCountInStats, skipValidation);
      if (onComplete) {
        onComplete(stat);
      }
      const rendererOutput = jsx(RendererContextProvider, {
        value: rendererContext
      }, jsx(ActiveHeaderIdProvider, {
        value: getActiveHeadingId(allowHeadingAnchorLinks)
      }, jsx(AnalyticsContext.Provider, {
        value: {
          fireAnalyticsEvent: event => this.fireAnalyticsEvent(event)
        }
      }, jsx(SmartCardStorageProvider, null, jsx(ProviderFactoryProvider, {
        value: this.providerFactory
      }, jsx(RendererWrapper, {
        allowAnnotations: allowAnnotations,
        appearance: appearance,
        allowNestedHeaderLinks: allowNestedHeaderLinks,
        allowColumnSorting: allowColumnSorting,
        allowCopyToClipboard: allowCopyToClipboard,
        allowWrapCodeBlock: allowWrapCodeBlock,
        allowCustomPanels: allowCustomPanels,
        allowPlaceholderText: allowPlaceholderText,
        useBlockRenderForCodeBlock: (_rendererContext$feat = rendererContext.featureFlags.useBlockRenderForCodeBlock) !== null && _rendererContext$feat !== void 0 ? _rendererContext$feat : true,
        addTelepointer: this.props.addTelepointer,
        innerRef: this.editorRef,
        onClick: handleWrapperOnClick,
        onMouseDown: this.onMouseDownEditView,
        ssr: media === null || media === void 0 ? void 0 : media.ssr,
        isInsideOfInlineExtension: this.props.isInsideOfInlineExtension,
        isTopLevelRenderer: rendererContext.isTopLevelRenderer
      }, enableSsrInlineScripts || noOpSSRInlineScript ? jsx(BreakoutSSRInlineScript, {
        noOpSSRInlineScript: Boolean(noOpSSRInlineScript)
      }) : null, jsx(RendererActionsInternalUpdater, {
        doc: pmDoc,
        schema: schema,
        onAnalyticsEvent: this.fireAnalyticsEvent
      }, result)))))));
      const rendererResult = truncated ? jsx(TruncatedWrapper, {
        height: maxHeight,
        fadeHeight: fadeOutHeight
      }, rendererOutput) : rendererOutput;
      return jsx(Fragment, null, rendererResult);
    } catch (e) {
      var _rendererContext$feat2;
      if (onError) {
        onError(e);
      }
      return jsx(RendererWrapper, {
        allowAnnotations: allowAnnotations,
        appearance: appearance,
        allowCopyToClipboard: allowCopyToClipboard,
        allowWrapCodeBlock: allowWrapCodeBlock,
        allowPlaceholderText: allowPlaceholderText,
        allowColumnSorting: allowColumnSorting,
        allowNestedHeaderLinks: allowNestedHeaderLinks,
        useBlockRenderForCodeBlock: (_rendererContext$feat2 = rendererContext.featureFlags.useBlockRenderForCodeBlock) !== null && _rendererContext$feat2 !== void 0 ? _rendererContext$feat2 : true,
        addTelepointer: this.props.addTelepointer,
        onClick: handleWrapperOnClick,
        isTopLevelRenderer: rendererContext.isTopLevelRenderer
      }, jsx(UnsupportedBlock, null));
    }
  }
  componentWillUnmount() {
    const {
      dataProviders
    } = this.props;
    if (this.rafID) {
      window.cancelAnimationFrame(this.rafID);
    }

    // if this is the ProviderFactory which was created in constructor
    // it's safe to destroy it on Renderer unmount
    if (!dataProviders) {
      this.providerFactory.destroy();
    }
  }
}
const handleMouseTripleClickInTables = event => {
  var _parentElement3, _parentElement4;
  if (browser.ios || browser.android) {
    return;
  }
  const badBrowser = browser.chrome || browser.safari;
  const tripleClick = event.detail >= 3;
  if (!(badBrowser && tripleClick)) {
    return;
  }
  const selection = window.getSelection();
  if (!selection) {
    return;
  }
  const {
    type,
    anchorNode,
    focusNode
  } = selection;
  const rangeSelection = Boolean(type === 'Range' && anchorNode && focusNode);
  if (!rangeSelection) {
    return;
  }
  // Ignored via go/ees005
  // eslint-disable-next-line @atlaskit/editor/no-as-casting
  const target = event.target;
  const tableCell = target.closest('td,th');
  const clickedInCell = Boolean(tableCell);
  if (!clickedInCell) {
    return;
  }
  // Ignored via go/ees005
  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
  const anchorInCell = tableCell.contains(anchorNode);
  // Ignored via go/ees005
  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
  const focusInCell = tableCell.contains(focusNode);
  const selectionStartsOrEndsOutsideClickedCell = !(anchorInCell && focusInCell);
  if (!selectionStartsOrEndsOutsideClickedCell) {
    return;
  }

  // Ensure that selecting text in the renderer doesn't trigger onUnhandledClick
  // This logic originated in jira-frontend:
  // src/packages/issue/issue-view/src/views/field/rich-text/rich-text-inline-edit-view.js

  // The selection is required to be checked in `onMouseDown` and here. If not here, a new
  // selection isn't reported; if not in `onMouseDown`, a click outside the selection will
  // return an empty selection, which will erroneously fire onUnhandledClick.

  const elementToSelect = anchorInCell ? // Ignored via go/ees005
  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
  (_parentElement3 = anchorNode.parentElement) === null || _parentElement3 === void 0 ? void 0 : _parentElement3.closest('div,p') : focusInCell ? // Ignored via go/ees005
  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
  (_parentElement4 = focusNode.parentElement) === null || _parentElement4 === void 0 ? void 0 : _parentElement4.closest('div,p') : tableCell;
  if (elementToSelect) {
    selection.selectAllChildren(elementToSelect);
  }
};

/**
 * Handle clicks inside renderer. If the click isn't on media, in the media picker, or on a
 * link, call the onUnhandledClick eventHandler (which in Jira for example, may switch the
 * renderer out for the editor).
 * @param event Click event anywhere inside renderer
 */
const handleWrapperOnClick = (event, props, mouseDownSelection) => {
  var _props$eventHandlers;
  // Ignored via go/ees005
  // eslint-disable-next-line @atlaskit/editor/no-as-casting
  const targetElement = event.target;
  handleMouseTripleClickInTables(event);

  // ED-14862: When a user triple clicks to select a line of content inside a
  // a table cell, but the browser incorrectly moves the selection start or end into
  // a different table cell, we manually set the selection back to within the original
  // table cell the user intended to target
  if (!((_props$eventHandlers = props.eventHandlers) !== null && _props$eventHandlers !== void 0 && _props$eventHandlers.onUnhandledClick)) {
    return;
  }
  if (!(targetElement instanceof window.Element)) {
    return;
  }

  // Ignored via go/ees005
  // eslint-disable-next-line @atlaskit/editor/no-as-casting
  const rendererWrapper = event.currentTarget;
  const isInteractiveElementInTree = findInTree(targetElement, rendererWrapper, isInteractiveElement);
  if (isInteractiveElementInTree) {
    return;
  }

  // Ensure that selecting text in the renderer doesn't trigger onUnhandledClick
  // This logic originated in jira-frontend:
  // src/packages/issue/issue-view/src/views/field/rich-text/rich-text-inline-edit-view.js

  // The selection is required to be checked in `onMouseDown` and here. If not here, a new
  // selection isn't reported; if not in `onMouseDown`, a click outside the selection will
  // return an empty selection, which will erroneously fire onUnhandledClick.
  const windowSelection = window.getSelection();
  const selection = windowSelection !== null ? windowSelection.toString() : undefined;
  const hasSelection = selection && selection.length !== 0;
  const hasSelectionMouseDown = mouseDownSelection.current && mouseDownSelection.current.length !== 0;
  const allowEditBasedOnSelection = !hasSelection && !hasSelectionMouseDown;
  if (allowEditBasedOnSelection) {
    props.eventHandlers.onUnhandledClick(event);
  }
};
const RendererFunctionalComponent = props => {
  const mouseDownSelection = useRef(undefined);
  const providerFactory = useMemo(() => props.dataProviders || new ProviderFactory(), [props.dataProviders]);
  const createRendererContext = useMemo(() => (featureFlags, isTopLevelRenderer) => {
    const normalizedFeatureFlags = normalizeFeatureFlags(featureFlags);
    return {
      featureFlags: normalizedFeatureFlags,
      isTopLevelRenderer: isTopLevelRenderer === undefined
    };
  }, []);
  const fireAnalyticsEvent = useCallback(event => {
    const {
      createAnalyticsEvent
    } = props;
    if (createAnalyticsEvent) {
      const channel = FabricChannel.editor;
      createAnalyticsEvent(event).fire(channel);
    }
  }, [props]);
  const deriveSerializerProps = useCallback(props => {
    const stickyHeaders = props.stickyHeaders ? props.stickyHeaders === true ? {} : props.stickyHeaders : undefined;
    const {
      annotationProvider
    } = props;
    const allowAnnotationsDraftMode = Boolean(annotationProvider && annotationProvider.inlineComment && annotationProvider.inlineComment.allowDraftMode);
    const {
      featureFlags
    } = createRendererContext(props.featureFlags, props.isTopLevelRenderer);
    return {
      startPos: props.startPos,
      providers: providerFactory,
      eventHandlers: props.eventHandlers,
      extensionHandlers: props.extensionHandlers,
      portal: props.portal,
      objectContext: {
        adDoc: props.document,
        schema: props.schema,
        ...props.rendererContext
      },
      appearance: props.appearance,
      disableHeadingIDs: props.disableHeadingIDs,
      disableActions: props.disableActions,
      allowHeadingAnchorLinks: props.allowHeadingAnchorLinks,
      allowColumnSorting: props.allowColumnSorting,
      fireAnalyticsEvent: fireAnalyticsEvent,
      shouldOpenMediaViewer: props.shouldOpenMediaViewer,
      allowAltTextOnImages: props.allowAltTextOnImages,
      stickyHeaders,
      allowMediaLinking: props.media && props.media.allowLinking,
      surroundTextNodesWithTextWrapper: allowAnnotationsDraftMode,
      media: props.media,
      emojiResourceConfig: props.emojiResourceConfig,
      smartLinks: props.smartLinks,
      allowCopyToClipboard: props.allowCopyToClipboard,
      allowWrapCodeBlock: props.allowWrapCodeBlock,
      allowCustomPanels: props.allowCustomPanels,
      allowAnnotations: props.allowAnnotations,
      allowSelectAllTrap: props.allowSelectAllTrap,
      allowPlaceholderText: props.allowPlaceholderText,
      nodeComponents: props.nodeComponents,
      allowWindowedCodeBlock: featureFlags === null || featureFlags === void 0 ? void 0 : featureFlags.allowWindowedCodeBlock,
      isInsideOfInlineExtension: props.isInsideOfInlineExtension,
      textHighlighter: props.UNSTABLE_textHighlighter,
      allowTableAlignment: props.UNSTABLE_allowTableAlignment,
      allowTableResizing: props.UNSTABLE_allowTableResizing
    };
  }, [createRendererContext, providerFactory, fireAnalyticsEvent]);
  const serializer = useMemo(() => {
    var _props$startPos;
    return new ReactSerializer(deriveSerializerProps({
      ...props,
      startPos: (_props$startPos = props.startPos) !== null && _props$startPos !== void 0 ? _props$startPos : 0
    }));
  }, [deriveSerializerProps, props]);
  const localRef = useRef(null);
  const editorRef = props.innerRef || localRef;
  const id = useMemo(() => uuid(), []);
  const renderedMeasurementDistortedDurationMonitor = useMemo(() => getDistortedDurationMonitor(), []);

  // we are doing this to ensure it runs as
  // early as possible in the React lifecycle
  // to avoid any other side effects
  const measureStarted = useRef(false);
  const startAnalyticsMeasure = () => {
    startMeasure(`Renderer Render Time: ${id}`);
  };
  if (!measureStarted.current) {
    startAnalyticsMeasure();
    measureStarted.current = true;
  }
  const anchorLinkAnalytics = useCallback(() => {
    const hash = window.location.hash && decodeURIComponent(window.location.hash.slice(1));
    const disableHeadingIDs = props.disableHeadingIDs;
    if (!disableHeadingIDs && hash && editorRef && editorRef.current instanceof HTMLElement) {
      const anchorLinkElement = document.getElementById(hash);
      if (anchorLinkElement && editorRef.current.contains(anchorLinkElement)) {
        fireAnalyticsEvent({
          action: ACTION.VIEWED,
          actionSubject: ACTION_SUBJECT.ANCHOR_LINK,
          attributes: {
            platform: PLATFORM.WEB,
            mode: MODE.RENDERER
          },
          eventType: EVENT_TYPE.UI
        });
      }
    }
  }, [props.disableHeadingIDs, editorRef, fireAnalyticsEvent]);
  const getSchema = useMemo(() => {
    return (schema, adfStage) => {
      if (schema) {
        return schema;
      }
      return getSchemaBasedOnStage(adfStage);
    };
  }, []);
  const onMouseDownEditView = () => {
    const windowSelection = window.getSelection();
    mouseDownSelection.current = windowSelection !== null ? windowSelection.toString() : undefined;
  };
  const {
    dataProviders,
    analyticsEventSeverityTracking
  } = props;
  useEffect(() => {
    let rafID;
    const handleAnalytics = () => {
      fireAnalyticsEvent({
        action: ACTION.STARTED,
        actionSubject: ACTION_SUBJECT.RENDERER,
        attributes: {
          platform: PLATFORM.WEB
        },
        eventType: EVENT_TYPE.UI
      });
      rafID = requestAnimationFrame(() => {
        stopMeasure(`Renderer Render Time: ${id}`, duration => {
          var _analyticsEventSeveri3, _analyticsEventSeveri4;
          const forceSeverityTracking = typeof analyticsEventSeverityTracking === 'undefined' && shouldForceTracking();
          const severity = !!forceSeverityTracking || analyticsEventSeverityTracking !== null && analyticsEventSeverityTracking !== void 0 && analyticsEventSeverityTracking.enabled ? getAnalyticsEventSeverity(duration, (_analyticsEventSeveri3 = analyticsEventSeverityTracking === null || analyticsEventSeverityTracking === void 0 ? void 0 : analyticsEventSeverityTracking.severityNormalThreshold) !== null && _analyticsEventSeveri3 !== void 0 ? _analyticsEventSeveri3 : NORMAL_SEVERITY_THRESHOLD, (_analyticsEventSeveri4 = analyticsEventSeverityTracking === null || analyticsEventSeverityTracking === void 0 ? void 0 : analyticsEventSeverityTracking.severityDegradedThreshold) !== null && _analyticsEventSeveri4 !== void 0 ? _analyticsEventSeveri4 : DEGRADED_SEVERITY_THRESHOLD) : undefined;
          const isTTRTrackingExplicitlyDisabled = (analyticsEventSeverityTracking === null || analyticsEventSeverityTracking === void 0 ? void 0 : analyticsEventSeverityTracking.enabled) === false;
          if (!isTTRTrackingExplicitlyDisabled) {
            fireAnalyticsEvent({
              action: ACTION.RENDERED,
              actionSubject: ACTION_SUBJECT.RENDERER,
              attributes: {
                platform: PLATFORM.WEB,
                duration,
                // Ignored via go/ees005
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                distortedDuration: renderedMeasurementDistortedDurationMonitor.distortedDuration,
                ttfb: getResponseEndTime(),
                nodes: countNodes(props.document),
                severity
              },
              eventType: EVENT_TYPE.OPERATIONAL
            });
          }

          // Ignored via go/ees005
          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
          renderedMeasurementDistortedDurationMonitor.cleanup();
        });
        anchorLinkAnalytics();
      });
    };
    handleAnalytics();
    return () => {
      if (rafID) {
        window.cancelAnimationFrame(rafID);
      }
      if (dataProviders) {
        providerFactory.destroy();
      }
    };
    // we are going to ignore this because I'm doing this on purpose
    // having a dependency array means we run stopMeasure twice per render
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);
  try {
    var _createRendererContex, _props$media;
    const schema = getSchema(props.schema, props.adfStage);
    const {
      result,
      stat,
      pmDoc
    } = renderDocument(props.document, serializer, schema, props.adfStage, props.useSpecBasedValidator, id, fireAnalyticsEvent, props.unsupportedContentLevelsTracking, props.appearance, props.includeNodesCountInStats, props.skipValidation);
    if (props.onComplete) {
      props.onComplete(stat);
    }
    const rendererOutput = jsx(RendererContextProvider, {
      value: createRendererContext(props.featureFlags, props.isTopLevelRenderer)
    }, jsx(ActiveHeaderIdProvider, {
      value: getActiveHeadingId(props.allowHeadingAnchorLinks)
    }, jsx(AnalyticsContext.Provider, {
      value: {
        fireAnalyticsEvent: event => fireAnalyticsEvent(event)
      }
    }, jsx(SmartCardStorageProvider, null, jsx(ProviderFactoryProvider, {
      value: providerFactory
    }, jsx(RendererWrapper, {
      allowAnnotations: props.allowAnnotations,
      appearance: props.appearance,
      allowNestedHeaderLinks: isNestedHeaderLinksEnabled(props.allowHeadingAnchorLinks),
      allowColumnSorting: props.allowColumnSorting,
      allowCopyToClipboard: props.allowCopyToClipboard,
      allowWrapCodeBlock: props.allowWrapCodeBlock,
      allowCustomPanels: props.allowCustomPanels,
      allowPlaceholderText: props.allowPlaceholderText,
      useBlockRenderForCodeBlock: (_createRendererContex = createRendererContext(props.featureFlags, props.isTopLevelRenderer).featureFlags.useBlockRenderForCodeBlock) !== null && _createRendererContex !== void 0 ? _createRendererContex : true,
      addTelepointer: props.addTelepointer,
      innerRef: editorRef,
      onClick: event => handleWrapperOnClick(event, props, mouseDownSelection),
      onMouseDown: onMouseDownEditView,
      ssr: (_props$media = props.media) === null || _props$media === void 0 ? void 0 : _props$media.ssr,
      isInsideOfInlineExtension: props.isInsideOfInlineExtension,
      isTopLevelRenderer: createRendererContext(props.featureFlags, props.isTopLevelRenderer).isTopLevelRenderer
    }, props.enableSsrInlineScripts || props.noOpSSRInlineScript ? jsx(BreakoutSSRInlineScript, {
      noOpSSRInlineScript: Boolean(props.noOpSSRInlineScript)
    }) : null, jsx(RendererActionsInternalUpdater, {
      doc: pmDoc,
      schema: schema,
      onAnalyticsEvent: fireAnalyticsEvent
    }, result)))))));
    const rendererResult = props.truncated ? jsx(TruncatedWrapper, {
      height: props.maxHeight,
      fadeHeight: props.fadeOutHeight
    }, rendererOutput) : rendererOutput;
    return jsx(Fragment, null, rendererResult);
  } catch (e) {
    var _createRendererContex2;
    if (props.onError) {
      props.onError(e);
    }
    return jsx(RendererWrapper, {
      allowAnnotations: props.allowAnnotations,
      appearance: props.appearance,
      allowCopyToClipboard: props.allowCopyToClipboard,
      allowWrapCodeBlock: props.allowWrapCodeBlock,
      allowPlaceholderText: props.allowPlaceholderText,
      allowColumnSorting: props.allowColumnSorting,
      allowNestedHeaderLinks: isNestedHeaderLinksEnabled(props.allowHeadingAnchorLinks),
      useBlockRenderForCodeBlock: (_createRendererContex2 = createRendererContext(props.featureFlags, props.isTopLevelRenderer).featureFlags.useBlockRenderForCodeBlock) !== null && _createRendererContex2 !== void 0 ? _createRendererContex2 : true,
      addTelepointer: props.addTelepointer,
      onClick: event => handleWrapperOnClick(event, props, mouseDownSelection),
      isTopLevelRenderer: createRendererContext(props.featureFlags, props.isTopLevelRenderer).isTopLevelRenderer
    }, jsx(UnsupportedBlock, null));
  }
};
export function Renderer(props) {
  const {
    startPos
  } = React.useContext(AnnotationsPositionContext);
  const {
    isTopLevelRenderer
  } = useRendererContext();
  const {
    skipValidation
  } = useContext(ValidationContext) || {};
  return fg('platform_editor_react18_renderer') ? jsx(RendererFunctionalComponent
  // Ignored via go/ees005
  // eslint-disable-next-line react/jsx-props-no-spreading
  , _extends({}, props, {
    startPos: startPos,
    isTopLevelRenderer: isTopLevelRenderer,
    skipValidation: skipValidation
  })) :
  // eslint-disable-next-line react/jsx-pascal-case
  jsx(__RendererClassComponent
  // Ignored via go/ees005
  // eslint-disable-next-line react/jsx-props-no-spreading
  , _extends({}, props, {
    startPos: startPos,
    isTopLevelRenderer: isTopLevelRenderer,
    skipValidation: skipValidation
  }));
}

// Usage notes:
// Used by Confluence for View page renderer
// For the nested renderers - see RendererWithAnnotationSelection.
export const RendererWithAnalytics = /*#__PURE__*/React.memo(props => jsx(FabricEditorAnalyticsContext, {
  data: {
    appearance: getAnalyticsAppearance(props.appearance),
    packageName,
    packageVersion,
    componentName: 'renderer',
    editorSessionId: uuid()
  }
}, jsx(WithCreateAnalyticsEvent, {
  render: createAnalyticsEvent => {
    // `IntlErrorBoundary` only captures Internationalisation errors, leaving others for `ErrorBoundary`.
    return jsx(ErrorBoundary, {
      component: ACTION_SUBJECT.RENDERER,
      rethrowError: true,
      fallbackComponent: null,
      createAnalyticsEvent: createAnalyticsEvent
    }, jsx(IntlErrorBoundary, null, jsx(Renderer
    // Ignored via go/ees005
    // eslint-disable-next-line react/jsx-props-no-spreading
    , _extends({}, props, {
      createAnalyticsEvent: createAnalyticsEvent
    }))));
  }
})));
const RendererWrapper = /*#__PURE__*/React.memo(props => {
  const {
    allowColumnSorting,
    allowNestedHeaderLinks,
    innerRef,
    appearance,
    children,
    onClick,
    onMouseDown,
    useBlockRenderForCodeBlock,
    addTelepointer,
    ssr,
    isInsideOfInlineExtension,
    allowTableResizing,
    isTopLevelRenderer
  } = props;
  const createTelepointer = () => {
    const telepointer = document.createElement('span');
    telepointer.textContent = '\u200b';
    telepointer.id = TELEPOINTER_ID;
    return telepointer;
  };
  const initialUpdate = React.useRef(true);
  useEffect(() => {
    // We must check if window is defined, if it isn't we are in a SSR environment
    // and we don't want to add the telepointer
    if (typeof window !== 'undefined' && addTelepointer && innerRef !== null && innerRef !== void 0 && innerRef.current) {
      // Ignored via go/ees005
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const renderer = innerRef.current.querySelector('.ak-renderer-document');
      if (initialUpdate.current) {
        const lastChild = renderer.lastChild;
        lastChild && lastChild.appendChild(createTelepointer());
      }
      const mutateTelepointer = mutations => {
        mutations.forEach(mutation => {
          if (initialUpdate.current) {
            const oldTelepointer = renderer.querySelector(`#${TELEPOINTER_ID}`);
            if (oldTelepointer) {
              oldTelepointer.remove();
            }
            const lastChild = renderer.lastChild;
            lastChild && lastChild.appendChild(createTelepointer());
            initialUpdate.current = false;
          }
          if (mutation.type === 'characterData') {
            const parentNode = mutation.target.parentElement;
            if (parentNode) {
              const oldTelepointer = renderer.querySelector(`#${TELEPOINTER_ID}`);
              if (oldTelepointer) {
                oldTelepointer.remove();
              }
              // Ignored via go/ees005
              // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
              parentNode.appendChild(createTelepointer());
            }
          }
        });
      };
      const observer = new MutationObserver(mutateTelepointer);
      observer.observe(innerRef.current, {
        characterData: true,
        attributes: false,
        childList: true,
        subtree: true
      });
      return () => observer.disconnect();
    }
  }, [innerRef, addTelepointer]);
  const renderer = jsx(WidthProvider
  // eslint-disable-next-line @atlaskit/ui-styling-standard/no-classname-prop -- Ignored via go/DSP-18766
  , {
    className: `ak-renderer-wrapper is-${appearance}`,
    "data-appearance": appearance,
    shouldCheckExistingValue: isInsideOfInlineExtension
  }, jsx(BaseTheme, {
    baseFontSize: appearance && appearance !== 'comment' ? akEditorFullPageDefaultFontSize : undefined
  }, jsx(EditorMediaClientProvider, {
    ssr: ssr
  }, jsx("div", {
    ref: innerRef,
    onClick: onClick,
    onMouseDown: onMouseDown
    // eslint-disable-next-line @atlaskit/design-system/consistent-css-prop-usage, @atlaskit/ui-styling-standard/no-imported-style-values -- Ignored via go/DSP-18766
    ,
    css: rendererStyles({
      appearance,
      allowNestedHeaderLinks,
      allowColumnSorting: !!allowColumnSorting,
      useBlockRenderForCodeBlock,
      allowAnnotations: props.allowAnnotations,
      allowTableResizing: allowTableResizing
    })
  }, children))));

  // We can only make the wrapper div query container when we have a known width.
  // This is also required for SSR to work correctly. As WidthProvider/WithConsumer will not have the correct width during SSR.
  //
  // We are setting this wrapper div as query container conditionally.
  // Only apply container-type = inline-size when having a known width in full-page/full-width/comment mode.
  // Otherwise when appearance is unspecified the renderer size is decided by the content.
  // In this case we can't set the container-type = inline-size as it will collapse width to 0.
  return (appearance === 'full-page' || appearance === 'full-width' || appearance === 'comment') &&
  // In case of having excerpt-include on page there are multiple renderers nested.
  // Make sure only the root renderer is set to be query container.
  isTopLevelRenderer && fg('platform-fix-table-ssr-resizing') ? jsx("div", {
    css: setAsQueryContainerStyles
  }, renderer) : renderer;
});
const RootRendererContext = /*#__PURE__*/React.createContext(null);
function RendererActionsInternalUpdater({
  children,
  doc,
  schema,
  onAnalyticsEvent
}) {
  const rootRendererContextValue = React.useContext(RootRendererContext);
  const actions = useContext(ActionsContext);
  const rendererRef = useRef(null);

  // This doc is used by the renderer actions when applying comments to the document.
  // (via hand crafted steps based on non prosemirror based position calculations)
  // It is set to the root renderer's doc as otherwise the resulting document will
  // be incorrect (nested renderers use a fake document which represents a subset
  // of the actual document).
  let _doc;
  if (editorExperiment('comment_on_bodied_extensions', true) && rootRendererContextValue) {
    // If rootRendererContextValue is set -- we are inside a nested renderer
    // and should always use the doc from the root renderer
    _doc = rootRendererContextValue.doc;
  } else {
    // If rootRendererContextValue is not set -- we are in the root renderer
    // and set the doc to the current doc.
    _doc = doc;
  }
  useLayoutEffect(() => {
    if (_doc) {
      actions._privateRegisterRenderer(rendererRef, _doc, schema, onAnalyticsEvent);
    } else {
      actions._privateUnregisterRenderer();
    }
    return () => actions._privateUnregisterRenderer();
  }, [actions, schema, _doc, onAnalyticsEvent]);
  if (editorExperiment('comment_on_bodied_extensions', true)) {
    return jsx(RootRendererContext.Provider, {
      value: {
        doc: _doc
      }
    }, children);
  }
  return children;
}

// Usage notes:
// Used by Confluence for nested renderers
// For the View page renderer - see RendererWithAnalytics
const RendererWithAnnotationSelection = props => {
  const {
    allowAnnotations,
    document: adfDocument
  } = props;
  const localRef = React.useRef(null);
  const innerRef = props.innerRef || localRef;
  if (!allowAnnotations) {
    // Ignored via go/ees005
    // eslint-disable-next-line react/jsx-props-no-spreading
    return jsx(RendererWithAnalytics, _extends({
      innerRef: innerRef
    }, props));
  }
  return jsx(RendererActionsContext, null, jsx(AnnotationsWrapper, {
    rendererRef: innerRef,
    adfDocument: adfDocument,
    annotationProvider: props.annotationProvider,
    isNestedRender: true
  }, jsx(RendererWithAnalytics, _extends({
    innerRef: innerRef
    // Ignored via go/ees005
    // eslint-disable-next-line react/jsx-props-no-spreading
  }, props, {
    featureFlags: props.featureFlags
  }))));
};

// eslint-disable-next-line @repo/internal/deprecations/deprecation-ticket-required -- Ignored via go/ED-25883
/* @deprecated using this version of the renderer causes the RendererActions to inaccessible from any consumers */
export default RendererWithAnnotationSelection;