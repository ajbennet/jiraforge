"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _typeof = require("@babel/runtime/helpers/typeof");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.mediaIdentifierMap = exports.getListOfIdentifiersFromDoc = exports.getClipboardAttrs = exports.MediaCardView = exports.MediaCardInternal = exports.MediaCard = void 0;
var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));
var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));
var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _react = _interopRequireWildcard(require("react"));
var _traverse = require("@atlaskit/adf-utils/traverse");
var _mediaCard = require("@atlaskit/media-card");
var _mediaClientReact = require("@atlaskit/media-client-react");
var _utils = require("@atlaskit/editor-common/utils");
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != _typeof(e) && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { (0, _defineProperty2.default)(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _callSuper(t, o, e) { return o = (0, _getPrototypeOf2.default)(o), (0, _possibleConstructorReturn2.default)(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], (0, _getPrototypeOf2.default)(t).constructor) : o.apply(t, e)); }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
var mediaIdentifierMap = exports.mediaIdentifierMap = new Map();
var getListOfIdentifiersFromDoc = exports.getListOfIdentifiersFromDoc = function getListOfIdentifiersFromDoc(doc) {
  if (!doc) {
    return [];
  }
  return (0, _traverse.filter)(doc, function (node) {
    return node.type === 'media';
  }).reduce(function (identifierList, mediaNode) {
    if (mediaNode.attrs) {
      var _mediaNode$attrs = mediaNode.attrs,
        type = _mediaNode$attrs.type,
        dataURI = _mediaNode$attrs.url,
        id = _mediaNode$attrs.id;
      if (type === 'file' && id) {
        identifierList.push({
          mediaItemType: 'file',
          id: id
        });
      } else if (type === 'external' && dataURI) {
        identifierList.push({
          mediaItemType: 'external-image',
          dataURI: dataURI,
          name: dataURI
        });
      }
    }
    return identifierList;
  }, []);
};

// Ignored via go/ees005
// eslint-disable-next-line @repo/internal/react/no-class-components
var MediaCardView = exports.MediaCardView = /*#__PURE__*/function (_Component) {
  function MediaCardView() {
    var _this;
    (0, _classCallCheck2.default)(this, MediaCardView);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _callSuper(this, MediaCardView, [].concat(args));
    (0, _defineProperty2.default)(_this, "state", {});
    (0, _defineProperty2.default)(_this, "saveFileState", /*#__PURE__*/function () {
      var _ref = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee(id) {
        var _this$props, collectionName, mediaClient, options, fileState;
        return _regenerator.default.wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              _this$props = _this.props, collectionName = _this$props.collection, mediaClient = _this$props.mediaClient;
              options = {
                collectionName: collectionName
              };
              _context.prev = 2;
              if (!mediaClient) {
                _context.next = 8;
                break;
              }
              _context.next = 6;
              return mediaClient.file.getCurrentState(id, options);
            case 6:
              fileState = _context.sent;
              _this.setState({
                fileState: fileState
              });
            case 8:
              _context.next = 12;
              break;
            case 10:
              _context.prev = 10;
              _context.t0 = _context["catch"](2);
            case 12:
            case "end":
              return _context.stop();
          }
        }, _callee, null, [[2, 10]]);
      }));
      return function (_x) {
        return _ref.apply(this, arguments);
      };
    }());
    (0, _defineProperty2.default)(_this, "renderLoadingCard", function () {
      var cardDimensions = _this.props.cardDimensions;
      return /*#__PURE__*/_react.default.createElement(_mediaCard.CardLoading, {
        dimensions: cardDimensions,
        interactionName: "renderer-media-card-loading"
      });
    });
    /**
     * We want to call provided `eventHandlers.media.onClick` when it's provided,
     * but we also don't want to call it when it's a video and inline video player is enabled.
     * This is due to consumers normally process this onClick call by opening media viewer and
     * we don't want that to happened described above text.
     */
    (0, _defineProperty2.default)(_this, "getOnCardClickCallback", function (isInlinePlayer) {
      var eventHandlers = _this.props.eventHandlers;
      if (eventHandlers && eventHandlers.media && eventHandlers.media.onClick) {
        return function (result, analyticsEvent) {
          var isVideo = result.mediaItemDetails && result.mediaItemDetails.mediaType === 'video';
          var isVideoWithInlinePlayer = isInlinePlayer && isVideo;
          if (!isVideoWithInlinePlayer && eventHandlers && eventHandlers.media && eventHandlers.media.onClick) {
            eventHandlers.media.onClick(result, analyticsEvent);
          }
        };
      }
      return undefined;
    });
    return _this;
  }
  (0, _inherits2.default)(MediaCardView, _Component);
  return (0, _createClass2.default)(MediaCardView, [{
    key: "componentDidMount",
    value: function () {
      var _componentDidMount = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee2() {
        var _this$props2, rendererContext, contextIdentifierProvider, id, url, collectionName, nodeIsInCache;
        return _regenerator.default.wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              _this$props2 = this.props, rendererContext = _this$props2.rendererContext, contextIdentifierProvider = _this$props2.contextIdentifierProvider, id = _this$props2.id, url = _this$props2.url, collectionName = _this$props2.collection;
              if (!contextIdentifierProvider) {
                _context2.next = 8;
                break;
              }
              _context2.t0 = this;
              _context2.next = 5;
              return contextIdentifierProvider;
            case 5:
              _context2.t1 = _context2.sent;
              _context2.t2 = {
                contextIdentifierProvider: _context2.t1
              };
              _context2.t0.setState.call(_context2.t0, _context2.t2);
            case 8:
              nodeIsInCache = id && mediaIdentifierMap.has(id) || url && mediaIdentifierMap.has(url);
              if (rendererContext && rendererContext.adDoc && !nodeIsInCache) {
                getListOfIdentifiersFromDoc(rendererContext.adDoc).forEach(function (identifier) {
                  if (identifier.mediaItemType === 'file' && identifier.id === id) {
                    mediaIdentifierMap.set(identifier.id, _objectSpread(_objectSpread({}, identifier), {}, {
                      collectionName: collectionName
                    }));
                  } else if (identifier.mediaItemType === 'external-image') {
                    mediaIdentifierMap.set(identifier.dataURI, identifier);
                  }
                });
              }
              if (id) {
                this.saveFileState(id);
              }
            case 11:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this);
      }));
      function componentDidMount() {
        return _componentDidMount.apply(this, arguments);
      }
      return componentDidMount;
    }()
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps) {
      var oldId = prevProps.id;
      if (this.props.id && oldId !== this.props.id) {
        this.saveFileState(this.props.id);
      }
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      var _this$props3 = this.props,
        id = _this$props3.id,
        dataURI = _this$props3.url;
      if (id) {
        mediaIdentifierMap.delete(id);
      } else if (dataURI) {
        mediaIdentifierMap.delete(dataURI);
      }
    }
  }, {
    key: "renderExternal",
    value: function renderExternal(shouldOpenMediaViewer) {
      var _this$props4 = this.props,
        cardDimensions = _this$props4.cardDimensions,
        resizeMode = _this$props4.resizeMode,
        appearance = _this$props4.appearance,
        url = _this$props4.url,
        imageStatus = _this$props4.imageStatus,
        disableOverlay = _this$props4.disableOverlay,
        alt = _this$props4.alt,
        featureFlags = _this$props4.featureFlags,
        ssr = _this$props4.ssr,
        mediaClient = _this$props4.mediaClient,
        dataAttributes = _this$props4.dataAttributes;
      if (imageStatus === 'loading' || !url) {
        return this.renderLoadingCard();
      }
      var identifier = {
        dataURI: url,
        name: url,
        mediaItemType: 'external-image'
      };

      // we need this statement for the mandatory mediaClientConfig below
      var mediaClientConfig = mediaClient === null || mediaClient === void 0 ? void 0 : mediaClient.mediaClientConfig;
      return (
        /*#__PURE__*/
        // Ignored via go/ees005
        // eslint-disable-next-line react/jsx-props-no-spreading
        _react.default.createElement("div", (0, _extends2.default)({}, dataAttributes, {
          "data-node-type": "media"
        }), /*#__PURE__*/_react.default.createElement(_mediaCard.Card
        // TODO MPT-315: clean up after we move mediaClientConfig into FileIdentifier
        // context is not really used when the type is external and we want to render the component asap
        // Ignored via go/ees005
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        , {
          mediaClientConfig: mediaClientConfig,
          alt: alt,
          identifier: identifier,
          dimensions: cardDimensions,
          appearance: appearance,
          resizeMode: resizeMode,
          disableOverlay: disableOverlay,
          shouldOpenMediaViewer: shouldOpenMediaViewer,
          mediaViewerItems: Array.from(mediaIdentifierMap.values()),
          featureFlags: featureFlags,
          ssr: ssr === null || ssr === void 0 ? void 0 : ssr.mode,
          shouldHideTooltip: false
        }))
      );
    }
  }, {
    key: "render",
    value: function render() {
      var _this$state = this.state,
        contextIdentifierProvider = _this$state.contextIdentifierProvider,
        fileState = _this$state.fileState;
      var _this$props5 = this.props,
        id = _this$props5.id,
        alt = _this$props5.alt,
        type = _this$props5.type,
        collection = _this$props5.collection,
        occurrenceKey = _this$props5.occurrenceKey,
        cardDimensions = _this$props5.cardDimensions,
        resizeMode = _this$props5.resizeMode,
        disableOverlay = _this$props5.disableOverlay,
        useInlinePlayer = _this$props5.useInlinePlayer,
        originalDimensions = _this$props5.originalDimensions,
        forceOpenMediaViewer = _this$props5.shouldOpenMediaViewer,
        featureFlags = _this$props5.featureFlags,
        shouldEnableDownloadButton = _this$props5.shouldEnableDownloadButton,
        ssr = _this$props5.ssr,
        mediaClient = _this$props5.mediaClient,
        dataAttributes = _this$props5.dataAttributes;
      var isMobile = false;
      var shouldPlayInline = useInlinePlayer !== undefined ? useInlinePlayer : true;
      var isInlinePlayer = isMobile ? false : shouldPlayInline;
      var onCardClick = this.getOnCardClickCallback(isInlinePlayer);
      var shouldOpenMediaViewer = typeof forceOpenMediaViewer === 'boolean' ? forceOpenMediaViewer : !isMobile && !onCardClick;
      if (type === 'external') {
        return this.renderExternal(shouldOpenMediaViewer);
      }
      if (type === 'link') {
        return null;
      }
      var mediaClientConfig = !!ssr ? ssr.config : mediaClient === null || mediaClient === void 0 ? void 0 : mediaClient.mediaClientConfig;
      if (!mediaClientConfig || !id) {
        return this.renderLoadingCard();
      }
      if (!id || type !== 'file') {
        return /*#__PURE__*/_react.default.createElement(_mediaCard.CardError, {
          dimensions: cardDimensions
        });
      }
      var contextId = contextIdentifierProvider && contextIdentifierProvider.objectId;
      var identifier = {
        id: id,
        mediaItemType: 'file',
        collectionName: collection,
        occurrenceKey: occurrenceKey
      };
      return /*#__PURE__*/_react.default.createElement("div", (0, _extends2.default)({}, getClipboardAttrs({
        id: id,
        alt: alt,
        collection: collection,
        contextIdentifierProvider: contextIdentifierProvider,
        originalDimensions: originalDimensions,
        fileState: fileState
      }), dataAttributes), /*#__PURE__*/_react.default.createElement(_mediaCard.Card, {
        identifier: identifier,
        alt: alt,
        contextId: contextId,
        mediaClientConfig: mediaClientConfig,
        dimensions: cardDimensions,
        originalDimensions: originalDimensions,
        onClick: onCardClick,
        resizeMode: resizeMode,
        isLazy: !isMobile,
        disableOverlay: disableOverlay,
        useInlinePlayer: isInlinePlayer,
        shouldOpenMediaViewer: shouldOpenMediaViewer,
        mediaViewerItems: Array.from(mediaIdentifierMap.values()),
        featureFlags: featureFlags,
        shouldEnableDownloadButton: shouldEnableDownloadButton,
        ssr: ssr === null || ssr === void 0 ? void 0 : ssr.mode,
        shouldHideTooltip: isMobile
      }));
    }
  }]);
}(_react.Component);
// Needed for copy & paste
var getClipboardAttrs = exports.getClipboardAttrs = function getClipboardAttrs(_ref2) {
  var id = _ref2.id,
    alt = _ref2.alt,
    collection = _ref2.collection,
    contextIdentifierProvider = _ref2.contextIdentifierProvider,
    originalDimensions = _ref2.originalDimensions,
    fileState = _ref2.fileState;
  var contextId = contextIdentifierProvider && contextIdentifierProvider.objectId;
  var width = originalDimensions && originalDimensions.width;
  var height = originalDimensions && originalDimensions.height;
  var fileName = 'file'; // default name is needed for Confluence
  var fileSize = 1;
  var fileMimeType = '';
  if (fileState && fileState.status !== 'error') {
    fileSize = fileState.size;
    fileName = fileState.name;
    fileMimeType = fileState.mimeType;
  }
  return {
    'data-context-id': contextId,
    'data-type': 'file',
    'data-node-type': 'media',
    'data-width': width,
    'data-height': height,
    'data-id': id,
    'data-collection': collection,
    'data-file-name': fileName,
    'data-file-size': fileSize,
    'data-file-mime-type': fileMimeType,
    'data-alt': alt
  };
};
var MediaCardInternal = exports.MediaCardInternal = function MediaCardInternal(props) {
  var mediaClient = (0, _react.useContext)(_mediaClientReact.MediaClientContext);

  // Ignored via go/ees005
  // eslint-disable-next-line react/jsx-props-no-spreading
  return /*#__PURE__*/_react.default.createElement(MediaCardView, (0, _extends2.default)({}, props, {
    mediaClient: mediaClient
  }));
};
var MediaCard = exports.MediaCard = (0, _utils.withImageLoader)(MediaCardInternal);