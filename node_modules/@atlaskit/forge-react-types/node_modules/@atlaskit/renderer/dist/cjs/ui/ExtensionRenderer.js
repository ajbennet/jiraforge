"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = ExtensionRenderer;
var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));
var _react = require("@emotion/react");
var _react2 = _interopRequireDefault(require("react"));
var _memoizeOne = _interopRequireDefault(require("memoize-one"));
var _extensions = require("@atlaskit/editor-common/extensions");
var _providerFactory = require("@atlaskit/editor-common/provider-factory");
var _utils = require("@atlaskit/editor-common/utils");
/**
 * @jsxRuntime classic
 * @jsx jsx
 */
// eslint-disable-next-line @atlaskit/ui-styling-standard/use-compiled -- Ignored via go/DSP-18766

var inlineExtensionStyle = (0, _react.css)({
  display: 'inline-block',
  maxWidth: '100%',
  verticalAlign: 'middle',
  // es-lint-disable-next-line @atlaskit/design-system/ensure-design-token-usage
  margin: "1px 1px ".concat("var(--ds-space-050, 4px)"),
  // eslint-disable-next-line @atlaskit/ui-styling-standard/no-nested-selectors -- Ignored via go/DSP-18766
  '& .rich-media-item': {
    maxWidth: '100%'
  }
});
function ExtensionRenderer(props) {
  var extensionHandlers = props.extensionHandlers,
    rendererContext = props.rendererContext,
    extensionType = props.extensionType,
    extensionKey = props.extensionKey,
    parameters = props.parameters,
    content = props.content,
    text = props.text,
    type = props.type,
    localId = props.localId,
    marks = props.marks,
    actions = props.actions,
    children = props.children;
  var isMounted = _react2.default.useRef(true);
  var localGetNodeRenderer = _react2.default.useMemo(function () {
    return (0, _memoizeOne.default)(_extensions.getNodeRenderer);
  }, []);
  var _React$useState = _react2.default.useState(null),
    _React$useState2 = (0, _slicedToArray2.default)(_React$useState, 2),
    extensionProvider = _React$useState2[0],
    setExtensionProvider = _React$useState2[1];

  // Ignored via go/ees005
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  var handleProvider = _react2.default.useCallback(function (name, providerPromise) {
    providerPromise && providerPromise.then(function (provider) {
      if (isMounted.current) {
        setExtensionProvider(provider);
      }
    });
  }, []);
  var renderExtensionNode = _react2.default.useCallback(function (extensionProvider) {
    var _marks$find;
    var fragmentLocalId = marks === null || marks === void 0 || (_marks$find = marks.find(function (m) {
      return m.type.name === 'fragment';
    })) === null || _marks$find === void 0 || (_marks$find = _marks$find.attrs) === null || _marks$find === void 0 ? void 0 : _marks$find.localId;
    var node = {
      type: type,
      extensionKey: extensionKey,
      extensionType: extensionType,
      parameters: parameters,
      content: content || text,
      localId: localId,
      fragmentLocalId: fragmentLocalId
    };
    var result = null;
    try {
      if (extensionHandlers && extensionHandlers[extensionType]) {
        var render = (0, _utils.getExtensionRenderer)(extensionHandlers[extensionType]);
        result = render(node, rendererContext.adDoc);
      }
      if (!result && extensionProvider) {
        var NodeRenderer = localGetNodeRenderer(extensionProvider, extensionType, extensionKey);
        if (node.type === 'multiBodiedExtension') {
          result = (0, _react.jsx)(NodeRenderer, {
            node: node,
            actions: actions
          });
        } else if (node.type === 'inlineExtension') {
          result = (0, _react.jsx)(InlineNodeRendererWrapper, null, (0, _react.jsx)(NodeRenderer, {
            node: node
          }));
        } else {
          result = (0, _react.jsx)(NodeRenderer, {
            node: node
          });
        }
      }
    } catch (e) {
      /** We don't want this error to block renderer */
      /** We keep rendering the default content */
    }
    return children({
      result: result
    });
  }, [actions, children, content, extensionHandlers, extensionKey, extensionType, localGetNodeRenderer, localId, marks, parameters, rendererContext === null || rendererContext === void 0 ? void 0 : rendererContext.adDoc, text, type]);
  var setupAndRenderExtensionNode = _react2.default.useCallback(function (providers) {
    if (!extensionProvider && providers.extensionProvider) {
      handleProvider('extensionProvider', providers.extensionProvider);
    }
    return renderExtensionNode(extensionProvider);
  }, [extensionProvider, handleProvider, renderExtensionNode]);
  _react2.default.useEffect(function () {
    isMounted.current = true;
    return function () {
      isMounted.current = false;
    };
  }, []);
  if (!props.providers) {
    return setupAndRenderExtensionNode({});
  }
  return (0, _react.jsx)(_providerFactory.WithProviders, {
    providers: ['extensionProvider'],
    providerFactory: props.providers,
    renderNode: setupAndRenderExtensionNode
  });
}
var InlineNodeRendererWrapper = function InlineNodeRendererWrapper(_ref) {
  var children = _ref.children;
  return (
    // eslint-disable-next-line @atlaskit/ui-styling-standard/no-classname-prop -- Ignored via go/DSP-18766
    (0, _react.jsx)("div", {
      className: "inline-extension-renderer",
      css: inlineExtensionStyle
    }, children)
  );
};