"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _typeof = require("@babel/runtime/helpers/typeof");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SelectionInlineCommentMounter = void 0;
var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));
var _react = _interopRequireWildcard(require("react"));
var _adfSchema = require("@atlaskit/adf-schema");
var _platformFeatureFlags = require("@atlaskit/platform-feature-flags");
var _dom = require("../draft/dom");
var _types = require("@atlaskit/analytics-listeners/types");
var _analytics = require("@atlaskit/editor-common/analytics");
var _getRendererRangeInlineNodeNames = require("../../../actions/get-renderer-range-inline-node-names");
var _RendererActionsContext = require("../../RendererActionsContext");
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != _typeof(e) && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
var SelectionInlineCommentMounter = exports.SelectionInlineCommentMounter = /*#__PURE__*/_react.default.memo(function (props) {
  var Component = props.component,
    range = props.range,
    draftRange = props.draftRange,
    isAnnotationAllowed = props.isAnnotationAllowed,
    wrapperDOM = props.wrapperDOM,
    onCloseProps = props.onClose,
    clearAnnotationDraft = props.clearAnnotationDraft,
    applyAnnotationDraftAt = props.applyAnnotationDraftAt,
    documentPosition = props.documentPosition,
    applyAnnotation = props.applyAnnotation,
    createAnalyticsEvent = props.createAnalyticsEvent,
    generateIndexMatch = props.generateIndexMatch;
  var _useState = (0, _react.useState)(),
    _useState2 = (0, _slicedToArray2.default)(_useState, 2),
    draftDocumentPosition = _useState2[0],
    setDraftDocumentPosition = _useState2[1];
  var actions = (0, _react.useContext)(_RendererActionsContext.RendererContext);
  var inlineNodeTypes = (0, _react.useMemo)(function () {
    if ((0, _platformFeatureFlags.fg)('annotations_defensive_node_name_calculations')) {
      if (!actions.isRangeAnnotatable(range)) {
        return undefined;
      }
      return (0, _getRendererRangeInlineNodeNames.getRendererRangeInlineNodeNames)({
        pos: documentPosition,
        actions: actions
      });
    } else {
      if (!(0, _platformFeatureFlags.fg)('editor_inline_comments_on_inline_nodes')) {
        return undefined;
      }
      if (actions.isValidAnnotationRange(range)) {
        return (0, _getRendererRangeInlineNodeNames.getRendererRangeInlineNodeNames)({
          pos: documentPosition,
          actions: actions
        });
      } else {
        return undefined;
      }
    }
  }, [documentPosition, actions, range]);
  var onCreateCallback = (0, _react.useCallback)(function (annotationId) {
    // We want to support creation on a documentPosition if the user is only using ranges
    // but we want to prioritize draft positions if they are being used by consumers
    var positionToAnnotate = draftDocumentPosition || documentPosition;
    if (!positionToAnnotate || !applyAnnotation) {
      return false;
    }

    // Evaluate position validity when the user commits the position to be annotated
    var isCreateAllowedOnPosition = actions.isValidAnnotationPosition(positionToAnnotate);
    if (!isCreateAllowedOnPosition) {
      return false;
    }
    var annotation = {
      annotationId: annotationId,
      annotationType: _adfSchema.AnnotationTypes.INLINE_COMMENT
    };
    if (createAnalyticsEvent) {
      createAnalyticsEvent({
        action: _analytics.ACTION.INSERTED,
        actionSubject: _analytics.ACTION_SUBJECT.ANNOTATION,
        actionSubjectId: _analytics.ACTION_SUBJECT_ID.INLINE_COMMENT,
        attributes: {
          inlineNodeNames: inlineNodeTypes
        },
        eventType: _analytics.EVENT_TYPE.TRACK
      }).fire(_types.FabricChannel.editor);
    }
    return applyAnnotation(positionToAnnotate, annotation);
  }, [actions, documentPosition, applyAnnotation, draftDocumentPosition, createAnalyticsEvent, inlineNodeTypes]);
  var createIndexCallback = (0, _react.useCallback)(function () {
    if (!documentPosition || !generateIndexMatch) {
      return false;
    }
    var result = generateIndexMatch(documentPosition);
    if (!result) {
      return false;
    }
    return result;
  }, [documentPosition, generateIndexMatch]);
  var applyDraftModeCallback = (0, _react.useCallback)(function (options) {
    if (!documentPosition || !isAnnotationAllowed) {
      if (createAnalyticsEvent) {
        createAnalyticsEvent({
          action: _analytics.ACTION.CREATE_NOT_ALLOWED,
          actionSubject: _analytics.ACTION_SUBJECT.ANNOTATION,
          actionSubjectId: _analytics.ACTION_SUBJECT_ID.INLINE_COMMENT,
          attributes: {
            inlineNodeNames: inlineNodeTypes
          },
          eventType: _analytics.EVENT_TYPE.TRACK
        }).fire(_types.FabricChannel.editor);
      }
      return false;
    }
    setDraftDocumentPosition(documentPosition);
    applyAnnotationDraftAt(documentPosition);
    if (createAnalyticsEvent) {
      var uniqueAnnotationsInRange = range ? actions.getAnnotationsByPosition(range) : [];
      createAnalyticsEvent({
        action: _analytics.ACTION.OPENED,
        actionSubject: _analytics.ACTION_SUBJECT.ANNOTATION,
        actionSubjectId: _analytics.ACTION_SUBJECT_ID.INLINE_COMMENT,
        eventType: _analytics.EVENT_TYPE.TRACK,
        attributes: {
          overlap: uniqueAnnotationsInRange.length,
          inlineNodeNames: inlineNodeTypes
        }
      }).fire(_types.FabricChannel.editor);
    }
    window.requestAnimationFrame(function () {
      if (options.keepNativeSelection) {
        (0, _dom.updateWindowSelectionAroundDraft)(documentPosition);
      } else {
        var sel = window.getSelection();
        if (sel) {
          sel.removeAllRanges();
        }
      }
    });
    var positionToAnnotate = draftDocumentPosition || documentPosition;
    if (!positionToAnnotate || !applyAnnotation || !options.annotationId) {
      return false;
    }
    var annotation = {
      annotationId: options.annotationId,
      annotationType: _adfSchema.AnnotationTypes.INLINE_COMMENT
    };
    return applyAnnotation(positionToAnnotate, annotation);
  }, [documentPosition, isAnnotationAllowed, applyAnnotationDraftAt, createAnalyticsEvent, applyAnnotation, draftDocumentPosition, actions, range, inlineNodeTypes]);
  var removeDraftModeCallback = (0, _react.useCallback)(function () {
    clearAnnotationDraft();
    setDraftDocumentPosition(null);
    var sel = window.getSelection();
    if (sel) {
      sel.removeAllRanges();
    }
  }, [clearAnnotationDraft]);
  var onCloseCallback = (0, _react.useCallback)(function () {
    if (createAnalyticsEvent) {
      createAnalyticsEvent({
        action: _analytics.ACTION.CLOSED,
        actionSubject: _analytics.ACTION_SUBJECT.ANNOTATION,
        actionSubjectId: _analytics.ACTION_SUBJECT_ID.INLINE_COMMENT,
        eventType: _analytics.EVENT_TYPE.TRACK,
        attributes: {
          inlineNodeNames: inlineNodeTypes
        }
      }).fire(_types.FabricChannel.editor);
    }
    removeDraftModeCallback();
    onCloseProps();
  }, [onCloseProps, removeDraftModeCallback, createAnalyticsEvent, inlineNodeTypes]);
  return /*#__PURE__*/_react.default.createElement(Component, {
    range: range,
    draftRange: draftRange
    // Ignored via go/ees005
    // eslint-disable-next-line @atlaskit/editor/no-as-casting
    ,
    wrapperDOM: wrapperDOM.current,
    isAnnotationAllowed: isAnnotationAllowed,
    onClose: onCloseCallback,
    onCreate: onCreateCallback,
    getAnnotationIndexMatch: createIndexCallback,
    applyDraftMode: applyDraftModeCallback,
    removeDraftMode: removeDraftModeCallback,
    inlineNodeTypes: inlineNodeTypes
  });
});