"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Colgroup = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _react = _interopRequireDefault(require("react"));
var _styles = require("@atlaskit/editor-common/styles");
var _editorSharedStyles = require("@atlaskit/editor-shared-styles");
var _experiments = require("@atlaskit/tmp-editor-statsig/experiments");
var _nodeWidth = require("@atlaskit/editor-common/node-width");
var _platformFeatureFlags = require("@atlaskit/platform-feature-flags");
var _useFeatureFlags = require("../../../use-feature-flags");
var _rendererContext = require("../../../renderer-context");
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { (0, _defineProperty2.default)(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
// we allow scaling down column widths by no more than 30%
// this intends to reduce unwanted scrolling in the Renderer in these scenarios:
// User A creates a table with column widths → User B views it on a smaller screen
// User A creates a table with column widths → User A views it with reduced viewport space (eg. Confluence sidebar is open)
var MAX_SCALING_PERCENT = 0.3;
var MAX_SCALING_PERCENT_TABLES_WITH_FIXED_COLUMN_WIDTHS_OPTION = 0.4;
var isTableColumnResized = function isTableColumnResized(columnWidths) {
  var filteredWidths = columnWidths.filter(function (width) {
    return width !== 0;
  });
  return !!filteredWidths.length;
};
var fixColumnWidth = function fixColumnWidth(columnWidth, _tableWidth, _layoutWidth, zeroWidthColumnsCount, scaleDownPercent) {
  if (columnWidth === 0) {
    return columnWidth;
  }

  // If the tables total width (including no zero widths col or cols without width) is less than the current layout
  // We scale up the columns to meet the minimum of the table layout.
  if (zeroWidthColumnsCount === 0 && scaleDownPercent) {
    return Math.max(Math.floor((1 - scaleDownPercent) * columnWidth), _styles.tableCellMinWidth);
  }
  return Math.max(
  // We need to take tableCellBorderWidth, to avoid unnecessary overflow.
  columnWidth - _styles.tableCellBorderWidth, zeroWidthColumnsCount ? _editorSharedStyles.akEditorTableLegacyCellMinWidth : _styles.tableCellMinWidth);
};
var calcScalePercent = function calcScalePercent(_ref) {
  var renderWidth = _ref.renderWidth,
    tableWidth = _ref.tableWidth,
    maxScale = _ref.maxScale,
    isNumberColumnEnabled = _ref.isNumberColumnEnabled;
  var noNumColumnScalePercent = renderWidth / tableWidth;
  // when numbered column is enabled, we need to calculate the scale percent without the akEditorTableNumberColumnWidth
  // As numbered column width is not scaled down
  var numColumnScalePercent = (renderWidth - _editorSharedStyles.akEditorTableNumberColumnWidth) / (tableWidth - _editorSharedStyles.akEditorTableNumberColumnWidth);
  var diffPercent = 1 - noNumColumnScalePercent;
  return diffPercent < maxScale ? isNumberColumnEnabled ? 1 - numColumnScalePercent : diffPercent : maxScale;
};
var colWidthSum = function colWidthSum(columnWidths) {
  return columnWidths.reduce(function (prev, curr) {
    return curr + prev;
  }, 0);
};
var renderScaleDownColgroup = function renderScaleDownColgroup(props) {
  var _props$tableNode;
  var columnWidths = props.columnWidths,
    isNumberColumnEnabled = props.isNumberColumnEnabled,
    renderWidth = props.renderWidth,
    tableNode = props.tableNode,
    rendererAppearance = props.rendererAppearance,
    isInsideOfBlockNode = props.isInsideOfBlockNode,
    isInsideOfTable = props.isInsideOfTable,
    isinsideMultiBodiedExtension = props.isinsideMultiBodiedExtension,
    isTableScalingEnabled = props.isTableScalingEnabled,
    isTableFixedColumnWidthsOptionEnabled = props.isTableFixedColumnWidthsOptionEnabled,
    allowTableResizing = props.allowTableResizing,
    isTopLevelRenderer = props.isTopLevelRenderer;
  if (!columnWidths) {
    return [];
  }
  var tableColumnResized = isTableColumnResized(columnWidths);
  var noOfColumns = columnWidths.length;
  var targetWidths;

  // This is a fix for ED-23259
  // Some extensions (for ex: Page Properties or Excerpt) do not renderer tables directly inside themselves. They use ReactRenderer.
  // So if we add a check like isInsideExtension (similar to exising isInsideBlockNode), it will fail, and to the only way to learn
  // if the table is rendered inside another node, is to check if the Renderer itself is nested.
  var isRendererNested = isTopLevelRenderer === false && (0, _platformFeatureFlags.fg)('platform_editor_nested_table_in_nested_parent_fix');

  // appearance == comment && allowTableResizing && !tableNode?.attrs.width, means it is a comment
  // appearance == comment && !allowTableResizing && !tableNode?.attrs.width, means it is a inline comment
  // When comment and inline comment table width inherits from the parent container, we want tableContainerWidth === renderWidth
  var tableContainerWidth = rendererAppearance === 'comment' && !(tableNode !== null && tableNode !== void 0 && tableNode.attrs.width) || isRendererNested ? renderWidth : (0, _nodeWidth.getTableContainerWidth)(tableNode);
  if (allowTableResizing && !isInsideOfBlockNode && !((0, _platformFeatureFlags.fg)('platform_editor_nested_tables_renderer_colgroup') && isInsideOfTable) && !isinsideMultiBodiedExtension && !tableColumnResized) {
    // when no columns are resized, each column should have equal width, equals to tableWidth / noOfColumns
    var _tableWidth2 = (isNumberColumnEnabled ? tableContainerWidth - _editorSharedStyles.akEditorTableNumberColumnWidth : tableContainerWidth) - 1;
    var defaultColumnWidth = _tableWidth2 / noOfColumns;
    targetWidths = new Array(noOfColumns).fill(defaultColumnWidth);
  } else if (!tableColumnResized) {
    return null;
  }
  var sumOfColumns = colWidthSum(columnWidths);

  // tables in the wild may be smaller than table container width (col resizing bugs, created before custom widths etc.)
  // this causes issues with num column scaling as we add a new table column in renderer
  var isTableSmallerThanContainer = sumOfColumns < tableContainerWidth - 1;
  var forceScaleForNumColumn = isTableScalingEnabled && isNumberColumnEnabled && tableColumnResized;

  // when table resized and number column is enabled, we need to scale down the table in render
  if (forceScaleForNumColumn) {
    var scalePercentage = +((tableContainerWidth - _editorSharedStyles.akEditorTableNumberColumnWidth) / tableContainerWidth);
    var targetMaxWidth = tableContainerWidth - _editorSharedStyles.akEditorTableNumberColumnWidth;
    var totalWidthAfterScale = 0;
    var newScaledTargetWidths = columnWidths.map(function (width) {
      // we need to scale each column UP, to ensure total width of table matches table container
      var patchedWidth = isTableSmallerThanContainer ? width / sumOfColumns * (tableContainerWidth - 1) : width;
      var newWidth = Math.floor(patchedWidth * scalePercentage);
      totalWidthAfterScale += newWidth;
      return newWidth;
    });
    var diff = targetMaxWidth - totalWidthAfterScale;
    targetWidths = newScaledTargetWidths;
    if (diff > 0 || diff < 0 && Math.abs(diff) < _styles.tableCellMinWidth) {
      var updated = false;
      targetWidths = targetWidths.map(function (width) {
        if (!updated && width + diff > _styles.tableCellMinWidth) {
          updated = true;
          width += diff;
        }
        return width;
      });
    }
  }
  targetWidths = targetWidths || columnWidths;

  // @see ED-6056
  var maxTableWidth = renderWidth < tableContainerWidth ? renderWidth : tableContainerWidth;
  var tableWidth = isNumberColumnEnabled ? _editorSharedStyles.akEditorTableNumberColumnWidth : 0;
  var minTableWidth = tableWidth;
  var zeroWidthColumnsCount = 0;
  targetWidths.forEach(function (width) {
    if (width) {
      tableWidth += Math.ceil(width);
    } else {
      zeroWidthColumnsCount += 1;
    }
    minTableWidth += Math.ceil(width) || _editorSharedStyles.akEditorTableLegacyCellMinWidth;
  });
  var cellMinWidth = 0;
  var scaleDownPercent = 0;
  var isTableScalingWithFixedColumnWidthsOptionEnabled = isTableScalingEnabled && isTableFixedColumnWidthsOptionEnabled;
  var isTableWidthFixed = isTableScalingWithFixedColumnWidthsOptionEnabled && ((_props$tableNode = props.tableNode) === null || _props$tableNode === void 0 ? void 0 : _props$tableNode.attrs.displayMode) === 'fixed';
  var maxScalingPercent = isTableScalingWithFixedColumnWidthsOptionEnabled || isTableScalingEnabled && rendererAppearance === 'comment' ? MAX_SCALING_PERCENT_TABLES_WITH_FIXED_COLUMN_WIDTHS_OPTION : MAX_SCALING_PERCENT;

  // fixes migration tables with zero-width columns
  if (zeroWidthColumnsCount > 0) {
    if (minTableWidth > maxTableWidth) {
      var minWidth = Math.ceil((maxTableWidth - tableWidth) / zeroWidthColumnsCount);
      cellMinWidth = minWidth < _editorSharedStyles.akEditorTableLegacyCellMinWidth ? _editorSharedStyles.akEditorTableLegacyCellMinWidth : minWidth;
    }
  }
  // scaling down
  else if (renderWidth < tableWidth && !isTableWidthFixed) {
    var shouldTable100ScaleDown = rendererAppearance === 'comment' && allowTableResizing && !(tableNode !== null && tableNode !== void 0 && tableNode.attrs.width);
    scaleDownPercent = calcScalePercent({
      renderWidth: renderWidth,
      tableWidth: tableWidth,
      maxScale: shouldTable100ScaleDown ? 1 : maxScalingPercent,
      isNumberColumnEnabled: isNumberColumnEnabled
    });
  }
  return targetWidths.map(function (colWidth) {
    var width = fixColumnWidth(colWidth, minTableWidth, maxTableWidth, zeroWidthColumnsCount, scaleDownPercent) || cellMinWidth;
    var style = width ? {
      width: "".concat(width, "px")
    } : {};
    return style;
  });
};
var Colgroup = exports.Colgroup = function Colgroup(props) {
  var _useRendererContext = (0, _rendererContext.useRendererContext)(),
    isTopLevelRenderer = _useRendererContext.isTopLevelRenderer;
  var columnWidths = props.columnWidths,
    isNumberColumnEnabled = props.isNumberColumnEnabled;
  var flags = (0, _useFeatureFlags.useFeatureFlags)();
  if (!columnWidths) {
    return null;
  }
  var colStyles = renderScaleDownColgroup(_objectSpread(_objectSpread({}, props), {}, {
    isTopLevelRenderer: isTopLevelRenderer,
    isTableScalingEnabled: props.rendererAppearance === 'full-page' || props.rendererAppearance === 'full-width' || props.rendererAppearance === 'comment' && (0, _experiments.editorExperiment)('support_table_in_comment', true, {
      exposure: true
    }) || props.rendererAppearance === 'comment' && (0, _experiments.editorExperiment)('support_table_in_comment_jira', true, {
      exposure: true
    }),
    isTableFixedColumnWidthsOptionEnabled: !!(flags && 'tableWithFixedColumnWidthsOption' in flags && flags.tableWithFixedColumnWidthsOption) && (props.rendererAppearance === 'full-page' || props.rendererAppearance === 'full-width')
  }));
  if (!colStyles) {
    return null;
  }
  return /*#__PURE__*/_react.default.createElement("colgroup", null, isNumberColumnEnabled && /*#__PURE__*/_react.default.createElement("col", {
    // eslint-disable-next-line @atlaskit/ui-styling-standard/enforce-style-prop, @atlaskit/ui-styling-standard/no-imported-style-values -- Ignored via go/DSP-18766
    style: {
      width: _editorSharedStyles.akEditorTableNumberColumnWidth
    },
    "data-test-id": 'num'
  }), colStyles.map(function (style, idx) {
    return (
      /*#__PURE__*/
      // Ignored via go/ees005
      // eslint-disable-next-line react/no-array-index-key, @atlaskit/ui-styling-standard/enforce-style-prop -- Ignored via go/DSP-18766
      _react.default.createElement("col", {
        key: idx,
        style: style
      })
    );
  }));
};