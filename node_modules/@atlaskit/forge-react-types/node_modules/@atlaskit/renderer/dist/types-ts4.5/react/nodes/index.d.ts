import type React from 'react';
import Loadable from 'react-loadable';
import type { Fragment, Node, Mark } from '@atlaskit/editor-prosemirror/model';
import Blockquote from './blockquote';
import BodiedExtension from './bodiedExtension';
import MultiBodiedExtension from './multiBodiedExtension';
import ExtensionFrame from './extensionFrame';
import BulletList from './bulletList';
import Doc, { DocWithSelectAllTrap } from './doc';
import Extension from './extension';
import HardBreak from './hardBreak';
import Heading from './heading';
import InlineExtension from './inlineExtension';
import LayoutSection from './layoutSection';
import LayoutColumn from './layoutColumn';
import ListItem from './listItem';
import Caption from './caption';
import OrderedList from './orderedList';
import Paragraph from './paragraph';
import Placeholder from './placeholder';
import Rule from './rule';
import Table from './table';
import { TableCell } from './tableCell';
import TableRow from './tableRow';
import UnknownBlock from './unknownBlock';
import type { NodeComponentsProps } from '../../ui/Renderer/types';
declare const WindowedCodeBlock: React.ComponentType<import("./codeBlock/codeBlock").Props> & Loadable.LoadableComponent;
declare const CodeBlock: React.ComponentType<import("react-intl-next").WithIntlProps<import("./codeBlock/codeBlock").Props & import("react-intl-next").WrappedComponentProps>> & Loadable.LoadableComponent;
declare const TaskList: React.ComponentType<import("./taskList").Props> & Loadable.LoadableComponent;
declare const TaskItem: React.ComponentType<import("../types").NodeProps<import("./taskItem").Props>> & Loadable.LoadableComponent;
declare const DecisionList: React.ComponentType<import("./decisionList").Props> & Loadable.LoadableComponent;
declare const DecisionItem: React.ComponentType<import("../types").NodeProps> & Loadable.LoadableComponent;
declare const Date: React.ComponentType<import("./date").Props> & Loadable.LoadableComponent;
declare const Status: React.ComponentType<import("./status").Props> & Loadable.LoadableComponent;
declare const Emoji: React.ComponentType<import("./emoji").EmojiProps> & Loadable.LoadableComponent;
declare const Panel: React.ComponentType<import("./panel").Props> & Loadable.LoadableComponent;
declare const EmbedCard: React.ComponentType<{
    url?: string | undefined;
    data?: object | undefined;
    eventHandlers?: import("@atlaskit/editor-common/ui").EventHandlers | undefined;
    portal?: HTMLElement | undefined;
    originalHeight?: number | undefined;
    originalWidth?: number | undefined;
    width?: number | undefined;
    layout: import("@atlaskit/adf-schema").RichMediaLayout;
    rendererAppearance?: import("../../ui/Renderer/types").RendererAppearance;
    isInsideOfBlockNode?: boolean | undefined;
    smartLinks?: import("../../types/smartLinksOptions").SmartLinksOptions | undefined;
    isInsideOfInlineExtension?: boolean | undefined;
}> & Loadable.LoadableComponent;
declare const InlineCard: React.ComponentType<import("@atlaskit/editor-common/utils").Diff<import("./inlineCard").InlineCardProps & import("../../ui/SmartCardStorage").WithSmartCardStorageProps, import("../../ui/SmartCardStorage").WithSmartCardStorageProps>> & Loadable.LoadableComponent;
declare const BlockCard: React.ComponentType<{
    url?: string | undefined;
    data?: object | undefined;
    eventHandlers?: import("@atlaskit/editor-common/ui").EventHandlers | undefined;
    datasource?: import("@atlaskit/adf-schema").DatasourceAttributeProperties | undefined;
    portal?: HTMLElement | undefined;
    rendererAppearance?: import("../../ui/Renderer/types").RendererAppearance;
    smartLinks?: import("../../types/smartLinksOptions").SmartLinksOptions | undefined;
    layout?: string | undefined;
    isNodeNested?: boolean | undefined;
}> & Loadable.LoadableComponent;
declare const Media: React.ComponentType<React.PropsWithChildren<import("./media").MediaProps>> & Loadable.LoadableComponent;
declare const MediaGroup: React.ComponentType<import("./mediaGroup").MediaGroupProps> & Loadable.LoadableComponent;
declare const MediaInline: React.ComponentType<import("react-intl-next").WithIntlProps<{
    id: string;
    providers: import("@atlaskit/editor-common/provider-factory").ProviderFactory;
    collection?: string | undefined;
    eventHandlers?: import("@atlaskit/editor-common/ui").EventHandlers | undefined;
    rendererAppearance?: import("../../ui/Renderer/types").RendererAppearance;
    featureFlags?: import("@atlaskit/media-common").MediaFeatureFlags | undefined;
    marks?: Mark[] | undefined;
    ssr?: import("../..").MediaSSR | undefined;
} & import("react-intl-next").WrappedComponentProps & import("@atlaskit/editor-common/media-inline").MediaInlineAttrs>> & Loadable.LoadableComponent;
declare const MediaSingle: React.ComponentType<import("react-intl-next").WithIntlProps<import("./mediaSingle").Props & import("react-intl-next").WrappedComponentProps>> & Loadable.LoadableComponent;
declare const Mention: React.ComponentType<import("./mention").Props> & Loadable.LoadableComponent;
declare const Expand: React.ComponentType<import("react-intl-next").WithIntlProps<import("../../ui/Expand").ExpandProps & import("react-intl-next").WrappedComponentProps>> & Loadable.LoadableComponent;
export declare const nodeToReact: {
    [key: string]: React.ComponentType<React.PropsWithChildren<any>>;
};
interface ToReactFlags {
    allowSelectAllTrap?: boolean;
    allowWindowedCodeBlock?: boolean;
}
export declare const toReact: (node: Node, flags?: ToReactFlags, nodeComponents?: NodeComponentsProps) => React.ComponentType<React.PropsWithChildren<any>>;
export interface TextWrapper {
    type: {
        name: 'textWrapper';
    };
    content: Node[];
    nodeSize: number;
}
interface NodeSimple {
    type: {
        name: string;
    };
    attrs?: any;
    text?: string;
    nodeSize: number;
}
export declare const mergeTextNodes: (nodes: (Node | NodeSimple)[]) => (Node | TextWrapper | NodeSimple)[];
export declare const isText: (type: string) => type is "text";
export declare const isTextWrapper: (node: Node | TextWrapper | NodeSimple) => node is TextWrapper;
export declare function isTextNode(node: Node | Mark): node is Node;
/**
 * Detects whether a fragment contains a single paragraph node
 * whose content satisfies the condition for an emoji block
 */
export declare const isEmojiDoc: (doc: Fragment) => boolean;
export { Blockquote, BodiedExtension, BulletList, BlockCard, Caption, CodeBlock, WindowedCodeBlock, Date, DecisionItem, DecisionList, Doc, DocWithSelectAllTrap, Emoji, Extension, ExtensionFrame, Expand, HardBreak, Heading, ListItem, InlineCard, InlineExtension, LayoutSection, LayoutColumn, Media, MediaGroup, MediaInline, MediaSingle, Mention, MultiBodiedExtension, OrderedList, Panel, Paragraph, Placeholder, Rule, Status, TaskItem, TaskList, Table, TableCell, TableRow, UnknownBlock, EmbedCard, };
