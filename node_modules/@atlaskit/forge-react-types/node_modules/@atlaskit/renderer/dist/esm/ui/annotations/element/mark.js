import _defineProperty from "@babel/runtime/helpers/defineProperty";
import _toConsumableArray from "@babel/runtime/helpers/toConsumableArray";
import _taggedTemplateLiteral from "@babel/runtime/helpers/taggedTemplateLiteral";
var _templateObject;
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
/**
 * @jsxRuntime classic
 * @jsx jsx
 */

import { useMemo, useCallback } from 'react';
// eslint-disable-next-line @atlaskit/ui-styling-standard/use-compiled -- Ignored via go/DSP-18766
import { css, jsx } from '@emotion/react';
import { AnnotationSharedCSSByState } from '@atlaskit/editor-common/styles';
import { AnnotationMarkStates } from '@atlaskit/adf-schema';
import { fg } from '@atlaskit/platform-feature-flags';
import { useIntl } from 'react-intl-next';
import { inlineCommentMessages } from '../../../messages';

// eslint-disable-next-line @atlaskit/design-system/no-css-tagged-template-expression -- `AnnotationSharedCSSByState` is not object-safe
var markStyles = function markStyles() {
  return css(_templateObject || (_templateObject = _taggedTemplateLiteral(["\n\tcolor: inherit;\n\tbackground-color: unset;\n\t-webkit-tap-highlight-color: transparent;\n\n\t&[data-mark-annotation-state='", "'] {\n\t\t", "\n\t\t", "\n\n\t\t&:focus,\n\t\t\t&[data-has-focus='true'] {\n\t\t\t", "\n\t\t}\n\t\t&[data-is-hovered='true']:not([data-has-focus='true']) {\n\t\t\t", "\n\t\t}\n\t}\n"])), AnnotationMarkStates.ACTIVE, fg('editor_inline_comments_on_inline_nodes') ? AnnotationSharedCSSByState().common : '', AnnotationSharedCSSByState().blur, AnnotationSharedCSSByState().focus, fg('confluence-frontend-comments-panel') ? AnnotationSharedCSSByState().hover : '');
};
var isMobile = function isMobile() {
  // Ignored via go/ees005
  // eslint-disable-next-line require-unicode-regexp
  return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
};
var accessibilityStyles = function accessibilityStyles(startMarker, endMarker) {
  return css({
    '&::before, &::after': {
      clipPath: 'inset(100%)',
      clip: 'rect(1px, 1px, 1px, 1px)',
      height: '1px',
      overflow: 'hidden',
      position: 'absolute',
      whiteSpace: 'nowrap',
      width: '1px'
    },
    '&::before': {
      // eslint-disable-next-line @atlaskit/ui-styling-standard/no-unsafe-values
      content: "' [".concat(startMarker, "] '")
    },
    '&::after': {
      // eslint-disable-next-line @atlaskit/ui-styling-standard/no-unsafe-values
      content: "' [".concat(endMarker, "] '")
    }
  });
};
export var MarkComponent = function MarkComponent(_ref) {
  var annotationParentIds = _ref.annotationParentIds,
    children = _ref.children,
    dataAttributes = _ref.dataAttributes,
    id = _ref.id,
    state = _ref.state,
    hasFocus = _ref.hasFocus,
    isHovered = _ref.isHovered,
    onClick = _ref.onClick,
    useBlockLevel = _ref.useBlockLevel;
  var intl = useIntl();
  var annotationIds = useMemo(function () {
    return _toConsumableArray(new Set([].concat(_toConsumableArray(annotationParentIds), [id])));
  }, [id, annotationParentIds]);
  var onMarkClick = useCallback(function (event) {
    // prevent inline mark logic for media block marks
    if (event.currentTarget instanceof HTMLElement && event.currentTarget.getAttribute('data-block-mark')) {
      return;
    }

    // prevents multiple callback on overlapping annotations
    if (event.defaultPrevented || state !== AnnotationMarkStates.ACTIVE) {
      return;
    }
    if (fg('editor_inline_comments_on_inline_nodes')) {
      // We only want to interfere with click events if the click is on some ui inside the renderer document
      // This is to prevent the click events from portaled content (such as link previews and mention profiles)
      if (event.target instanceof HTMLElement && event.target.closest('.ak-renderer-document')) {
        if (event.target.closest('[data-mention-id]')) {
          // don't prevent default for mentions
        } else {
          // prevents from opening link URL inside webView in Safari
          event.preventDefault();
          event.stopPropagation();
        }
      }
    } else {
      // prevents from opening link URL inside webView in Safari
      event.preventDefault();
    }

    // Ignored via go/ees005
    // eslint-disable-next-line @atlaskit/editor/no-as-casting
    onClick({
      eventTarget: event.target,
      annotationIds: annotationIds
    });
  }, [annotationIds, onClick, state]);
  var onMarkEnter = function onMarkEnter(evt) {
    var _document$activeEleme;
    var focusedElementTag = (_document$activeEleme = document.activeElement) === null || _document$activeEleme === void 0 ? void 0 : _document$activeEleme.tagName;
    if (focusedElementTag === 'MARK' && evt.key === 'Enter') {
      onMarkClick(evt);
    }
  };
  var overriddenData = !state ? dataAttributes : _objectSpread(_objectSpread({}, dataAttributes), {}, {
    'data-mark-annotation-state': state,
    'data-has-focus': hasFocus,
    'data-is-hovered': isHovered
  });
  var desktopAccessibilityAttributes = isMobile() ? {} : {
    role: 'button',
    tabIndex: 0,
    onKeyDown: onMarkEnter,
    'aria-expanded': hasFocus
  };
  var accessibility = state !== AnnotationMarkStates.ACTIVE ? {
    'aria-disabled': true
  } : _objectSpread({
    'aria-details': annotationIds.join(', ')
  }, desktopAccessibilityAttributes);
  var getAccessibilityStyles = function getAccessibilityStyles() {
    if (isMobile()) {
      return {};
    }
    if (state !== AnnotationMarkStates.RESOLVED) {
      var startMarker = intl.formatMessage(inlineCommentMessages.contentRendererInlineCommentMarkerStart);
      var endMarker = intl.formatMessage(inlineCommentMessages.contentRendererInlineCommentMarkerEnd);
      return accessibilityStyles(startMarker, endMarker);
    } else {
      return {};
    }
  };
  return jsx(useBlockLevel ? 'div' : 'mark', _objectSpread(_objectSpread(_objectSpread(_defineProperty({
    id: id
  }, fg('editor_inline_comments_on_inline_nodes') ? 'onClickCapture' : 'onClick', onMarkClick), accessibility), overriddenData), !useBlockLevel && {
    css: [markStyles, getAccessibilityStyles()]
  }), children);
};