import _extends from "@babel/runtime/helpers/extends";
import _classCallCheck from "@babel/runtime/helpers/classCallCheck";
import _createClass from "@babel/runtime/helpers/createClass";
import _possibleConstructorReturn from "@babel/runtime/helpers/possibleConstructorReturn";
import _getPrototypeOf from "@babel/runtime/helpers/getPrototypeOf";
import _inherits from "@babel/runtime/helpers/inherits";
import _defineProperty from "@babel/runtime/helpers/defineProperty";
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
/**
 * @jsxRuntime classic
 * @jsx jsx
 */
import React, { Fragment, PureComponent, useCallback, useContext, useEffect, useLayoutEffect, useMemo, useRef } from 'react';
// eslint-disable-next-line @atlaskit/ui-styling-standard/use-compiled -- Ignored via go/DSP-18766
import { getSchemaBasedOnStage } from '@atlaskit/adf-schema/schema-default';
import { ProviderFactory, ProviderFactoryProvider } from '@atlaskit/editor-common/provider-factory';
import { BaseTheme, IntlErrorBoundary, UnsupportedBlock, WidthProvider, WithCreateAnalyticsEvent } from '@atlaskit/editor-common/ui';
import { editorExperiment } from '@atlaskit/tmp-editor-statsig/experiments';
// eslint-disable-next-line @atlaskit/ui-styling-standard/use-compiled -- Ignored via go/DSP-18766
import { css, jsx } from '@emotion/react';
import { browser } from '@atlaskit/editor-common/browser';
import { startMeasure, stopMeasure } from '@atlaskit/editor-common/performance-measures';
import { getDistortedDurationMonitor } from '@atlaskit/editor-common/performance/measure-render';
import { getResponseEndTime } from '@atlaskit/editor-common/performance/navigation';
import { getAnalyticsAppearance, getAnalyticsEventSeverity, shouldForceTracking } from '@atlaskit/editor-common/utils';
import { fg } from '@atlaskit/platform-feature-flags';
import { FabricChannel } from '@atlaskit/analytics-listeners/types';
import { FabricEditorAnalyticsContext } from '@atlaskit/analytics-namespaced-context';
import { ACTION, ACTION_SUBJECT, EVENT_TYPE } from '@atlaskit/editor-common/analytics';
import { normalizeFeatureFlags } from '@atlaskit/editor-common/normalize-feature-flags';
import { akEditorFullPageDefaultFontSize } from '@atlaskit/editor-shared-styles';
import memoizeOne from 'memoize-one';
import uuid from 'uuid/v4';
import { ReactSerializer, renderDocument } from '../../';
import AnalyticsContext from '../../analytics/analyticsContext';
import { MODE, PLATFORM } from '../../analytics/events';
import { EditorMediaClientProvider } from '../../react/utils/EditorMediaClientProvider';
import { getActiveHeadingId, isNestedHeaderLinksEnabled } from '../../react/utils/links';
import { RendererContextProvider, useRendererContext } from '../../renderer-context';
import { findInTree } from '../../utils';
import { RendererContext as ActionsContext, RendererActionsContext } from '../RendererActionsContext';
import { Provider as SmartCardStorageProvider } from '../SmartCardStorage';
import { ActiveHeaderIdProvider } from '../active-header-id-provider';
import { AnnotationsPositionContext, AnnotationsWrapper } from '../annotations';
import { ErrorBoundary } from './ErrorBoundary';
import { BreakoutSSRInlineScript } from './breakout-ssr';
import { isInteractiveElement } from './click-to-edit';
import { countNodes } from './count-nodes';
import { TELEPOINTER_ID, rendererStyles } from './style';
import { TruncatedWrapper } from './truncated-wrapper';
import { ValidationContext } from './ValidationContext';
export var NORMAL_SEVERITY_THRESHOLD = 2000;
export var DEGRADED_SEVERITY_THRESHOLD = 3000;
var packageName = "@atlaskit/renderer";
var packageVersion = "112.15.0";
var setAsQueryContainerStyles = css({
  containerName: 'ak-renderer-wrapper',
  containerType: 'inline-size',
  contain: 'layout style inline-size'
});

/**
 * Exported due to enzyme test reliance on this component.
 */
// eslint-disable-next-line @repo/internal/react/no-class-components
export var __RendererClassComponent = /*#__PURE__*/function (_PureComponent) {
  function __RendererClassComponent(props) {
    var _this;
    _classCallCheck(this, __RendererClassComponent);
    _this = _callSuper(this, __RendererClassComponent, [props]);
    /**
     * This is used in measuring the Renderer Mount time and is then
     * deleted once that measurement occurs.
     */
    _defineProperty(_this, "renderedMeasurementDistortedDurationMonitor", getDistortedDurationMonitor());
    _defineProperty(_this, "createRendererContext", memoizeOne(function (featureFlags, isTopLevelRenderer) {
      var normalizedFeatureFlags = normalizeFeatureFlags(featureFlags);
      return {
        featureFlags: normalizedFeatureFlags,
        // The context is uninitialized at the top level. In nested levels it's all false
        isTopLevelRenderer: isTopLevelRenderer === undefined
      };
    }));
    _defineProperty(_this, "fireAnalyticsEvent", function (event) {
      var createAnalyticsEvent = _this.props.createAnalyticsEvent;
      if (createAnalyticsEvent) {
        var channel = FabricChannel.editor;
        createAnalyticsEvent(event).fire(channel);
      }
    });
    _defineProperty(_this, "getSchema", memoizeOne(function (schema, adfStage) {
      if (schema) {
        return schema;
      }
      return getSchemaBasedOnStage(adfStage);
    }));
    _defineProperty(_this, "onMouseDownEditView", function () {
      // When the user is deselecting text on the screen by clicking, if they are clicking outside
      // the current selection, by the time the onclick handler is called the window.getSelection()
      // value will already be cleared.
      // The mousedown callback is called before the selection is cleared.
      var windowSelection = window.getSelection();
      _this.mouseDownSelection = windowSelection !== null ? windowSelection.toString() : undefined;
    });
    _defineProperty(_this, "handleMouseTripleClickInTables", function (event) {
      var _parentElement, _parentElement2;
      if (browser.ios || browser.android) {
        return;
      }
      var badBrowser = browser.chrome || browser.safari;
      var tripleClick = event.detail >= 3;
      if (!(badBrowser && tripleClick)) {
        return;
      }
      var selection = window.getSelection();
      if (!selection) {
        return;
      }
      var type = selection.type,
        anchorNode = selection.anchorNode,
        focusNode = selection.focusNode;
      var rangeSelection = Boolean(type === 'Range' && anchorNode && focusNode);
      if (!rangeSelection) {
        return;
      }
      // Ignored via go/ees005
      // eslint-disable-next-line @atlaskit/editor/no-as-casting
      var target = event.target;
      var tableCell = target.closest('td,th');
      var clickedInCell = Boolean(tableCell);
      if (!clickedInCell) {
        return;
      }
      // Ignored via go/ees005
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      var anchorInCell = tableCell.contains(anchorNode);
      // Ignored via go/ees005
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      var focusInCell = tableCell.contains(focusNode);
      var selectionStartsOrEndsOutsideClickedCell = !(anchorInCell && focusInCell);
      if (!selectionStartsOrEndsOutsideClickedCell) {
        return;
      }
      // If selection starts or ends in a different cell than the clicked cell,
      // we select the node inside the clicked cell (or if both are in a different
      // cell, we select the cell's contents instead). We want to select the nearest
      // parent block, so that a whole line of text/content is selected (rather than
      // selecting a span that would select one specific chunk of text).
      var elementToSelect = anchorInCell ? // Ignored via go/ees005
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      (_parentElement = anchorNode.parentElement) === null || _parentElement === void 0 ? void 0 : _parentElement.closest('div,p') : focusInCell ? // Ignored via go/ees005
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      (_parentElement2 = focusNode.parentElement) === null || _parentElement2 === void 0 ? void 0 : _parentElement2.closest('div,p') : tableCell;
      if (elementToSelect) {
        selection.selectAllChildren(elementToSelect);
      }
    });
    _this.providerFactory = props.dataProviders || new ProviderFactory();
    _this.serializer = new ReactSerializer(_this.deriveSerializerProps(props));
    _this.editorRef = props.innerRef || /*#__PURE__*/React.createRef();
    _this.id = uuid();
    startMeasure("Renderer Render Time: ".concat(_this.id));
    return _this;
  }
  _inherits(__RendererClassComponent, _PureComponent);
  return _createClass(__RendererClassComponent, [{
    key: "anchorLinkAnalytics",
    value: function anchorLinkAnalytics() {
      var hash = window.location.hash && decodeURIComponent(window.location.hash.slice(1));
      var disableHeadingIDs = this.props.disableHeadingIDs;
      if (!disableHeadingIDs && hash && this.editorRef && this.editorRef.current instanceof HTMLElement) {
        var anchorLinkElement = document.getElementById(hash);
        // We are not use this.editorRef.querySelector here, instead we have this.editorRef.contains
        // because querySelector might fail if there are special characters in hash, and CSS.escape is still experimental.
        if (anchorLinkElement && this.editorRef.current.contains(anchorLinkElement)) {
          this.fireAnalyticsEvent({
            action: ACTION.VIEWED,
            actionSubject: ACTION_SUBJECT.ANCHOR_LINK,
            attributes: {
              platform: PLATFORM.WEB,
              mode: MODE.RENDERER
            },
            eventType: EVENT_TYPE.UI
          });
        }
      }
    }
  }, {
    key: "componentDidMount",
    value: function componentDidMount() {
      var _this2 = this;
      this.fireAnalyticsEvent({
        action: ACTION.STARTED,
        actionSubject: ACTION_SUBJECT.RENDERER,
        attributes: {
          platform: PLATFORM.WEB
        },
        eventType: EVENT_TYPE.UI
      });
      this.rafID = requestAnimationFrame(function () {
        stopMeasure("Renderer Render Time: ".concat(_this2.id), function (duration) {
          var _analyticsEventSeveri, _analyticsEventSeveri2, _this2$props;
          var analyticsEventSeverityTracking = _this2.props.analyticsEventSeverityTracking;
          var forceSeverityTracking = typeof analyticsEventSeverityTracking === 'undefined' && shouldForceTracking();
          var severity = !!forceSeverityTracking || analyticsEventSeverityTracking !== null && analyticsEventSeverityTracking !== void 0 && analyticsEventSeverityTracking.enabled ? getAnalyticsEventSeverity(duration, (_analyticsEventSeveri = analyticsEventSeverityTracking === null || analyticsEventSeverityTracking === void 0 ? void 0 : analyticsEventSeverityTracking.severityNormalThreshold) !== null && _analyticsEventSeveri !== void 0 ? _analyticsEventSeveri : NORMAL_SEVERITY_THRESHOLD, (_analyticsEventSeveri2 = analyticsEventSeverityTracking === null || analyticsEventSeverityTracking === void 0 ? void 0 : analyticsEventSeverityTracking.severityDegradedThreshold) !== null && _analyticsEventSeveri2 !== void 0 ? _analyticsEventSeveri2 : DEGRADED_SEVERITY_THRESHOLD) : undefined;

          // ED-16320: Check for explicit disable so that by default
          // it will still be enabled as it currently is. Then we can
          // progressively opt out synthetic tenants.
          var isTTRTrackingExplicitlyDisabled = ((_this2$props = _this2.props) === null || _this2$props === void 0 || (_this2$props = _this2$props.analyticsEventSeverityTracking) === null || _this2$props === void 0 ? void 0 : _this2$props.enabled) === false;
          if (!isTTRTrackingExplicitlyDisabled) {
            _this2.fireAnalyticsEvent({
              action: ACTION.RENDERED,
              actionSubject: ACTION_SUBJECT.RENDERER,
              attributes: {
                platform: PLATFORM.WEB,
                duration: duration,
                distortedDuration:
                // Ignored via go/ees005
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                _this2.renderedMeasurementDistortedDurationMonitor.distortedDuration,
                ttfb: getResponseEndTime(),
                nodes: countNodes(_this2.props.document),
                severity: severity
              },
              eventType: EVENT_TYPE.OPERATIONAL
            });
          }

          // Ignored via go/ees005
          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
          _this2.renderedMeasurementDistortedDurationMonitor.cleanup();
          delete _this2.renderedMeasurementDistortedDurationMonitor;
        });
        _this2.anchorLinkAnalytics();
      });
    }

    // Ignored via go/ees005
    // eslint-disable-next-line react/no-unsafe
  }, {
    key: "UNSAFE_componentWillReceiveProps",
    value: function UNSAFE_componentWillReceiveProps(nextProps) {
      var nextMedia = nextProps.media || {};
      var media = this.props.media || {};
      if (nextProps.portal !== this.props.portal || nextProps.appearance !== this.props.appearance || nextProps.stickyHeaders !== this.props.stickyHeaders || nextProps.disableActions !== this.props.disableActions || nextProps.allowCustomPanels !== this.props.allowCustomPanels || nextProps.extensionHandlers !== this.props.extensionHandlers || nextProps.allowHeadingAnchorLinks !== this.props.allowHeadingAnchorLinks || nextMedia.allowLinking !== media.allowLinking) {
        this.serializer = new ReactSerializer(this.deriveSerializerProps(nextProps));
      }
    }
  }, {
    key: "deriveSerializerProps",
    value: function deriveSerializerProps(props) {
      // if just passed a boolean, change shape into object to simplify type
      var stickyHeaders = props.stickyHeaders ? props.stickyHeaders === true ? {} : props.stickyHeaders : undefined;
      var annotationProvider = props.annotationProvider;
      var allowAnnotationsDraftMode = Boolean(annotationProvider && annotationProvider.inlineComment && annotationProvider.inlineComment.allowDraftMode);
      var _this$createRendererC = this.createRendererContext(props.featureFlags, props.isTopLevelRenderer),
        featureFlags = _this$createRendererC.featureFlags;
      return {
        startPos: props.startPos,
        providers: this.providerFactory,
        eventHandlers: props.eventHandlers,
        extensionHandlers: props.extensionHandlers,
        portal: props.portal,
        objectContext: _objectSpread({
          adDoc: props.document,
          schema: props.schema
        }, props.rendererContext),
        appearance: props.appearance,
        disableHeadingIDs: props.disableHeadingIDs,
        disableActions: props.disableActions,
        allowHeadingAnchorLinks: props.allowHeadingAnchorLinks,
        allowColumnSorting: props.allowColumnSorting,
        fireAnalyticsEvent: this.fireAnalyticsEvent,
        shouldOpenMediaViewer: props.shouldOpenMediaViewer,
        allowAltTextOnImages: props.allowAltTextOnImages,
        stickyHeaders: stickyHeaders,
        allowMediaLinking: props.media && props.media.allowLinking,
        surroundTextNodesWithTextWrapper: allowAnnotationsDraftMode,
        media: props.media,
        emojiResourceConfig: props.emojiResourceConfig,
        smartLinks: props.smartLinks,
        allowCopyToClipboard: props.allowCopyToClipboard,
        allowWrapCodeBlock: props.allowWrapCodeBlock,
        allowCustomPanels: props.allowCustomPanels,
        allowAnnotations: props.allowAnnotations,
        allowSelectAllTrap: props.allowSelectAllTrap,
        allowPlaceholderText: props.allowPlaceholderText,
        nodeComponents: props.nodeComponents,
        // does not currently support SSR, should not be enabled in environments where Renderer is SSR-ed
        allowWindowedCodeBlock: featureFlags === null || featureFlags === void 0 ? void 0 : featureFlags.allowWindowedCodeBlock,
        isInsideOfInlineExtension: props.isInsideOfInlineExtension,
        textHighlighter: props.UNSTABLE_textHighlighter,
        allowTableAlignment: props.UNSTABLE_allowTableAlignment,
        allowTableResizing: props.UNSTABLE_allowTableResizing
      };
    }
  }, {
    key: "render",
    value: function render() {
      var _this3 = this;
      var _this$props = this.props,
        adfDocument = _this$props.document,
        onComplete = _this$props.onComplete,
        onError = _this$props.onError,
        appearance = _this$props.appearance,
        allowAnnotations = _this$props.allowAnnotations,
        adfStage = _this$props.adfStage,
        truncated = _this$props.truncated,
        maxHeight = _this$props.maxHeight,
        fadeOutHeight = _this$props.fadeOutHeight,
        enableSsrInlineScripts = _this$props.enableSsrInlineScripts,
        noOpSSRInlineScript = _this$props.noOpSSRInlineScript,
        allowHeadingAnchorLinks = _this$props.allowHeadingAnchorLinks,
        allowPlaceholderText = _this$props.allowPlaceholderText,
        allowColumnSorting = _this$props.allowColumnSorting,
        allowCopyToClipboard = _this$props.allowCopyToClipboard,
        allowWrapCodeBlock = _this$props.allowWrapCodeBlock,
        allowCustomPanels = _this$props.allowCustomPanels,
        media = _this$props.media,
        skipValidation = _this$props.skipValidation;
      var rendererContext = this.createRendererContext(this.props.featureFlags, this.props.isTopLevelRenderer);
      var allowNestedHeaderLinks = isNestedHeaderLinksEnabled(allowHeadingAnchorLinks);
      /**
       * Handle clicks inside renderer. If the click isn't on media, in the media picker, or on a
       * link, call the onUnhandledClick eventHandler (which in Jira for example, may switch the
       * renderer out for the editor).
       * @param event Click event anywhere inside renderer
       */
      var handleWrapperOnClick = function handleWrapperOnClick(event) {
        var _this3$props$eventHan;
        // Ignored via go/ees005
        // eslint-disable-next-line @atlaskit/editor/no-as-casting
        var targetElement = event.target;

        // ED-14862: When a user triple clicks to select a line of content inside a
        // a table cell, but the browser incorrectly moves the selection start or end into
        // a different table cell, we manually set the selection back to within the original
        // table cell the user intended to target
        _this3.handleMouseTripleClickInTables(event);
        if (!((_this3$props$eventHan = _this3.props.eventHandlers) !== null && _this3$props$eventHan !== void 0 && _this3$props$eventHan.onUnhandledClick)) {
          return;
        }
        if (!(targetElement instanceof window.Element)) {
          return;
        }

        // Ignored via go/ees005
        // eslint-disable-next-line @atlaskit/editor/no-as-casting
        var rendererWrapper = event.currentTarget;

        // Check if the click was on an interactive element
        var isInteractiveElementInTree = findInTree(targetElement, rendererWrapper, isInteractiveElement);
        if (isInteractiveElementInTree) {
          return;
        }

        // Ensure that selecting text in the renderer doesn't trigger onUnhandledClick
        // This logic originated in jira-frontend:
        // src/packages/issue/issue-view/src/views/field/rich-text/rich-text-inline-edit-view.js

        // The selection is required to be checked in `onMouseDown` and here. If not here, a new
        // selection isn't reported; if not in `onMouseDown`, a click outside the selection will
        // return an empty selection, which will erroneously fire onUnhandledClick.
        var windowSelection = window.getSelection();
        var selection = windowSelection !== null ? windowSelection.toString() : undefined;
        var hasSelection = selection && selection.length !== 0;
        var hasSelectionMouseDown = _this3.mouseDownSelection && _this3.mouseDownSelection.length !== 0;
        var allowEditBasedOnSelection = !hasSelection && !hasSelectionMouseDown;
        if (allowEditBasedOnSelection) {
          _this3.props.eventHandlers.onUnhandledClick(event);
        }
      };
      try {
        var _rendererContext$feat;
        var schema = this.getSchema(this.props.schema, this.props.adfStage);
        var _renderDocument = renderDocument(adfDocument, this.serializer, schema, adfStage, this.props.useSpecBasedValidator, this.id, this.fireAnalyticsEvent, this.props.unsupportedContentLevelsTracking, this.props.appearance, this.props.includeNodesCountInStats, skipValidation),
          result = _renderDocument.result,
          stat = _renderDocument.stat,
          pmDoc = _renderDocument.pmDoc;
        if (onComplete) {
          onComplete(stat);
        }
        var rendererOutput = jsx(RendererContextProvider, {
          value: rendererContext
        }, jsx(ActiveHeaderIdProvider, {
          value: getActiveHeadingId(allowHeadingAnchorLinks)
        }, jsx(AnalyticsContext.Provider, {
          value: {
            fireAnalyticsEvent: function fireAnalyticsEvent(event) {
              return _this3.fireAnalyticsEvent(event);
            }
          }
        }, jsx(SmartCardStorageProvider, null, jsx(ProviderFactoryProvider, {
          value: this.providerFactory
        }, jsx(RendererWrapper, {
          allowAnnotations: allowAnnotations,
          appearance: appearance,
          allowNestedHeaderLinks: allowNestedHeaderLinks,
          allowColumnSorting: allowColumnSorting,
          allowCopyToClipboard: allowCopyToClipboard,
          allowWrapCodeBlock: allowWrapCodeBlock,
          allowCustomPanels: allowCustomPanels,
          allowPlaceholderText: allowPlaceholderText,
          useBlockRenderForCodeBlock: (_rendererContext$feat = rendererContext.featureFlags.useBlockRenderForCodeBlock) !== null && _rendererContext$feat !== void 0 ? _rendererContext$feat : true,
          addTelepointer: this.props.addTelepointer,
          innerRef: this.editorRef,
          onClick: handleWrapperOnClick,
          onMouseDown: this.onMouseDownEditView,
          ssr: media === null || media === void 0 ? void 0 : media.ssr,
          isInsideOfInlineExtension: this.props.isInsideOfInlineExtension,
          isTopLevelRenderer: rendererContext.isTopLevelRenderer
        }, enableSsrInlineScripts || noOpSSRInlineScript ? jsx(BreakoutSSRInlineScript, {
          noOpSSRInlineScript: Boolean(noOpSSRInlineScript)
        }) : null, jsx(RendererActionsInternalUpdater, {
          doc: pmDoc,
          schema: schema,
          onAnalyticsEvent: this.fireAnalyticsEvent
        }, result)))))));
        var rendererResult = truncated ? jsx(TruncatedWrapper, {
          height: maxHeight,
          fadeHeight: fadeOutHeight
        }, rendererOutput) : rendererOutput;
        return jsx(Fragment, null, rendererResult);
      } catch (e) {
        var _rendererContext$feat2;
        if (onError) {
          onError(e);
        }
        return jsx(RendererWrapper, {
          allowAnnotations: allowAnnotations,
          appearance: appearance,
          allowCopyToClipboard: allowCopyToClipboard,
          allowWrapCodeBlock: allowWrapCodeBlock,
          allowPlaceholderText: allowPlaceholderText,
          allowColumnSorting: allowColumnSorting,
          allowNestedHeaderLinks: allowNestedHeaderLinks,
          useBlockRenderForCodeBlock: (_rendererContext$feat2 = rendererContext.featureFlags.useBlockRenderForCodeBlock) !== null && _rendererContext$feat2 !== void 0 ? _rendererContext$feat2 : true,
          addTelepointer: this.props.addTelepointer,
          onClick: handleWrapperOnClick,
          isTopLevelRenderer: rendererContext.isTopLevelRenderer
        }, jsx(UnsupportedBlock, null));
      }
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      var dataProviders = this.props.dataProviders;
      if (this.rafID) {
        window.cancelAnimationFrame(this.rafID);
      }

      // if this is the ProviderFactory which was created in constructor
      // it's safe to destroy it on Renderer unmount
      if (!dataProviders) {
        this.providerFactory.destroy();
      }
    }
  }]);
}(PureComponent);
var handleMouseTripleClickInTables = function handleMouseTripleClickInTables(event) {
  var _parentElement3, _parentElement4;
  if (browser.ios || browser.android) {
    return;
  }
  var badBrowser = browser.chrome || browser.safari;
  var tripleClick = event.detail >= 3;
  if (!(badBrowser && tripleClick)) {
    return;
  }
  var selection = window.getSelection();
  if (!selection) {
    return;
  }
  var type = selection.type,
    anchorNode = selection.anchorNode,
    focusNode = selection.focusNode;
  var rangeSelection = Boolean(type === 'Range' && anchorNode && focusNode);
  if (!rangeSelection) {
    return;
  }
  // Ignored via go/ees005
  // eslint-disable-next-line @atlaskit/editor/no-as-casting
  var target = event.target;
  var tableCell = target.closest('td,th');
  var clickedInCell = Boolean(tableCell);
  if (!clickedInCell) {
    return;
  }
  // Ignored via go/ees005
  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
  var anchorInCell = tableCell.contains(anchorNode);
  // Ignored via go/ees005
  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
  var focusInCell = tableCell.contains(focusNode);
  var selectionStartsOrEndsOutsideClickedCell = !(anchorInCell && focusInCell);
  if (!selectionStartsOrEndsOutsideClickedCell) {
    return;
  }

  // Ensure that selecting text in the renderer doesn't trigger onUnhandledClick
  // This logic originated in jira-frontend:
  // src/packages/issue/issue-view/src/views/field/rich-text/rich-text-inline-edit-view.js

  // The selection is required to be checked in `onMouseDown` and here. If not here, a new
  // selection isn't reported; if not in `onMouseDown`, a click outside the selection will
  // return an empty selection, which will erroneously fire onUnhandledClick.

  var elementToSelect = anchorInCell ? // Ignored via go/ees005
  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
  (_parentElement3 = anchorNode.parentElement) === null || _parentElement3 === void 0 ? void 0 : _parentElement3.closest('div,p') : focusInCell ? // Ignored via go/ees005
  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
  (_parentElement4 = focusNode.parentElement) === null || _parentElement4 === void 0 ? void 0 : _parentElement4.closest('div,p') : tableCell;
  if (elementToSelect) {
    selection.selectAllChildren(elementToSelect);
  }
};

/**
 * Handle clicks inside renderer. If the click isn't on media, in the media picker, or on a
 * link, call the onUnhandledClick eventHandler (which in Jira for example, may switch the
 * renderer out for the editor).
 * @param event Click event anywhere inside renderer
 */
var handleWrapperOnClick = function handleWrapperOnClick(event, props, mouseDownSelection) {
  var _props$eventHandlers;
  // Ignored via go/ees005
  // eslint-disable-next-line @atlaskit/editor/no-as-casting
  var targetElement = event.target;
  handleMouseTripleClickInTables(event);

  // ED-14862: When a user triple clicks to select a line of content inside a
  // a table cell, but the browser incorrectly moves the selection start or end into
  // a different table cell, we manually set the selection back to within the original
  // table cell the user intended to target
  if (!((_props$eventHandlers = props.eventHandlers) !== null && _props$eventHandlers !== void 0 && _props$eventHandlers.onUnhandledClick)) {
    return;
  }
  if (!(targetElement instanceof window.Element)) {
    return;
  }

  // Ignored via go/ees005
  // eslint-disable-next-line @atlaskit/editor/no-as-casting
  var rendererWrapper = event.currentTarget;
  var isInteractiveElementInTree = findInTree(targetElement, rendererWrapper, isInteractiveElement);
  if (isInteractiveElementInTree) {
    return;
  }

  // Ensure that selecting text in the renderer doesn't trigger onUnhandledClick
  // This logic originated in jira-frontend:
  // src/packages/issue/issue-view/src/views/field/rich-text/rich-text-inline-edit-view.js

  // The selection is required to be checked in `onMouseDown` and here. If not here, a new
  // selection isn't reported; if not in `onMouseDown`, a click outside the selection will
  // return an empty selection, which will erroneously fire onUnhandledClick.
  var windowSelection = window.getSelection();
  var selection = windowSelection !== null ? windowSelection.toString() : undefined;
  var hasSelection = selection && selection.length !== 0;
  var hasSelectionMouseDown = mouseDownSelection.current && mouseDownSelection.current.length !== 0;
  var allowEditBasedOnSelection = !hasSelection && !hasSelectionMouseDown;
  if (allowEditBasedOnSelection) {
    props.eventHandlers.onUnhandledClick(event);
  }
};
var RendererFunctionalComponent = function RendererFunctionalComponent(props) {
  var mouseDownSelection = useRef(undefined);
  var providerFactory = useMemo(function () {
    return props.dataProviders || new ProviderFactory();
  }, [props.dataProviders]);
  var createRendererContext = useMemo(function () {
    return function (featureFlags, isTopLevelRenderer) {
      var normalizedFeatureFlags = normalizeFeatureFlags(featureFlags);
      return {
        featureFlags: normalizedFeatureFlags,
        isTopLevelRenderer: isTopLevelRenderer === undefined
      };
    };
  }, []);
  var _fireAnalyticsEvent = useCallback(function (event) {
    var createAnalyticsEvent = props.createAnalyticsEvent;
    if (createAnalyticsEvent) {
      var channel = FabricChannel.editor;
      createAnalyticsEvent(event).fire(channel);
    }
  }, [props]);
  var deriveSerializerProps = useCallback(function (props) {
    var stickyHeaders = props.stickyHeaders ? props.stickyHeaders === true ? {} : props.stickyHeaders : undefined;
    var annotationProvider = props.annotationProvider;
    var allowAnnotationsDraftMode = Boolean(annotationProvider && annotationProvider.inlineComment && annotationProvider.inlineComment.allowDraftMode);
    var _createRendererContex = createRendererContext(props.featureFlags, props.isTopLevelRenderer),
      featureFlags = _createRendererContex.featureFlags;
    return {
      startPos: props.startPos,
      providers: providerFactory,
      eventHandlers: props.eventHandlers,
      extensionHandlers: props.extensionHandlers,
      portal: props.portal,
      objectContext: _objectSpread({
        adDoc: props.document,
        schema: props.schema
      }, props.rendererContext),
      appearance: props.appearance,
      disableHeadingIDs: props.disableHeadingIDs,
      disableActions: props.disableActions,
      allowHeadingAnchorLinks: props.allowHeadingAnchorLinks,
      allowColumnSorting: props.allowColumnSorting,
      fireAnalyticsEvent: _fireAnalyticsEvent,
      shouldOpenMediaViewer: props.shouldOpenMediaViewer,
      allowAltTextOnImages: props.allowAltTextOnImages,
      stickyHeaders: stickyHeaders,
      allowMediaLinking: props.media && props.media.allowLinking,
      surroundTextNodesWithTextWrapper: allowAnnotationsDraftMode,
      media: props.media,
      emojiResourceConfig: props.emojiResourceConfig,
      smartLinks: props.smartLinks,
      allowCopyToClipboard: props.allowCopyToClipboard,
      allowWrapCodeBlock: props.allowWrapCodeBlock,
      allowCustomPanels: props.allowCustomPanels,
      allowAnnotations: props.allowAnnotations,
      allowSelectAllTrap: props.allowSelectAllTrap,
      allowPlaceholderText: props.allowPlaceholderText,
      nodeComponents: props.nodeComponents,
      allowWindowedCodeBlock: featureFlags === null || featureFlags === void 0 ? void 0 : featureFlags.allowWindowedCodeBlock,
      isInsideOfInlineExtension: props.isInsideOfInlineExtension,
      textHighlighter: props.UNSTABLE_textHighlighter,
      allowTableAlignment: props.UNSTABLE_allowTableAlignment,
      allowTableResizing: props.UNSTABLE_allowTableResizing
    };
  }, [createRendererContext, providerFactory, _fireAnalyticsEvent]);
  var serializer = useMemo(function () {
    var _props$startPos;
    return new ReactSerializer(deriveSerializerProps(_objectSpread(_objectSpread({}, props), {}, {
      startPos: (_props$startPos = props.startPos) !== null && _props$startPos !== void 0 ? _props$startPos : 0
    })));
  }, [deriveSerializerProps, props]);
  var localRef = useRef(null);
  var editorRef = props.innerRef || localRef;
  var id = useMemo(function () {
    return uuid();
  }, []);
  var renderedMeasurementDistortedDurationMonitor = useMemo(function () {
    return getDistortedDurationMonitor();
  }, []);

  // we are doing this to ensure it runs as
  // early as possible in the React lifecycle
  // to avoid any other side effects
  var measureStarted = useRef(false);
  var startAnalyticsMeasure = function startAnalyticsMeasure() {
    startMeasure("Renderer Render Time: ".concat(id));
  };
  if (!measureStarted.current) {
    startAnalyticsMeasure();
    measureStarted.current = true;
  }
  var anchorLinkAnalytics = useCallback(function () {
    var hash = window.location.hash && decodeURIComponent(window.location.hash.slice(1));
    var disableHeadingIDs = props.disableHeadingIDs;
    if (!disableHeadingIDs && hash && editorRef && editorRef.current instanceof HTMLElement) {
      var anchorLinkElement = document.getElementById(hash);
      if (anchorLinkElement && editorRef.current.contains(anchorLinkElement)) {
        _fireAnalyticsEvent({
          action: ACTION.VIEWED,
          actionSubject: ACTION_SUBJECT.ANCHOR_LINK,
          attributes: {
            platform: PLATFORM.WEB,
            mode: MODE.RENDERER
          },
          eventType: EVENT_TYPE.UI
        });
      }
    }
  }, [props.disableHeadingIDs, editorRef, _fireAnalyticsEvent]);
  var getSchema = useMemo(function () {
    return function (schema, adfStage) {
      if (schema) {
        return schema;
      }
      return getSchemaBasedOnStage(adfStage);
    };
  }, []);
  var onMouseDownEditView = function onMouseDownEditView() {
    var windowSelection = window.getSelection();
    mouseDownSelection.current = windowSelection !== null ? windowSelection.toString() : undefined;
  };
  var dataProviders = props.dataProviders,
    analyticsEventSeverityTracking = props.analyticsEventSeverityTracking;
  useEffect(function () {
    var rafID;
    var handleAnalytics = function handleAnalytics() {
      _fireAnalyticsEvent({
        action: ACTION.STARTED,
        actionSubject: ACTION_SUBJECT.RENDERER,
        attributes: {
          platform: PLATFORM.WEB
        },
        eventType: EVENT_TYPE.UI
      });
      rafID = requestAnimationFrame(function () {
        stopMeasure("Renderer Render Time: ".concat(id), function (duration) {
          var _analyticsEventSeveri3, _analyticsEventSeveri4;
          var forceSeverityTracking = typeof analyticsEventSeverityTracking === 'undefined' && shouldForceTracking();
          var severity = !!forceSeverityTracking || analyticsEventSeverityTracking !== null && analyticsEventSeverityTracking !== void 0 && analyticsEventSeverityTracking.enabled ? getAnalyticsEventSeverity(duration, (_analyticsEventSeveri3 = analyticsEventSeverityTracking === null || analyticsEventSeverityTracking === void 0 ? void 0 : analyticsEventSeverityTracking.severityNormalThreshold) !== null && _analyticsEventSeveri3 !== void 0 ? _analyticsEventSeveri3 : NORMAL_SEVERITY_THRESHOLD, (_analyticsEventSeveri4 = analyticsEventSeverityTracking === null || analyticsEventSeverityTracking === void 0 ? void 0 : analyticsEventSeverityTracking.severityDegradedThreshold) !== null && _analyticsEventSeveri4 !== void 0 ? _analyticsEventSeveri4 : DEGRADED_SEVERITY_THRESHOLD) : undefined;
          var isTTRTrackingExplicitlyDisabled = (analyticsEventSeverityTracking === null || analyticsEventSeverityTracking === void 0 ? void 0 : analyticsEventSeverityTracking.enabled) === false;
          if (!isTTRTrackingExplicitlyDisabled) {
            _fireAnalyticsEvent({
              action: ACTION.RENDERED,
              actionSubject: ACTION_SUBJECT.RENDERER,
              attributes: {
                platform: PLATFORM.WEB,
                duration: duration,
                // Ignored via go/ees005
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                distortedDuration: renderedMeasurementDistortedDurationMonitor.distortedDuration,
                ttfb: getResponseEndTime(),
                nodes: countNodes(props.document),
                severity: severity
              },
              eventType: EVENT_TYPE.OPERATIONAL
            });
          }

          // Ignored via go/ees005
          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
          renderedMeasurementDistortedDurationMonitor.cleanup();
        });
        anchorLinkAnalytics();
      });
    };
    handleAnalytics();
    return function () {
      if (rafID) {
        window.cancelAnimationFrame(rafID);
      }
      if (dataProviders) {
        providerFactory.destroy();
      }
    };
    // we are going to ignore this because I'm doing this on purpose
    // having a dependency array means we run stopMeasure twice per render
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);
  try {
    var _createRendererContex2, _props$media;
    var schema = getSchema(props.schema, props.adfStage);
    var _renderDocument2 = renderDocument(props.document, serializer, schema, props.adfStage, props.useSpecBasedValidator, id, _fireAnalyticsEvent, props.unsupportedContentLevelsTracking, props.appearance, props.includeNodesCountInStats, props.skipValidation),
      result = _renderDocument2.result,
      stat = _renderDocument2.stat,
      pmDoc = _renderDocument2.pmDoc;
    if (props.onComplete) {
      props.onComplete(stat);
    }
    var rendererOutput = jsx(RendererContextProvider, {
      value: createRendererContext(props.featureFlags, props.isTopLevelRenderer)
    }, jsx(ActiveHeaderIdProvider, {
      value: getActiveHeadingId(props.allowHeadingAnchorLinks)
    }, jsx(AnalyticsContext.Provider, {
      value: {
        fireAnalyticsEvent: function fireAnalyticsEvent(event) {
          return _fireAnalyticsEvent(event);
        }
      }
    }, jsx(SmartCardStorageProvider, null, jsx(ProviderFactoryProvider, {
      value: providerFactory
    }, jsx(RendererWrapper, {
      allowAnnotations: props.allowAnnotations,
      appearance: props.appearance,
      allowNestedHeaderLinks: isNestedHeaderLinksEnabled(props.allowHeadingAnchorLinks),
      allowColumnSorting: props.allowColumnSorting,
      allowCopyToClipboard: props.allowCopyToClipboard,
      allowWrapCodeBlock: props.allowWrapCodeBlock,
      allowCustomPanels: props.allowCustomPanels,
      allowPlaceholderText: props.allowPlaceholderText,
      useBlockRenderForCodeBlock: (_createRendererContex2 = createRendererContext(props.featureFlags, props.isTopLevelRenderer).featureFlags.useBlockRenderForCodeBlock) !== null && _createRendererContex2 !== void 0 ? _createRendererContex2 : true,
      addTelepointer: props.addTelepointer,
      innerRef: editorRef,
      onClick: function onClick(event) {
        return handleWrapperOnClick(event, props, mouseDownSelection);
      },
      onMouseDown: onMouseDownEditView,
      ssr: (_props$media = props.media) === null || _props$media === void 0 ? void 0 : _props$media.ssr,
      isInsideOfInlineExtension: props.isInsideOfInlineExtension,
      isTopLevelRenderer: createRendererContext(props.featureFlags, props.isTopLevelRenderer).isTopLevelRenderer
    }, props.enableSsrInlineScripts || props.noOpSSRInlineScript ? jsx(BreakoutSSRInlineScript, {
      noOpSSRInlineScript: Boolean(props.noOpSSRInlineScript)
    }) : null, jsx(RendererActionsInternalUpdater, {
      doc: pmDoc,
      schema: schema,
      onAnalyticsEvent: _fireAnalyticsEvent
    }, result)))))));
    var rendererResult = props.truncated ? jsx(TruncatedWrapper, {
      height: props.maxHeight,
      fadeHeight: props.fadeOutHeight
    }, rendererOutput) : rendererOutput;
    return jsx(Fragment, null, rendererResult);
  } catch (e) {
    var _createRendererContex3;
    if (props.onError) {
      props.onError(e);
    }
    return jsx(RendererWrapper, {
      allowAnnotations: props.allowAnnotations,
      appearance: props.appearance,
      allowCopyToClipboard: props.allowCopyToClipboard,
      allowWrapCodeBlock: props.allowWrapCodeBlock,
      allowPlaceholderText: props.allowPlaceholderText,
      allowColumnSorting: props.allowColumnSorting,
      allowNestedHeaderLinks: isNestedHeaderLinksEnabled(props.allowHeadingAnchorLinks),
      useBlockRenderForCodeBlock: (_createRendererContex3 = createRendererContext(props.featureFlags, props.isTopLevelRenderer).featureFlags.useBlockRenderForCodeBlock) !== null && _createRendererContex3 !== void 0 ? _createRendererContex3 : true,
      addTelepointer: props.addTelepointer,
      onClick: function onClick(event) {
        return handleWrapperOnClick(event, props, mouseDownSelection);
      },
      isTopLevelRenderer: createRendererContext(props.featureFlags, props.isTopLevelRenderer).isTopLevelRenderer
    }, jsx(UnsupportedBlock, null));
  }
};
export function Renderer(props) {
  var _React$useContext = React.useContext(AnnotationsPositionContext),
    startPos = _React$useContext.startPos;
  var _useRendererContext = useRendererContext(),
    isTopLevelRenderer = _useRendererContext.isTopLevelRenderer;
  var _ref = useContext(ValidationContext) || {},
    skipValidation = _ref.skipValidation;
  return fg('platform_editor_react18_renderer') ? jsx(RendererFunctionalComponent
  // Ignored via go/ees005
  // eslint-disable-next-line react/jsx-props-no-spreading
  , _extends({}, props, {
    startPos: startPos,
    isTopLevelRenderer: isTopLevelRenderer,
    skipValidation: skipValidation
  })) :
  // eslint-disable-next-line react/jsx-pascal-case
  jsx(__RendererClassComponent
  // Ignored via go/ees005
  // eslint-disable-next-line react/jsx-props-no-spreading
  , _extends({}, props, {
    startPos: startPos,
    isTopLevelRenderer: isTopLevelRenderer,
    skipValidation: skipValidation
  }));
}

// Usage notes:
// Used by Confluence for View page renderer
// For the nested renderers - see RendererWithAnnotationSelection.
export var RendererWithAnalytics = /*#__PURE__*/React.memo(function (props) {
  return jsx(FabricEditorAnalyticsContext, {
    data: {
      appearance: getAnalyticsAppearance(props.appearance),
      packageName: packageName,
      packageVersion: packageVersion,
      componentName: 'renderer',
      editorSessionId: uuid()
    }
  }, jsx(WithCreateAnalyticsEvent, {
    render: function render(createAnalyticsEvent) {
      // `IntlErrorBoundary` only captures Internationalisation errors, leaving others for `ErrorBoundary`.
      return jsx(ErrorBoundary, {
        component: ACTION_SUBJECT.RENDERER,
        rethrowError: true,
        fallbackComponent: null,
        createAnalyticsEvent: createAnalyticsEvent
      }, jsx(IntlErrorBoundary, null, jsx(Renderer
      // Ignored via go/ees005
      // eslint-disable-next-line react/jsx-props-no-spreading
      , _extends({}, props, {
        createAnalyticsEvent: createAnalyticsEvent
      }))));
    }
  }));
});
var RendererWrapper = /*#__PURE__*/React.memo(function (props) {
  var allowColumnSorting = props.allowColumnSorting,
    allowNestedHeaderLinks = props.allowNestedHeaderLinks,
    innerRef = props.innerRef,
    appearance = props.appearance,
    children = props.children,
    onClick = props.onClick,
    onMouseDown = props.onMouseDown,
    useBlockRenderForCodeBlock = props.useBlockRenderForCodeBlock,
    addTelepointer = props.addTelepointer,
    ssr = props.ssr,
    isInsideOfInlineExtension = props.isInsideOfInlineExtension,
    allowTableResizing = props.allowTableResizing,
    isTopLevelRenderer = props.isTopLevelRenderer;
  var createTelepointer = function createTelepointer() {
    var telepointer = document.createElement('span');
    telepointer.textContent = "\u200B";
    telepointer.id = TELEPOINTER_ID;
    return telepointer;
  };
  var initialUpdate = React.useRef(true);
  useEffect(function () {
    // We must check if window is defined, if it isn't we are in a SSR environment
    // and we don't want to add the telepointer
    if (typeof window !== 'undefined' && addTelepointer && innerRef !== null && innerRef !== void 0 && innerRef.current) {
      // Ignored via go/ees005
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      var _renderer = innerRef.current.querySelector('.ak-renderer-document');
      if (initialUpdate.current) {
        var lastChild = _renderer.lastChild;
        lastChild && lastChild.appendChild(createTelepointer());
      }
      var mutateTelepointer = function mutateTelepointer(mutations) {
        mutations.forEach(function (mutation) {
          if (initialUpdate.current) {
            var oldTelepointer = _renderer.querySelector("#".concat(TELEPOINTER_ID));
            if (oldTelepointer) {
              oldTelepointer.remove();
            }
            var _lastChild = _renderer.lastChild;
            _lastChild && _lastChild.appendChild(createTelepointer());
            initialUpdate.current = false;
          }
          if (mutation.type === 'characterData') {
            var parentNode = mutation.target.parentElement;
            if (parentNode) {
              var _oldTelepointer = _renderer.querySelector("#".concat(TELEPOINTER_ID));
              if (_oldTelepointer) {
                _oldTelepointer.remove();
              }
              // Ignored via go/ees005
              // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
              parentNode.appendChild(createTelepointer());
            }
          }
        });
      };
      var observer = new MutationObserver(mutateTelepointer);
      observer.observe(innerRef.current, {
        characterData: true,
        attributes: false,
        childList: true,
        subtree: true
      });
      return function () {
        return observer.disconnect();
      };
    }
  }, [innerRef, addTelepointer]);
  var renderer = jsx(WidthProvider
  // eslint-disable-next-line @atlaskit/ui-styling-standard/no-classname-prop -- Ignored via go/DSP-18766
  , {
    className: "ak-renderer-wrapper is-".concat(appearance),
    "data-appearance": appearance,
    shouldCheckExistingValue: isInsideOfInlineExtension
  }, jsx(BaseTheme, {
    baseFontSize: appearance && appearance !== 'comment' ? akEditorFullPageDefaultFontSize : undefined
  }, jsx(EditorMediaClientProvider, {
    ssr: ssr
  }, jsx("div", {
    ref: innerRef,
    onClick: onClick,
    onMouseDown: onMouseDown
    // eslint-disable-next-line @atlaskit/design-system/consistent-css-prop-usage, @atlaskit/ui-styling-standard/no-imported-style-values -- Ignored via go/DSP-18766
    ,
    css: rendererStyles({
      appearance: appearance,
      allowNestedHeaderLinks: allowNestedHeaderLinks,
      allowColumnSorting: !!allowColumnSorting,
      useBlockRenderForCodeBlock: useBlockRenderForCodeBlock,
      allowAnnotations: props.allowAnnotations,
      allowTableResizing: allowTableResizing
    })
  }, children))));

  // We can only make the wrapper div query container when we have a known width.
  // This is also required for SSR to work correctly. As WidthProvider/WithConsumer will not have the correct width during SSR.
  //
  // We are setting this wrapper div as query container conditionally.
  // Only apply container-type = inline-size when having a known width in full-page/full-width/comment mode.
  // Otherwise when appearance is unspecified the renderer size is decided by the content.
  // In this case we can't set the container-type = inline-size as it will collapse width to 0.
  return (appearance === 'full-page' || appearance === 'full-width' || appearance === 'comment') &&
  // In case of having excerpt-include on page there are multiple renderers nested.
  // Make sure only the root renderer is set to be query container.
  isTopLevelRenderer && fg('platform-fix-table-ssr-resizing') ? jsx("div", {
    css: setAsQueryContainerStyles
  }, renderer) : renderer;
});
var RootRendererContext = /*#__PURE__*/React.createContext(null);
function RendererActionsInternalUpdater(_ref2) {
  var children = _ref2.children,
    doc = _ref2.doc,
    schema = _ref2.schema,
    onAnalyticsEvent = _ref2.onAnalyticsEvent;
  var rootRendererContextValue = React.useContext(RootRendererContext);
  var actions = useContext(ActionsContext);
  var rendererRef = useRef(null);

  // This doc is used by the renderer actions when applying comments to the document.
  // (via hand crafted steps based on non prosemirror based position calculations)
  // It is set to the root renderer's doc as otherwise the resulting document will
  // be incorrect (nested renderers use a fake document which represents a subset
  // of the actual document).
  var _doc;
  if (editorExperiment('comment_on_bodied_extensions', true) && rootRendererContextValue) {
    // If rootRendererContextValue is set -- we are inside a nested renderer
    // and should always use the doc from the root renderer
    _doc = rootRendererContextValue.doc;
  } else {
    // If rootRendererContextValue is not set -- we are in the root renderer
    // and set the doc to the current doc.
    _doc = doc;
  }
  useLayoutEffect(function () {
    if (_doc) {
      actions._privateRegisterRenderer(rendererRef, _doc, schema, onAnalyticsEvent);
    } else {
      actions._privateUnregisterRenderer();
    }
    return function () {
      return actions._privateUnregisterRenderer();
    };
  }, [actions, schema, _doc, onAnalyticsEvent]);
  if (editorExperiment('comment_on_bodied_extensions', true)) {
    return jsx(RootRendererContext.Provider, {
      value: {
        doc: _doc
      }
    }, children);
  }
  return children;
}

// Usage notes:
// Used by Confluence for nested renderers
// For the View page renderer - see RendererWithAnalytics
var RendererWithAnnotationSelection = function RendererWithAnnotationSelection(props) {
  var allowAnnotations = props.allowAnnotations,
    adfDocument = props.document;
  var localRef = React.useRef(null);
  var innerRef = props.innerRef || localRef;
  if (!allowAnnotations) {
    // Ignored via go/ees005
    // eslint-disable-next-line react/jsx-props-no-spreading
    return jsx(RendererWithAnalytics, _extends({
      innerRef: innerRef
    }, props));
  }
  return jsx(RendererActionsContext, null, jsx(AnnotationsWrapper, {
    rendererRef: innerRef,
    adfDocument: adfDocument,
    annotationProvider: props.annotationProvider,
    isNestedRender: true
  }, jsx(RendererWithAnalytics, _extends({
    innerRef: innerRef
    // Ignored via go/ees005
    // eslint-disable-next-line react/jsx-props-no-spreading
  }, props, {
    featureFlags: props.featureFlags
  }))));
};

// eslint-disable-next-line @repo/internal/deprecations/deprecation-ticket-required -- Ignored via go/ED-25883
/* @deprecated using this version of the renderer causes the RendererActions to inaccessible from any consumers */
export default RendererWithAnnotationSelection;