import _extends from "@babel/runtime/helpers/extends";
import _objectWithoutProperties from "@babel/runtime/helpers/objectWithoutProperties";
import _toConsumableArray from "@babel/runtime/helpers/toConsumableArray";
import _classCallCheck from "@babel/runtime/helpers/classCallCheck";
import _createClass from "@babel/runtime/helpers/createClass";
import _defineProperty from "@babel/runtime/helpers/defineProperty";
var _excluded = ["key"];
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
import React from 'react';
import { MarkType } from '@atlaskit/editor-prosemirror/model';
import { editorExperiment } from '@atlaskit/tmp-editor-statsig/experiments';
import { isNestedHeaderLinksEnabled } from './utils/links';
import { Doc, DocWithSelectAllTrap, mergeTextNodes, isTextWrapper, isTextNode, toReact } from './nodes';
import TextWrapperComponent from './nodes/text-wrapper';
import { toReact as markToReact, isAnnotationMark } from './marks';
import { getMarksByOrder, isSameMark } from '@atlaskit/editor-common/validator';
import { calcTableColumnWidths, getColumnWidths } from '@atlaskit/editor-common/utils';
import { getText } from '../utils';
import { findChildrenByType } from '@atlaskit/editor-prosemirror/utils';
import { fg } from '@atlaskit/platform-feature-flags';
import { insideBlockNode, insideBreakoutLayout, insideMultiBodiedExtension, insideTable } from './renderer-node';
import { isCodeMark } from './marks/code';
import { segmentText } from './utils/segment-text';
import { renderTextSegments } from './utils/render-text-segments';
function mergeMarks(marksAndNodes) {
  return marksAndNodes.reduce(function (acc, markOrNode) {
    var prev = acc.length && acc[acc.length - 1] || null;
    if (markOrNode.type instanceof MarkType && prev && prev.type instanceof MarkType && Array.isArray(prev.content) && isSameMark(prev, markOrNode)) {
      prev.content = mergeMarks(prev.content.concat(markOrNode.content));
    } else {
      acc.push(markOrNode);
    }
    return acc;
  }, []);
}
var ReactSerializer = /*#__PURE__*/function () {
  function ReactSerializer(init) {
    var _this = this;
    _classCallCheck(this, ReactSerializer);
    _defineProperty(this, "headingIds", []);
    /**
     * The reason we have this extra array here is because we need to generate the same unique
     * heading id for 2 different nodes: headers and expands (check the implementation of
     * `getUniqueHeadingId` for more info).
     *
     * We will eventually need to refactor the current approach to generate unique ids
     * for headers under this ticket -> https://product-fabric.atlassian.net/browse/ED-9668
     */
    _defineProperty(this, "expandHeadingIds", []);
    _defineProperty(this, "allowCopyToClipboard", false);
    _defineProperty(this, "allowWrapCodeBlock", false);
    _defineProperty(this, "allowPlaceholderText", true);
    _defineProperty(this, "allowCustomPanels", false);
    _defineProperty(this, "surroundTextNodesWithTextWrapper", false);
    _defineProperty(this, "allowAnnotations", false);
    _defineProperty(this, "serializeFragmentChild", function (node, _ref) {
      var index = _ref.index,
        parentInfo = _ref.parentInfo;
      var pos = _this.startPos;
      var currentPath = parentInfo && parentInfo.path || [];
      var parentIsIncompleteTask = node.type.name === 'taskItem' && node.attrs.state !== 'DONE';
      var nodeKey = "".concat(node.type.name, "__").concat(_this.startPos);
      var serializedContent = _this.serializeFragment(node.content, _this.getNodeProps(node, parentInfo), toReact(node, {
        allowSelectAllTrap: _this.allowSelectAllTrap,
        allowWindowedCodeBlock: _this.allowWindowedCodeBlock
      }, _this.nodeComponents), nodeKey, {
        parentIsIncompleteTask: parentIsIncompleteTask,
        path: [].concat(_toConsumableArray(currentPath), [node]),
        pos: _this.startPos
      });
      _this.startPos = pos + node.nodeSize;
      var marks = node.marks ? _toConsumableArray(node.marks) : [];
      var isMedia = node.type.name === 'media';
      var shouldSkipBorderMark = function shouldSkipBorderMark(mark) {
        return currentPath.some(function (n) {
          var _n$type;
          return ((_n$type = n.type) === null || _n$type === void 0 ? void 0 : _n$type.name) !== 'mediaSingle';
        }) && isMedia && mark.type.name === 'border';
      };
      var shouldSkipLinkMark = function shouldSkipLinkMark(mark) {
        return _this.allowMediaLinking !== true && isMedia && mark.type.name === 'link';
      };
      return marks.reduceRight(function (content, mark) {
        if (shouldSkipLinkMark(mark) || shouldSkipBorderMark(mark)) {
          return content;
        }
        return _this.renderMark(markToReact(mark), _this.withMediaMarkProps(node, mark, _this.getMarkProps(mark, [], node)), "".concat(mark.type.name, "-").concat(index), content);
      }, serializedContent);
    });
    // Ignored via go/ees005
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    // Ignored via go/ees005
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    _defineProperty(this, "withMediaMarkProps", function (node, mark, defaultProps) {
      if (mark.type.name === 'link' && node.type.name === 'media') {
        return _objectSpread(_objectSpread({}, defaultProps), {}, {
          isMediaLink: true
        });
      }
      if (node.type.name === 'mediaInline' && mark.type.name === 'annotation') {
        return _objectSpread(_objectSpread({}, defaultProps), {}, {
          isMediaInline: true
        });
      }
      return defaultProps;
    });
    _defineProperty(this, "getUnsupportedContentProps", function (node) {
      return {
        node: node,
        dispatchAnalyticsEvent: _this.fireAnalyticsEvent
      };
    });
    _defineProperty(this, "getAnnotationMarkProps", function (mark, marksParentPath) {
      var annotationParentIds = (marksParentPath || []).reduce(function (acc, parent) {
        if (isAnnotationMark(parent)) {
          return [].concat(_toConsumableArray(acc), [parent.attrs.id]);
        }
        return acc;
      }, []);
      return {
        id: mark.attrs.id,
        annotationType: mark.attrs.annotationType,
        annotationParentIds: annotationParentIds,
        allowAnnotations: _this.allowAnnotations,
        dataAttributes: {
          'data-renderer-mark': true
        }
      };
    });
    _defineProperty(this, "getMarkProps", function (mark, marksParentPath, node) {
      if (isAnnotationMark(mark)) {
        return _this.getAnnotationMarkProps(mark, marksParentPath);
      }
      var _mark$attrs = mark.attrs,
        key = _mark$attrs.key,
        otherAttrs = _objectWithoutProperties(_mark$attrs, _excluded);
      var extraProps = {
        isInline: node === null || node === void 0 ? void 0 : node.isInline
      };

      // currently the only mark which has custom props is the code mark
      var markSpecificProps = isCodeMark(mark) ? {
        // The appearance being mobile indicates we are in an renderer being
        // rendered by mobile bridge in a web view.
        // The tooltip is likely to have unexpected behaviour there, with being cut
        // off, so we disable it. This is also to keep the behaviour consistent with
        // the rendering in the mobile Native Renderer.
        codeBidiWarningTooltipEnabled: false
      } : {};
      var props = _objectSpread(_objectSpread(_objectSpread(_objectSpread({
        eventHandlers: _this.eventHandlers,
        fireAnalyticsEvent: _this.fireAnalyticsEvent,
        markKey: key
      }, otherAttrs), extraProps), markSpecificProps), {}, {
        dataAttributes: {
          'data-renderer-mark': true
        }
      });
      return props;
    });
    if (editorExperiment('comment_on_bodied_extensions', true)) {
      this.initStartPos = init.startPos || 1;
      this.startPos = init.startPos || 1;
    } else {
      this.initStartPos = 1;
      this.startPos = 1;
    }
    this.providers = init.providers;
    this.eventHandlers = init.eventHandlers;
    this.extensionHandlers = init.extensionHandlers;
    this.portal = init.portal;
    this.rendererContext = init.objectContext;
    this.appearance = init.appearance;
    this.disableHeadingIDs = init.disableHeadingIDs;
    this.disableActions = init.disableActions;
    this.allowHeadingAnchorLinks = init.allowHeadingAnchorLinks;
    this.allowCopyToClipboard = init.allowCopyToClipboard;
    this.allowWrapCodeBlock = init.allowWrapCodeBlock;
    this.allowPlaceholderText = init.allowPlaceholderText;
    this.allowCustomPanels = init.allowCustomPanels;
    this.allowColumnSorting = init.allowColumnSorting;
    this.fireAnalyticsEvent = init.fireAnalyticsEvent;
    this.shouldOpenMediaViewer = init.shouldOpenMediaViewer;
    this.allowAltTextOnImages = init.allowAltTextOnImages;
    this.stickyHeaders = init.stickyHeaders;
    this.allowMediaLinking = init.allowMediaLinking;
    this.allowAnnotations = Boolean(init.allowAnnotations);
    this.surroundTextNodesWithTextWrapper = Boolean(init.surroundTextNodesWithTextWrapper);
    this.media = init.media;
    this.emojiResourceConfig = init.emojiResourceConfig;
    this.smartLinks = init.smartLinks;
    this.allowSelectAllTrap = init.allowSelectAllTrap;
    this.nodeComponents = init.nodeComponents;
    this.allowWindowedCodeBlock = init.allowWindowedCodeBlock;
    this.isInsideOfInlineExtension = init.isInsideOfInlineExtension;
    this.textHighlighter = init.textHighlighter;
    this.allowTableAlignment = init.allowTableAlignment;
    this.allowTableResizing = init.allowTableResizing;
  }
  return _createClass(ReactSerializer, [{
    key: "resetState",
    value: function resetState() {
      this.headingIds = [];
      this.expandHeadingIds = [];
      this.startPos = this.initStartPos;
    }
  }, {
    key: "getNodeProps",
    value: function getNodeProps(node, parentInfo) {
      var path = parentInfo ? parentInfo.path : undefined;
      switch (node.type.name) {
        case 'date':
          return this.getDateProps(node, parentInfo, path);
        case 'hardBreak':
          return this.getHardBreakProps(node, path);
        case 'heading':
          return this.getHeadingProps(node, path);
        case 'media':
          return this.getMediaProps(node, path);
        case 'emoji':
          return this.getEmojiProps(node);
        case 'mediaGroup':
          return this.getMediaGroupProps(node);
        case 'mediaInline':
          return this.getMediaInlineProps(node);
        case 'mediaSingle':
          return this.getMediaSingleProps(node, path);
        case 'table':
          return this.getTableProps(node, path);
        case 'tableHeader':
        case 'tableRow':
          return this.getTableChildrenProps(node);
        case 'taskItem':
          return this.getTaskItemProps(node, path);
        case 'embedCard':
          return this.getEmbedCardProps(node, path);
        case 'blockCard':
          return this.getBlockCardProps(node, path);
        case 'expand':
          return this.getExpandProps(node, path);
        case 'unsupportedBlock':
        case 'unsupportedInline':
          return this.getUnsupportedContentProps(node);
        case 'codeBlock':
          return this.getCodeBlockProps(node);
        case 'panel':
          return this.getPanelProps(node);
        default:
          return this.getProps(node, path);
      }
    }
  }, {
    key: "serializeFragment",
    value: function serializeFragment(fragment) {
      var _this2 = this;
      var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var target = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.allowSelectAllTrap ? DocWithSelectAllTrap : Doc;
      var key = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'root-0';
      var parentInfo = arguments.length > 4 ? arguments[4] : undefined;
      // This makes sure that we reset internal state on re-render.
      if (key === 'root-0') {
        this.resetState();
      }
      return this.renderNode(target, props, key, ReactSerializer.getChildNodes(fragment).map(function (node, index) {
        if (isTextWrapper(node)) {
          return _this2.serializeTextWrapper(node.content, {
            index: index,
            parentInfo: parentInfo
          });
        }
        return _this2.serializeFragmentChild(node, {
          index: index,
          parentInfo: parentInfo
        });
      }));
    }
  }, {
    key: "serializeTextWrapper",
    value: function serializeTextWrapper(content, _ref2) {
      var _this3 = this;
      var index = _ref2.index,
        parentInfo = _ref2.parentInfo;
      var currentPath = parentInfo && parentInfo.path || [];
      var nodePosition = parentInfo && parentInfo.pos || 1;
      return ReactSerializer.buildMarkStructure(content).map(function (mark, index) {
        return _this3.serializeMark({
          mark: mark,
          parentNode: {
            path: currentPath,
            pos: nodePosition
          },
          parentMark: {
            path: [mark]
          }
        });
      });
    }
  }, {
    key: "serializeMark",
    value: function serializeMark(_ref3) {
      var _this4 = this;
      var mark = _ref3.mark,
        parentNode = _ref3.parentNode,
        parentMark = _ref3.parentMark;
      if (!isTextNode(mark)) {
        var serializeContent = function serializeContent(childMark, index) {
          return _this4.serializeMark({
            mark: childMark,
            parentNode: parentNode,
            parentMark: {
              path: [].concat(_toConsumableArray(parentMark.path), [childMark])
            }
          });
        };

        // Ignored via go/ees005
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        var content = (mark.content || []).map(serializeContent);
        var markKey = "".concat(mark.type.name, "-component__").concat(this.startPos, "__").concat(parentMark.path.length);
        return this.renderMark(markToReact(mark), this.getMarkProps(mark, parentMark.path), markKey, content);
      }
      var startPos = this.startPos;
      var endPos = startPos + mark.nodeSize;
      this.startPos = endPos;
      var textKey = "text-wrapper_".concat(this.startPos);
      if (this.surroundTextNodesWithTextWrapper) {
        var parentDepth = Math.max(parentNode.path.length - 1, 0);
        return /*#__PURE__*/React.createElement(TextWrapperComponent, {
          key: textKey,
          startPos: startPos + parentDepth,
          endPos: endPos + parentDepth,
          textHighlighter: this.textHighlighter,
          marks: mark.marks
        }, mark.text);
      }
      var segments = segmentText(mark.text, this.textHighlighter);
      return renderTextSegments(segments, this.textHighlighter, mark.marks, startPos);
    }
  }, {
    key: "renderNode",
    value: function renderNode(
    // Ignored via go/ees005
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    NodeComponent,
    // Ignored via go/ees005
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    props, key,
    // Ignored via go/ees005
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    content) {
      return (
        /*#__PURE__*/
        // Ignored via go/ees005
        // eslint-disable-next-line react/jsx-props-no-spreading
        React.createElement(NodeComponent, _extends({
          key: key
        }, props), content)
      );
    }
  }, {
    key: "renderMark",
    value: function renderMark(
    // Ignored via go/ees005
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    MarkComponent, props, key,
    // Ignored via go/ees005
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    content) {
      return (
        /*#__PURE__*/
        // Ignored via go/ees005
        // eslint-disable-next-line react/jsx-props-no-spreading
        React.createElement(MarkComponent, _extends({
          key: key
        }, props), content)
      );
    }
  }, {
    key: "getTableChildrenProps",
    value: function getTableChildrenProps(node) {
      return _objectSpread(_objectSpread({}, this.getProps(node)), {}, {
        allowColumnSorting: this.allowColumnSorting
      });
    }
  }, {
    key: "getTableProps",
    value: function getTableProps(node) {
      var path = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
      var isInsideOfBlockNode = insideBlockNode(path, node.type.schema);
      var isInsideMultiBodiedExtension = insideMultiBodiedExtension(path, node.type.schema);
      var isInsideOfTable = insideTable(path, node.type.schema);

      // TODO: https://product-fabric.atlassian.net/browse/CEMS-1048
      var stickyHeaders = !isInsideOfTable && !insideBreakoutLayout(path) ? this.stickyHeaders : undefined;
      return _objectSpread(_objectSpread({}, this.getProps(node)), {}, {
        allowColumnSorting: this.allowColumnSorting,
        columnWidths:
        // When allowTableResizing is enabled, the number of columns is required to render
        // the same scaling logic as editor. Some tables can have unequal rows, so the entire
        // table needs to be scanned.
        this.allowTableResizing && fg('platform_editor_table_col_calculation_fix') ? getColumnWidths(node) : calcTableColumnWidths(node),
        tableNode: node,
        stickyHeaders: stickyHeaders,
        isInsideOfBlockNode: isInsideOfBlockNode,
        isInsideOfTable: isInsideOfTable,
        isInsideMultiBodiedExtension: isInsideMultiBodiedExtension,
        allowTableAlignment: this.allowTableAlignment,
        allowTableResizing: this.allowTableResizing
      });
    }
  }, {
    key: "getDateProps",
    value: function getDateProps(node, parentInfo) {
      var path = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
      return {
        timestamp: node.attrs && node.attrs.timestamp,
        parentIsIncompleteTask: parentInfo && parentInfo.parentIsIncompleteTask,
        dataAttributes: {
          // We need to account for depth (path.length gives up depth) here
          // but depth doesnt increment the pos, only accounted for.
          'data-renderer-start-pos': this.startPos + path.length
        }
      };
    }
  }, {
    key: "getMediaSingleProps",
    value: function getMediaSingleProps(node) {
      var _this5 = this;
      var path = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
      var link = node.type.schema.marks.link;
      var isInsideOfBlockNode = insideBlockNode(path, node.type.schema);
      var isLinkMark = function isLinkMark(mark) {
        return mark.type === link;
      };
      var childHasLink = node.firstChild && node.firstChild.marks.filter(function (m) {
        return isLinkMark(m) || _this5.allowMediaLinking === true;
      }).length;
      return _objectSpread(_objectSpread({}, this.getProps(node, path)), {}, {
        isInsideOfBlockNode: isInsideOfBlockNode,
        childHasLink: childHasLink,
        allowCaptions: this.media && this.media.allowCaptions,
        featureFlags: this.media && this.media.featureFlags
      });
    }
  }, {
    key: "getMediaProps",
    value: function getMediaProps(node) {
      var _this6 = this,
        _this$media;
      var path = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
      var _node$type$schema$mar = node.type.schema.marks,
        annotation = _node$type$schema$mar.annotation,
        link = _node$type$schema$mar.link,
        border = _node$type$schema$mar.border;
      var isChildOfMediaSingle = path.some(function (n) {
        var _n$type2;
        return ((_n$type2 = n.type) === null || _n$type2 === void 0 ? void 0 : _n$type2.name) === 'mediaSingle';
      });
      var isAnnotationMark = function isAnnotationMark(mark) {
        return mark.type === annotation;
      };
      var isLinkMark = function isLinkMark(mark) {
        return mark.type === link;
      };
      var isBorderMark = function isBorderMark(mark) {
        return isChildOfMediaSingle && mark.type === border;
      };
      return _objectSpread(_objectSpread({}, this.getProps(node, path)), {}, {
        marks: node.marks.filter(function (m) {
          return !isLinkMark(m) || _this6.allowMediaLinking === true;
        }),
        isLinkMark: isLinkMark,
        isBorderMark: isBorderMark,
        isAnnotationMark: isAnnotationMark,
        allowAltTextOnImages: this.allowAltTextOnImages,
        featureFlags: this.media && this.media.featureFlags,
        shouldOpenMediaViewer: this.shouldOpenMediaViewer,
        ssr: (_this$media = this.media) === null || _this$media === void 0 ? void 0 : _this$media.ssr,
        // surroundTextNodesWithTextWrapper checks inlineComment.allowDraftMode
        allowAnnotationsDraftMode: this.surroundTextNodesWithTextWrapper
      });
    }
  }, {
    key: "getEmojiProps",
    value: function getEmojiProps(node) {
      return _objectSpread(_objectSpread({}, this.getProps(node)), {}, {
        resourceConfig: this.emojiResourceConfig
      });
    }
  }, {
    key: "getEmbedCardProps",
    value: function getEmbedCardProps(node) {
      var path = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
      var isInsideOfBlockNode = insideBlockNode(path, node.type.schema);
      return _objectSpread(_objectSpread({}, this.getProps(node)), {}, {
        isInsideOfBlockNode: isInsideOfBlockNode
      });
    }
  }, {
    key: "getBlockCardProps",
    value: function getBlockCardProps(node) {
      var path = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
      return _objectSpread(_objectSpread({}, this.getProps(node)), {}, {
        isNodeNested: path.length > 0
      });
    }
  }, {
    key: "getMediaGroupProps",
    value: function getMediaGroupProps(node) {
      var _this$media2, _this$media3;
      return _objectSpread(_objectSpread({}, this.getProps(node)), {}, {
        shouldOpenMediaViewer: this.shouldOpenMediaViewer,
        allowAltTextOnImages: this.allowAltTextOnImages,
        featureFlags: this.media && this.media.featureFlags,
        enableDownloadButton: (_this$media2 = this.media) === null || _this$media2 === void 0 ? void 0 : _this$media2.enableDownloadButton,
        ssr: (_this$media3 = this.media) === null || _this$media3 === void 0 ? void 0 : _this$media3.ssr
      });
    }
  }, {
    key: "getMediaInlineProps",
    value: function getMediaInlineProps(node) {
      var _this$media4;
      return _objectSpread(_objectSpread({}, this.getProps(node)), {}, {
        ssr: (_this$media4 = this.media) === null || _this$media4 === void 0 ? void 0 : _this$media4.ssr
      });
    }
  }, {
    key: "getTaskItemProps",
    value: function getTaskItemProps(node) {
      var path = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
      return _objectSpread(_objectSpread({}, this.getProps(node, path)), {}, {
        disabled: this.disableActions
      });
    }
  }, {
    key: "getHardBreakProps",
    value: function getHardBreakProps(node) {
      var path = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
      var forceNewLine = false;
      var parentNode = path.length > 0 ? path[path.length - 1] : null;
      if (parentNode && parentNode.lastChild === node) {
        forceNewLine = true;
      }
      return _objectSpread(_objectSpread({}, this.getProps(node)), {}, {
        forceNewLine: forceNewLine
      });
    }
  }, {
    key: "getCodeBlockProps",
    value: function getCodeBlockProps(node) {
      // The appearance being mobile indicates we are in an renderer being
      // rendered by mobile bridge in a web view.
      // The tooltip is likely to have unexpected behaviour there, with being cut
      // off, so we disable it. This is also to keep the behaviour consistent with
      // the rendering in the mobile Native Renderer.
      var codeBidiWarningTooltipEnabled = false;
      return _objectSpread(_objectSpread({}, this.getProps(node)), {}, {
        text: node.textContent,
        codeBidiWarningTooltipEnabled: codeBidiWarningTooltipEnabled
      });
    }
  }, {
    key: "getPanelProps",
    value: function getPanelProps(node) {
      return _objectSpread(_objectSpread({}, this.getProps(node)), {}, {
        allowCustomPanels: this.allowCustomPanels
      });
    }
  }, {
    key: "getProps",
    value: function getProps(node) {
      var path = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
      var startPos = this.startPos + path.length;
      return _objectSpread({
        text: node.text,
        providers: this.providers,
        eventHandlers: this.eventHandlers,
        extensionHandlers: this.extensionHandlers,
        portal: this.portal,
        rendererContext: this.rendererContext,
        serializer: this,
        content: node.content ? node.content.toJSON() : undefined,
        allowHeadingAnchorLinks: this.allowHeadingAnchorLinks,
        allowCopyToClipboard: this.allowCopyToClipboard,
        allowWrapCodeBlock: this.allowWrapCodeBlock,
        allowPlaceholderText: this.allowPlaceholderText,
        rendererAppearance: this.appearance,
        fireAnalyticsEvent: this.fireAnalyticsEvent,
        nodeType: node.type.name,
        marks: node.marks,
        smartLinks: this.smartLinks,
        isInsideOfInlineExtension: this.isInsideOfInlineExtension,
        dataAttributes: {
          // We need to account for depth (path.length gives up depth) here
          // but depth doesnt increment the pos, only accounted for.
          'data-renderer-start-pos': startPos
        },
        startPos: startPos,
        path: path
      }, node.attrs);
    }
  }, {
    key: "headingAnchorSupported",
    value: function headingAnchorSupported() {
      var path = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      var isImmediateParent = function isImmediateParent(path, nodeName) {
        return path.length > 0 && path[path.length - 1].type.name === nodeName;
      };
      return isNestedHeaderLinksEnabled(this.allowHeadingAnchorLinks) || path.length === 0 || isImmediateParent(path, 'layoutColumn');
    }
  }, {
    key: "getHeadingProps",
    value: function getHeadingProps(node) {
      var path = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
      return _objectSpread(_objectSpread({}, this.getProps(node, path)), {}, {
        content: node.content ? node.content.toJSON() : undefined,
        headingId: this.getHeadingId(node, this.headingIds),
        showAnchorLink: this.appearance !== 'comment' && this.allowHeadingAnchorLinks && !this.disableHeadingIDs && this.headingAnchorSupported(path)
      });
    }
  }, {
    key: "getExpandProps",
    value: function getExpandProps(node) {
      var _this7 = this;
      var path = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
      if (!isNestedHeaderLinksEnabled(this.allowHeadingAnchorLinks)) {
        return this.getProps(node);
      }
      var nestedHeaderIds = findChildrenByType(node, node.type.schema.nodes.heading).map(function (_ref4) {
        var node = _ref4.node;
        return _this7.getHeadingId(node, _this7.expandHeadingIds);
      });
      return _objectSpread(_objectSpread({}, this.getProps(node)), {}, {
        nestedHeaderIds: nestedHeaderIds
      });
    }

    // The return value of this function is NOT url encoded,
    // In HTML5 standard, id can contain any characters, encoding is no necessary.
    // Plus we trying to avoid double encoding, therefore we leave the value as is.
    // Remember to use encodeURIComponent when generating url from the id value.
  }, {
    key: "getHeadingId",
    value: function getHeadingId(node, headingIds) {
      if (this.disableHeadingIDs || !node.content.size) {
        return;
      }

      // We are not use node.textContent here, because we would like to handle cases where
      // headings only contain inline blocks like emoji, status and date.
      // Ignored via go/ees005
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      var nodeContent = node.content.toJSON()
      // Ignored via go/ees005
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      .reduce(function (acc, node) {
        return acc.concat(getText(node) || '');
      }, '').trim()
      // Ignored via go/ees005
      // eslint-disable-next-line require-unicode-regexp
      .replace(/\s/g, '-');
      if (!nodeContent) {
        return;
      }
      return this.getUniqueHeadingId(nodeContent, headingIds);
    }
  }, {
    key: "getUniqueHeadingId",
    value: function getUniqueHeadingId(baseId, headingIds) {
      var counter = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      if (counter === 0 && headingIds.indexOf(baseId) === -1) {
        headingIds.push(baseId);
        return baseId;
      } else if (counter !== 0) {
        var headingId = "".concat(baseId, ".").concat(counter);
        if (headingIds.indexOf(headingId) === -1) {
          headingIds.push(headingId);
          return headingId;
        }
      }
      return this.getUniqueHeadingId(baseId, headingIds, ++counter);
    }
  }], [{
    key: "getChildNodes",
    value: function getChildNodes(fragment) {
      var children = [];
      fragment.forEach(function (node) {
        children.push(node);
      });
      return mergeTextNodes(children);
    }
  }, {
    key: "getMarks",
    value: function getMarks(node) {
      if (!node.marks || node.marks.length === 0) {
        return [];
      }
      return getMarksByOrder(node.marks);
    }
  }, {
    key: "buildMarkStructure",
    value: function buildMarkStructure(content) {
      var _this8 = this;
      return mergeMarks(content.map(function (node) {
        var nodeMarks = _this8.getMarks(node);
        if (nodeMarks.length === 0) {
          return node;
        }
        return nodeMarks.reverse().reduce(function (acc, mark) {
          var eq = mark.eq;
          return _objectSpread(_objectSpread({}, mark), {}, {
            eq: eq,
            content: [acc]
          });
          // Ignored via go/ees005
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
        }, node);
      }));
    }

    // TODO: ED-9004 Remove unused ReactSerializer.fromSchema in renderer
    // https://sourcegraph-frontend.internal.shared-prod.us-west-2.kitt-inf.net/search?q=ReactSerializer.fromSchema&patternType=literal
  }, {
    key: "fromSchema",
    value: function fromSchema(_, init) {
      if (process.env.NODE_ENV !== 'production') {
        // eslint-disable-next-line no-console
        console.warn('ReactSerializer.fromSchema is deprecated. Please use the constructor instead via new ReactSerializer()');
      }
      return new ReactSerializer(init);
    }
  }]);
}();
export { ReactSerializer as default };