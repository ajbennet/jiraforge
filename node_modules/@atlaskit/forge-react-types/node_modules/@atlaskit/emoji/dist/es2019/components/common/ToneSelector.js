/**
 * @jsxRuntime classic
 * @jsx jsx
 */
// eslint-disable-next-line @atlaskit/ui-styling-standard/use-compiled -- Ignored via go/DSP-18766
import { jsx } from '@emotion/react';
import { memo, useEffect, useMemo, useRef } from 'react';
import { withAnalyticsEvents } from '@atlaskit/analytics-next';
import { createAndFireEventInElementsChannel, toneSelectedEvent, toneSelectorOpenedEvent } from '../../util/analytics';
import { setSkinToneAriaLabelText } from './setSkinToneAriaLabelText';
import EmojiRadioButton from './EmojiRadioButton';
import { useIntl } from 'react-intl-next';
import { messages } from '../i18n';
import { hidden } from './styles';
export const toneSelectorTestId = 'tone-selector';
const extractAllTones = emoji => {
  if (emoji.skinVariations) {
    return [emoji, ...emoji.skinVariations];
  }
  return [emoji];
};
export const ToneSelectorInternal = props => {
  const {
    createAnalyticsEvent,
    emoji,
    onToneSelected,
    onToneClose,
    selectedTone,
    isVisible
  } = props;
  const isMounted = useRef(false);
  const selectedToneRadioRef = useRef(null);
  const {
    formatMessage
  } = useIntl();
  const emojiToneCollection = useMemo(() => {
    var selectedToneIndex = -1;
    const toneColletion = extractAllTones(emoji).map((tone, index) => {
      const isSelected = index === selectedTone;
      if (isSelected) {
        selectedToneIndex = index;
      }
      return {
        ...tone,
        isSelected: isSelected,
        label: setSkinToneAriaLabelText(tone.name),
        toneIndex: index
      };
    });

    // push description of selected tone to the end of the array
    // so that it gets rendered last/rightmost
    toneColletion.push(toneColletion.splice(selectedToneIndex, 1)[0]);
    return toneColletion;
  }, [emoji, selectedTone]);
  useEffect(() => {
    if (isVisible) {
      var _selectedToneRadioRef;
      (_selectedToneRadioRef = selectedToneRadioRef.current) === null || _selectedToneRadioRef === void 0 ? void 0 : _selectedToneRadioRef.focus();
    }
  }, [isVisible, selectedToneRadioRef]);
  const fireAnalyticsEvent = event => {
    if (createAnalyticsEvent) {
      createAndFireEventInElementsChannel(event)(createAnalyticsEvent);
    }
  };
  const onToneSelectedHandler = toneValue => () => {
    if (selectedTone === toneValue && onToneClose) {
      onToneClose();
      return;
    }
    onToneSelected(toneValue);
    const toneList = ['default', 'light', 'mediumLight', 'medium', 'mediumDark', 'dark'];
    fireAnalyticsEvent(toneSelectedEvent({
      skinToneModifier: toneList[toneValue]
    }));
  };
  if (!isMounted.current) {
    fireAnalyticsEvent(toneSelectorOpenedEvent({}));
  }
  isMounted.current = true;
  return jsx("div", {
    role: "radiogroup",
    "data-testid": toneSelectorTestId,
    id: "emoji-picker-tone-selector",
    "aria-label": formatMessage(messages.emojiSelectSkinToneListAriaLabelText)
    // eslint-disable-next-line @atlaskit/design-system/consistent-css-prop-usage, @atlaskit/ui-styling-standard/no-imported-style-values -- Ignored via go/DSP-18766
    ,
    css: !isVisible && hidden
  }, emojiToneCollection.map(tone => {
    return jsx(EmojiRadioButton, {
      ref: tone.isSelected ? selectedToneRadioRef : null,
      defaultChecked: tone.isSelected,
      ariaLabelText: tone.label,
      key: `${tone.id}`,
      emoji: tone,
      onSelected: onToneSelectedHandler(tone.toneIndex),
      selectOnHover: true
    });
  }));
};
const ToneSelector = withAnalyticsEvents()(ToneSelectorInternal);
export default /*#__PURE__*/memo(ToneSelector);