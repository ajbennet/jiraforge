/**
 * @jsxRuntime classic
 * @jsx jsx
 */
import React, { useCallback, useEffect, useRef, useState } from 'react';
// eslint-disable-next-line @atlaskit/ui-styling-standard/use-compiled -- Ignored via go/DSP-18766
import { jsx } from '@emotion/react';
import { useIntl } from 'react-intl-next';
import { Pressable, xcss } from '@atlaskit/primitives';
import Tooltip from '@atlaskit/tooltip';
import { CATEGORYSELECTOR_KEYBOARD_KEYS_SUPPORTED, defaultCategories, KeyboardKeys } from '../../util/constants';
import { messages } from '../i18n';
import { CategoryDescriptionMap } from './categories';
import { categorySelector, categorySelectorTablist } from './styles';
import { usePrevious } from '../../hooks/usePrevious';
import { RENDER_EMOJI_PICKER_LIST_TESTID } from './EmojiPickerList';
export const sortCategories = (c1, c2) => CategoryDescriptionMap[c1].order - CategoryDescriptionMap[c2].order;
const addNewCategories = (oldCategories, newCategories) => {
  if (!newCategories) {
    return oldCategories;
  }
  return oldCategories.concat(newCategories.filter(category => !!CategoryDescriptionMap[category])).sort(sortCategories);
};
const commonCategoryStyles = xcss({
  backgroundColor: 'color.background.neutral.subtle',
  border: 0,
  borderRadius: 'border.radius',
  padding: 'space.0',
  transition: 'color 0.2s ease'
});
const defaultCategoryStyles = xcss({
  color: 'color.text.subtlest',
  ':hover': {
    color: 'color.text.selected'
  }
});
const activeCategoryStyles = xcss({
  color: 'color.text.selected',
  ':hover': {
    color: 'color.text.selected'
  }
});
const disabledCategoryStyles = xcss({
  color: 'color.text.subtlest'
});
export const categorySelectorComponentTestId = 'category-selector-component';
export const categorySelectorCategoryTestId = categoryId => `category-selector-${categoryId}`;
const CategorySelector = props => {
  const {
    disableCategories,
    dynamicCategories,
    activeCategoryId,
    onCategorySelected
  } = props;
  const [categories, setCategories] = useState(addNewCategories(defaultCategories, dynamicCategories));
  const [currentFocus, setCurrentFocus] = useState(0);
  const categoryRef = useRef(null);
  const prevDynamicCategories = usePrevious(dynamicCategories);
  const {
    formatMessage
  } = useIntl();
  const updateCategories = useCallback(() => {
    const newCategories = addNewCategories(defaultCategories, dynamicCategories);
    setCategories(newCategories);
  }, [dynamicCategories]);
  useEffect(() => {
    if (prevDynamicCategories !== dynamicCategories) {
      updateCategories();
    }
  }, [prevDynamicCategories, dynamicCategories, updateCategories]);
  const focusCategory = useCallback(index => {
    var _categoryRef$current;
    const categoryToFocus = (_categoryRef$current = categoryRef.current) === null || _categoryRef$current === void 0 ? void 0 : _categoryRef$current.querySelector(`[data-focus-index="${index}"]`);
    categoryToFocus && categoryToFocus.focus();
    setCurrentFocus(index);
  }, [categoryRef, setCurrentFocus]);
  const handleKeyDown = e => {
    if (!CATEGORYSELECTOR_KEYBOARD_KEYS_SUPPORTED.includes(e.key)) {
      return;
    }
    e.preventDefault();
    e.stopPropagation();
    const lastCategoryIndex = categories.length - 1;
    switch (e.key) {
      // navigate to the right category
      case KeyboardKeys.ArrowRight:
        focusCategory(currentFocus === lastCategoryIndex ? 0 : currentFocus + 1);
        break;
      // navigate to the left category
      case KeyboardKeys.ArrowLeft:
        focusCategory(currentFocus === 0 ? lastCategoryIndex : currentFocus - 1);
        break;
      // navigate to the first category
      case KeyboardKeys.Home:
        focusCategory(0);
        break;
      // navigate to the last category
      case KeyboardKeys.End:
        focusCategory(lastCategoryIndex);
        break;
    }
  };
  const handleClick = (categoryId, index) => event => {
    if (disableCategories) {
      event.preventDefault();
      return;
    }
    if (onCategorySelected) {
      onCategorySelected(categoryId);
    }
    setCurrentFocus(index);
  };
  let categoriesSection;
  if (categories) {
    categoriesSection = jsx("div", {
      role: "tablist",
      "aria-label": formatMessage(messages.categoriesSelectorLabel),
      "data-testid": categorySelectorComponentTestId,
      ref: categoryRef
      // eslint-disable-next-line @atlaskit/design-system/consistent-css-prop-usage, @atlaskit/ui-styling-standard/no-imported-style-values -- Ignored via go/DSP-18766
      ,
      css: categorySelectorTablist
    }, categories.map((categoryId, index) => {
      const category = CategoryDescriptionMap[categoryId];
      const Icon = category.icon;
      const categoryName = formatMessage(messages[category.name]);
      return jsx(Tooltip, {
        content: categoryName,
        position: "bottom",
        key: category.id
      }, jsx(Pressable, {
        id: `category-selector-${category.id}`,
        "data-focus-index": index,
        "aria-label": categoryName,
        "aria-controls": currentFocus === index ? RENDER_EMOJI_PICKER_LIST_TESTID : undefined,
        "aria-selected": categoryId === activeCategoryId,
        xcss: [commonCategoryStyles, defaultCategoryStyles, categoryId === activeCategoryId && activeCategoryStyles, disableCategories && disabledCategoryStyles],
        isDisabled: disableCategories,
        onClick: handleClick(categoryId, index),
        testId: categorySelectorCategoryTestId(categoryId),
        tabIndex: currentFocus === index ? 0 : -1,
        onKeyDown: handleKeyDown,
        role: "tab"
      }, jsx(Icon, {
        label: categoryName
      })));
    }));
  }
  // eslint-disable-next-line @atlaskit/design-system/consistent-css-prop-usage, @atlaskit/ui-styling-standard/no-imported-style-values -- Ignored via go/DSP-18766
  return jsx("div", {
    css: categorySelector
  }, categoriesSection);
};
export default CategorySelector;