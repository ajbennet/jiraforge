import _extends from "@babel/runtime/helpers/extends";
import _defineProperty from "@babel/runtime/helpers/defineProperty";
/**
 * @jsxRuntime classic
 * @jsx jsx
 */
import { Component } from 'react';
// eslint-disable-next-line @atlaskit/ui-styling-standard/use-compiled -- Ignored via go/DSP-18766
import { jsx } from '@emotion/react';
import { FormattedMessage, injectIntl } from 'react-intl-next';
import AkButton from '@atlaskit/button/new';
import Heading from '@atlaskit/heading';
import FocusLock from 'react-focus-lock';
import { messages } from '../i18n';
import CachingEmoji from './CachingEmoji';
import EmojiErrorMessage, { emojiErrorScreenreaderTestId } from './EmojiErrorMessage';
import RetryableButton from './RetryableButton';
import { deleteFooter, deletePreview, deleteText, emojiDeleteErrorMessage, previewButtonGroup } from './styles';
import VisuallyHidden from '@atlaskit/visually-hidden';
import { fg } from '@atlaskit/platform-feature-flags';
export const emojiDeletePreviewTestId = 'emoji-delete-preview';
const deleteEmojiLabelId = 'fabric.emoji.delete.label.id';
class EmojiDeletePreview extends Component {
  constructor(props) {
    super(props);
    _defineProperty(this, "onSubmit", () => {
      const {
        emoji,
        onDeleteEmoji,
        onCloseDelete
      } = this.props;
      if (!this.state.loading) {
        this.setState({
          loading: true
        });
        onDeleteEmoji(emoji).then(success => {
          if (success) {
            onCloseDelete();
            return;
          }
          this.setState({
            loading: false,
            error: true
          });
        });
      }
    });
    _defineProperty(this, "onCancel", () => {
      this.props.onCloseDelete();
    });
    this.state = {
      loading: false,
      error: false
    };
  }
  UNSAFE_componentWillUpdate(nextProps) {
    if (!fg('platform_editor_react18_elements_emoji')) {
      if (nextProps.emoji.id !== this.props.emoji.id) {
        this.setState({
          error: false
        });
      }
    }
  }
  componentDidUpdate(prevProps) {
    if (fg('platform_editor_react18_elements_emoji')) {
      if (prevProps.emoji.id !== this.props.emoji.id) {
        this.setState({
          error: false
        });
      }
    }
  }
  render() {
    const {
      emoji,
      intl
    } = this.props;
    const {
      loading,
      error
    } = this.state;
    const {
      formatMessage
    } = intl;
    return jsx(FocusLock, {
      noFocusGuards: true
    }, jsx("div", {
      css: deletePreview,
      "data-testid": emojiDeletePreviewTestId
    }, jsx("div", {
      css: deleteText
    }, jsx(Heading, {
      size: "xxsmall"
    }, jsx(FormattedMessage, messages.deleteEmojiTitle)), jsx(FormattedMessage, _extends({}, messages.deleteEmojiDescription, {
      values: {
        emojiShortName: emoji.shortName
      }
    }))), jsx("div", {
      css: deleteFooter
    }, jsx(CachingEmoji, {
      emoji: emoji
    }), jsx("div", {
      css: previewButtonGroup
    }, error ? !loading ? jsx(EmojiErrorMessage, {
      message: formatMessage(messages.deleteEmojiFailed),
      messageStyles: emojiDeleteErrorMessage,
      tooltip: true
    }) : null : null, jsx(VisuallyHidden, {
      id: deleteEmojiLabelId
    }, formatMessage(messages.deleteEmojiLabel)), jsx(RetryableButton, {
      label: formatMessage(messages.deleteEmojiLabel),
      onSubmit: this.onSubmit,
      appearance: "danger",
      loading: loading,
      error: error,
      ariaLabelledBy: `${emojiErrorScreenreaderTestId} ${deleteEmojiLabelId}`
    }), jsx(AkButton, {
      appearance: "subtle",
      onClick: this.onCancel
    }, jsx(FormattedMessage, messages.cancelLabel))))));
  }
}
export default injectIntl(EmojiDeletePreview);