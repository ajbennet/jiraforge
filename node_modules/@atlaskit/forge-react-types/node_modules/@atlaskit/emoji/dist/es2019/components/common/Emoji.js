import _extends from "@babel/runtime/helpers/extends";
/**
 * @jsxRuntime classic
 * @jsx jsx
 */
import React, { useEffect, useCallback, forwardRef } from 'react';
// eslint-disable-next-line @atlaskit/ui-styling-standard/use-compiled -- Ignored via go/DSP-18766
import { jsx } from '@emotion/react';
import Tooltip from '@atlaskit/tooltip';
import { shouldUseAltRepresentation } from '../../api/EmojiUtils';
import { deleteEmojiLabel, EMOJI_KEYBOARD_KEYS_SUPPORTED, KeyboardKeys, SAMPLING_RATE_EMOJI_RENDERED_EXP } from '../../util/constants';
import { isImageRepresentation, isMediaRepresentation, isSpriteRepresentation, toEmojiId } from '../../util/type-helpers';
import { UfoEmojiTimings } from '../../types';
import { leftClick } from '../../util/mouse';
import DeleteButton from './DeleteButton';
import { emojiSpriteContainer, emojiNodeStyles, commonSelectedStyles, selectOnHoverStyles, emojiSprite, emojiMainStyle, emojiImageContainer, emojiImage, deletableEmoji } from './styles';
import { sampledUfoRenderedEmoji, ufoExperiences, useSampledUFOComponentExperience } from '../../util/analytics';
import browserSupport from '../../util/browser-support';
import { useInView } from '../../hooks/useInView';
import { hasUfoMarked } from '../../util/analytics/ufoExperiences';
import { DeletableEmojiTooltipContent, DeletableEmojiTooltipContentForScreenReader } from './DeletableEmojiTooltipContent';
import { isSSR } from '../../util/is-ssr';
const handleMouseDown = (props, event) => {
  // Clicked emoji delete button
  if (event.target instanceof Element && event.target.getAttribute('aria-label') === deleteEmojiLabel) {
    return;
  }
  const {
    emoji,
    onSelected
  } = props;
  if (onSelected && leftClick(event)) {
    onSelected(toEmojiId(emoji), emoji, event);
  }
};
const handleKeyDown = (props, event) => {
  if (!EMOJI_KEYBOARD_KEYS_SUPPORTED.includes(event.key)) {
    return;
  }
  event.preventDefault();
  event.stopPropagation();
  const {
    emoji,
    onSelected,
    showDelete
  } = props;
  if (onSelected && (event.key === KeyboardKeys.Enter || event.key === KeyboardKeys.Space)) {
    onSelected(toEmojiId(emoji), emoji, event);
  }
  if (showDelete && event.key === KeyboardKeys.Backspace) {
    handleDelete(props, event);
  }
};
const handleMouseMove = (props, event) => {
  const {
    emoji,
    onMouseMove
  } = props;
  if (onMouseMove) {
    onMouseMove(toEmojiId(emoji), emoji, event);
  }
};
const handleFocus = (props, event) => {
  const {
    emoji,
    onFocus
  } = props;
  if (onFocus) {
    onFocus(toEmojiId(emoji), emoji, event);
  }
};
const handleDelete = (props, event) => {
  const {
    emoji,
    onDelete
  } = props;
  if (onDelete) {
    onDelete(toEmojiId(emoji), emoji, event);
  }
};
const handleImageError = (props, event) => {
  const {
    emoji,
    onLoadError
  } = props;

  // Hide error state (but keep space for it)
  if (event.target) {
    const target = event.target;
    target.style.visibility = 'hidden';
  }
  if (onLoadError) {
    onLoadError(toEmojiId(emoji), emoji, event);
  }
};

// Pure functional components are used in favour of class based components, due to the performance!
// When rendering 1500+ emoji using class based components had a significant impact.
// TODO: add UFO tracking for sprite emoji
export const SpriteEmoji = props => {
  const {
    emoji,
    fitToHeight,
    selected,
    selectOnHover,
    className
  } = props;
  const representation = emoji.representation;
  const sprite = representation.sprite;
  const classes = `${emojiNodeStyles} ${selected ? commonSelectedStyles : ''} ${selectOnHover ? selectOnHoverStyles : ''} ${className ? className : ''}`;
  let sizing = {};
  if (fitToHeight) {
    sizing = {
      width: `${fitToHeight}px`,
      height: `${fitToHeight}px`,
      minHeight: `${fitToHeight}px`,
      minWidth: `${fitToHeight}px`
    };
  }
  const xPositionInPercent = 100 / (sprite.column - 1) * (representation.xIndex - 0);
  const yPositionInPercent = 100 / (sprite.row - 1) * (representation.yIndex - 0);
  const style = {
    backgroundImage: `url(${sprite.url})`,
    backgroundPosition: `${xPositionInPercent}% ${yPositionInPercent}%`,
    backgroundSize: `${sprite.column * 100}% ${sprite.row * 100}%`,
    ...sizing
  };
  return (
    // eslint-disable-next-line @atlaskit/ui-styling-standard/no-classname-prop -- Ignored via go/DSP-18766
    jsx(EmojiNodeWrapper, _extends({}, props, {
      type: "sprite",
      className: classes
    }), jsx("span", {
      className: emojiSprite,
      style: style
    }))
  );
};

// Keep as pure functional component, see renderAsSprite.
export const ImageEmoji = props => {
  const {
    emoji,
    fitToHeight,
    selected,
    selectOnHover,
    className,
    showDelete,
    onLoadSuccess,
    disableLazyLoad,
    autoWidth
  } = props;
  const [ref, inView] = useInView({
    triggerOnce: true
  });
  const ufoExp = sampledUfoRenderedEmoji(emoji);
  const classes = `${emojiMainStyle} ${emojiNodeStyles} ${selected ? commonSelectedStyles : ''} ${selectOnHover ? selectOnHoverStyles : ''} ${emojiImage} ${className ? className : ''} ${showDelete ? deletableEmoji : ''}`;
  let width;
  let height;
  let src;
  const representation = shouldUseAltRepresentation(emoji, fitToHeight) ? emoji.altRepresentation : emoji.representation;
  if (isImageRepresentation(representation)) {
    src = representation.imagePath;
    width = representation.width;
    height = representation.height;
  } else if (isMediaRepresentation(representation)) {
    src = representation.mediaPath;
    width = representation.width;
    height = representation.height;
  }
  let sizing = {};
  if (fitToHeight && width && height) {
    // Presize image, to prevent reflow due to size changes after loading
    sizing = {
      // Size of <img> needs to be deterministic when rendered on server-side. Auto will cause width to be 0 before image is loaded.
      width: autoWidth && !isSSR() ? 'auto' : fitToHeight / height * width,
      height: fitToHeight
    };
  }
  const onError = event => {
    handleImageError(props, event);
  };
  const onLoad = () => {
    const mountedMark = ufoExp.metrics.marks.find(mark => mark.name === UfoEmojiTimings.MOUNTED_END);
    // onload could trigger before onBeforeLoad when emojis in viewport at start, so we need to mark onload start manually.
    if (!hasUfoMarked(ufoExp, UfoEmojiTimings.ONLOAD_START)) {
      ufoExp.mark(UfoEmojiTimings.ONLOAD_START, mountedMark === null || mountedMark === void 0 ? void 0 : mountedMark.time);
    }
    const loadedStartMark = ufoExp.metrics.marks.find(mark => mark.name === UfoEmojiTimings.ONLOAD_START);
    if (mountedMark && loadedStartMark) {
      ufoExp.addMetadata({
        lazyLoad: loadedStartMark.time > mountedMark.time
      });
    }
    // onload_start
    if (!hasUfoMarked(ufoExp, UfoEmojiTimings.ONLOAD_END)) {
      ufoExp.mark(UfoEmojiTimings.ONLOAD_END);
    }
    ufoExp.success({
      metadata: {
        IBSupported: browserSupport.supportsIntersectionObserver
      }
    });
    if (onLoadSuccess) {
      onLoadSuccess(emoji);
    }
  };
  const onBeforeLoad = useCallback(() => {
    if (!hasUfoMarked(ufoExp, UfoEmojiTimings.ONLOAD_START)) {
      ufoExp.mark(UfoEmojiTimings.ONLOAD_START);
    }
  }, [ufoExp]);

  // because of the lack of browser support of on before load natively, used IntersectionObserver helper hook to mimic the before load time mark for UFO.
  useEffect(() => {
    if (inView) {
      onBeforeLoad();
    }
  }, [inView, onBeforeLoad]);
  const emojiNode = jsx("img", _extends({
    //@ts-ignore
    loading: disableLazyLoad ? 'eager' : 'lazy',
    src: src,
    key: src,
    alt: emoji.name || emoji.shortName,
    "data-emoji-short-name": emoji.shortName,
    "data-emoji-id": emoji.id,
    "data-emoji-text": emoji.fallback || emoji.shortName
    // eslint-disable-next-line @atlaskit/ui-styling-standard/no-classname-prop -- Ignored via go/DSP-18766
    ,
    className: "emoji"
    // eslint-disable-next-line @atlaskit/ui-styling-standard/enforce-style-prop -- Ignored via go/DSP-18766
    ,
    style: {
      visibility: 'visible'
    },
    onError: onError,
    onLoad: onLoad
  }, sizing, {
    "data-vc": "emoji"
  }));

  // show a tooltip for deletable emoji only on focus
  if (showDelete) {
    return jsx(Tooltip, {
      content: jsx(DeletableEmojiTooltipContent, null),
      position: "right-start",
      tag: "span"
    }, jsx(EmojiNodeWrapper, _extends({}, props, {
      "aria-labelledby": `screenreader-emoji-${emoji.id}`,
      type: "image"
      // eslint-disable-next-line @atlaskit/ui-styling-standard/no-classname-prop -- Ignored via go/DSP-18766
      ,
      className: classes,
      ref: ref,
      showTooltip: false // avoid showing both tooltip and title
      ,
      onMouseOver: e => {
        var _document$activeEleme;
        // only disable tooltip when not on focus
        if (!((_document$activeEleme = document.activeElement) !== null && _document$activeEleme !== void 0 && _document$activeEleme.contains(e.target))) {
          e.stopPropagation();
        }
      }
    }), emojiNode, jsx(DeleteButton, {
      onClick: event => handleDelete(props, event)
    }), jsx(DeletableEmojiTooltipContentForScreenReader, {
      emoji: emoji
    })));
  }
  return (
    // eslint-disable-next-line @atlaskit/ui-styling-standard/no-classname-prop -- Ignored via go/DSP-18766
    jsx(EmojiNodeWrapper, _extends({}, props, {
      type: "image",
      className: classes,
      ref: ref
    }), emojiNode)
  );
};
export const EmojiNodeWrapper = /*#__PURE__*/forwardRef((props, ref) => {
  const {
    emoji,
    fitToHeight,
    selected,
    selectOnHover,
    className,
    showTooltip,
    showDelete,
    shouldBeInteractive = false,
    tabIndex,
    onSelected,
    onMouseMove,
    onFocus,
    onDelete,
    onLoadError,
    onLoadSuccess,
    disableLazyLoad,
    autoWidth,
    children,
    type,
    editorEmoji,
    ...other
  } = props;
  let accessibilityProps;
  if (editorEmoji) {
    accessibilityProps = {
      role: undefined
    };
  } else if (shouldBeInteractive) {
    accessibilityProps = {
      role: 'button',
      'aria-label': emoji.shortName
    };
  } else {
    accessibilityProps = {
      role: 'img',
      'aria-label': emoji.shortName
    };
  }
  return (
    // eslint-disable-next-line jsx-a11y/no-static-element-interactions
    jsx("span", _extends({}, accessibilityProps, {
      ref: ref,
      "data-testid": `${type}-emoji-${emoji.shortName}`,
      "data-emoji-type": type,
      tabIndex: shouldBeInteractive ? tabIndex || 0 : undefined
      // eslint-disable-next-line @atlaskit/design-system/consistent-css-prop-usage, @atlaskit/ui-styling-standard/no-imported-style-values -- Ignored via go/DSP-18766
      ,
      css: type === 'sprite' ? emojiSpriteContainer : emojiImageContainer
      // eslint-disable-next-line @atlaskit/ui-styling-standard/no-classname-prop -- Ignored via go/DSP-18766
      ,
      className: className,
      onKeyDown: event => handleKeyDown(props, event),
      onMouseDown: event => {
        handleMouseDown(props, event);
      },
      onMouseEnter: event => {
        handleMouseMove(props, event);
      },
      onFocus: event => {
        handleFocus(props, event);
      },
      title: showTooltip ? emoji.shortName : undefined // TODO: COLLAB-2351 - use @atlaskit/Tooltip in future for non-deletable emoji if enabled showTooltip
    }, other), children)
  );
});
export const Emoji = props => {
  const {
    emoji
  } = props;
  // start emoji rendered experience, it may have already started earlier in ResourcedEmoji or CachingEmoji
  useSampledUFOComponentExperience(ufoExperiences['emoji-rendered'].getInstance(emoji.id || emoji.shortName), SAMPLING_RATE_EMOJI_RENDERED_EXP, {
    source: 'Emoji',
    emojiId: emoji.id
  });
  useEffect(() => {
    const ufoExp = sampledUfoRenderedEmoji(emoji);
    if (!hasUfoMarked(ufoExp, 'fmp')) {
      ufoExp.markFMP();
    }
    if (!hasUfoMarked(ufoExp, UfoEmojiTimings.MOUNTED_END)) {
      ufoExp.mark(UfoEmojiTimings.MOUNTED_END);
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);
  // TODO: We always prefer render as image as having accessibility issues with sprite representation
  if (isSpriteRepresentation(emoji.representation)) {
    return jsx(SpriteEmoji, props);
  }
  return jsx(ImageEmoji, props);
};
export default Emoji;