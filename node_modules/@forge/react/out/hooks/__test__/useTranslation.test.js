"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const jsx_runtime_1 = require("react/jsx-runtime");
const mockGetContext = jest.fn(async () => null);
const mockI18nCreateTranslationFunction = jest.fn(async () => jest.fn());
const reconcilerTestRenderer_1 = tslib_1.__importDefault(require("../../__test__/reconcilerTestRenderer"));
const testUtils_1 = require("../../__test__/testUtils");
const useTranslation_1 = require("../useTranslation");
const components_1 = require("../../components");
mockGetContext.mockResolvedValue({
    locale: 'en-US'
});
jest.mock('@forge/bridge', () => ({
    view: {
        getContext: mockGetContext
    },
    i18n: {
        createTranslationFunction: mockI18nCreateTranslationFunction
    }
}));
describe('useTranslation', () => {
    let bridgeCalls = [];
    beforeAll(async () => {
        bridgeCalls = (0, testUtils_1.setupBridge)();
    });
    it('should provide default context function when not ready', async () => {
        mockI18nCreateTranslationFunction.mockImplementation(async () => {
            await new Promise((res) => setTimeout(res, 1000));
            return jest.fn();
        });
        const TestComponent = () => {
            const { ready, t } = (0, useTranslation_1.useTranslation)();
            return ((0, jsx_runtime_1.jsxs)(jsx_runtime_1.Fragment, { children: [(0, jsx_runtime_1.jsx)(components_1.Text, { children: ready ? 'ready' : 'not ready' }), (0, jsx_runtime_1.jsx)(components_1.Text, { children: t('test.key') })] }));
        };
        const Test = () => {
            return ((0, jsx_runtime_1.jsx)(useTranslation_1.I18nProvider, { children: (0, jsx_runtime_1.jsx)(TestComponent, {}) }));
        };
        await reconcilerTestRenderer_1.default.create((0, jsx_runtime_1.jsx)(Test, {}));
        const forgeDoc = (0, testUtils_1.getLastBridgeCallForgeDoc)(bridgeCalls);
        expect(mockI18nCreateTranslationFunction).toHaveBeenCalledWith('en-US');
        expect(forgeDoc).toHaveProperty('children[0].children[0].props.text', 'not ready');
        expect(forgeDoc).toHaveProperty('children[1].children[0].props.text', 'test.key');
    });
    it('should provide resolved translation function when ready', async () => {
        const mockTranslationFunction = jest.fn();
        mockTranslationFunction.mockReturnValue('test value');
        mockI18nCreateTranslationFunction.mockResolvedValue(mockTranslationFunction);
        const TestComponent = () => {
            const { ready, t } = (0, useTranslation_1.useTranslation)();
            return ((0, jsx_runtime_1.jsxs)(jsx_runtime_1.Fragment, { children: [(0, jsx_runtime_1.jsx)(components_1.Text, { children: ready ? 'ready' : 'not ready' }), (0, jsx_runtime_1.jsx)(components_1.Text, { children: t('test.key') })] }));
        };
        const Test = () => {
            return ((0, jsx_runtime_1.jsx)(useTranslation_1.I18nProvider, { children: (0, jsx_runtime_1.jsx)(TestComponent, {}) }));
        };
        await reconcilerTestRenderer_1.default.create((0, jsx_runtime_1.jsx)(Test, {}));
        const forgeDoc = (0, testUtils_1.getLastBridgeCallForgeDoc)(bridgeCalls);
        expect(mockI18nCreateTranslationFunction).toHaveBeenCalledWith('en-US');
        expect(mockTranslationFunction).toHaveBeenCalledWith('test.key');
        expect(forgeDoc).toHaveProperty('children[0].children[0].props.text', 'ready');
        expect(forgeDoc).toHaveProperty('children[1].children[0].props.text', 'test value');
    });
    it('should use locale specified from the Provider', async () => {
        const mockTranslationFunction = jest.fn();
        mockTranslationFunction.mockReturnValue('test value');
        mockI18nCreateTranslationFunction.mockResolvedValue(mockTranslationFunction);
        const customLocale = 'zh-CN';
        const TestComponent = () => {
            const { ready, t } = (0, useTranslation_1.useTranslation)();
            return ((0, jsx_runtime_1.jsxs)(jsx_runtime_1.Fragment, { children: [(0, jsx_runtime_1.jsx)(components_1.Text, { children: ready ? 'ready' : 'not ready' }), (0, jsx_runtime_1.jsx)(components_1.Text, { children: t('test.key') })] }));
        };
        const Test = () => {
            return ((0, jsx_runtime_1.jsx)(useTranslation_1.I18nProvider, { locale: customLocale, children: (0, jsx_runtime_1.jsx)(TestComponent, {}) }));
        };
        await reconcilerTestRenderer_1.default.create((0, jsx_runtime_1.jsx)(Test, {}));
        const forgeDoc = (0, testUtils_1.getLastBridgeCallForgeDoc)(bridgeCalls);
        expect(mockI18nCreateTranslationFunction).toHaveBeenCalledWith(customLocale);
        expect(mockTranslationFunction).toHaveBeenCalledWith('test.key');
        expect(forgeDoc).toHaveProperty('children[0].children[0].props.text', 'ready');
        expect(forgeDoc).toHaveProperty('children[1].children[0].props.text', 'test value');
    });
    it('should use default context if Provider is not used', async () => {
        const TestComponent = () => {
            const { ready, t } = (0, useTranslation_1.useTranslation)();
            return ((0, jsx_runtime_1.jsxs)(jsx_runtime_1.Fragment, { children: [(0, jsx_runtime_1.jsx)(components_1.Text, { children: ready ? 'ready' : 'not ready' }), (0, jsx_runtime_1.jsx)(components_1.Text, { children: t('test.key') })] }));
        };
        const Test = () => {
            return (0, jsx_runtime_1.jsx)(TestComponent, {});
        };
        await reconcilerTestRenderer_1.default.create((0, jsx_runtime_1.jsx)(Test, {}));
        const forgeDoc = (0, testUtils_1.getLastBridgeCallForgeDoc)(bridgeCalls);
        expect(forgeDoc).toHaveProperty('children[0].children[0].props.text', 'not ready');
        expect(forgeDoc).toHaveProperty('children[1].children[0].props.text', 'test.key');
    });
});
