"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const jsx_runtime_1 = require("react/jsx-runtime");
const react_1 = tslib_1.__importStar(require("react"));
const components_1 = require("../../components");
const reconcilerTestRenderer_1 = tslib_1.__importDefault(require("../reconcilerTestRenderer"));
const testUtils_1 = require("../testUtils");
const get_1 = tslib_1.__importDefault(require("lodash/get"));
describe('InlineEdit', () => {
    let bridgeCalls = [];
    const onConfirmMock = jest.fn();
    const validateMock = jest.fn();
    const onEditMock = jest.fn();
    const onCancelMock = jest.fn();
    const validation = (value) => {
        validateMock(value);
        if (value.length < 3) {
            return 'Value must be at least 3 characters long';
        }
        return undefined;
    };
    beforeEach(async () => {
        bridgeCalls = (0, testUtils_1.setupBridge)();
        const Test = () => {
            const [editValue, setEditValue] = (0, react_1.useState)('test');
            return ((0, jsx_runtime_1.jsx)(react_1.default.Fragment, { children: (0, jsx_runtime_1.jsx)(components_1.InlineEdit, { onEdit: onEditMock, onCancel: onCancelMock, validate: validation, editView: ({ errorMessage, value, ...fieldProps }) => ((0, jsx_runtime_1.jsxs)(jsx_runtime_1.Fragment, { children: [(0, jsx_runtime_1.jsx)(components_1.Textfield, { value: value, ...fieldProps }), (0, jsx_runtime_1.jsx)(components_1.Text, { children: errorMessage })] })), readView: () => (0, jsx_runtime_1.jsx)(components_1.Text, { children: editValue }), defaultValue: editValue, onConfirm: (value) => {
                        onConfirmMock(value);
                        setEditValue(value);
                    } }) }));
        };
        await reconcilerTestRenderer_1.default.create((0, jsx_runtime_1.jsx)(Test, {}));
    });
    it('readView and editView is passed in the forgeDoc', () => {
        const forgeDoc = (0, testUtils_1.getLastBridgeCallForgeDoc)(bridgeCalls);
        const editViewComponent = (0, get_1.default)(forgeDoc, 'children[0].children[0].children[0].type');
        const readViewText = (0, get_1.default)(forgeDoc, 'children[0].children[1].children[0].children[0].props.text');
        expect(editViewComponent).toBe('Textfield');
        expect(readViewText).toBe('test');
    });
    it('onConfirm is called with the correct value', () => {
        const forgeDoc = (0, testUtils_1.getLastBridgeCallForgeDoc)(bridgeCalls);
        const onConfirm = (0, get_1.default)(forgeDoc, 'children[0].props.onConfirm');
        onConfirm();
        expect(onConfirmMock).toHaveBeenCalledWith('test');
        expect(validateMock).toHaveBeenCalledWith('test');
    });
    it('onChange triggers validation', () => {
        const forgeDoc = (0, testUtils_1.getLastBridgeCallForgeDoc)(bridgeCalls);
        const onChange = (0, get_1.default)(forgeDoc, 'children[0].children[0].children[0].props.onChange');
        onChange('value change');
        expect(validateMock).toHaveBeenCalledWith('value change');
    });
    it('validation is called and fails', () => {
        const forgeDoc = (0, testUtils_1.getLastBridgeCallForgeDoc)(bridgeCalls);
        const onChange = (0, get_1.default)(forgeDoc, 'children[0].children[0].children[0].props.onChange');
        onChange('f');
        const errorText = (0, get_1.default)(forgeDoc, 'children[0].children[0].children[1].children[0].props.text');
        expect(errorText).toBe('Value must be at least 3 characters long');
    });
    it('clears errorMessage and switches to edit mode when onEdit is called', () => {
        const forgeDoc = (0, testUtils_1.getLastBridgeCallForgeDoc)(bridgeCalls);
        const onEdit = (0, get_1.default)(forgeDoc, 'children[0].props.onEdit');
        onEdit();
        const errorText = (0, get_1.default)(forgeDoc, 'children[0].children[0].children[1].children[0].props.text');
        expect(errorText).toBe(undefined);
        const isEditing = (0, get_1.default)(forgeDoc, 'children[0].props.isEditing');
        expect(isEditing).toBe(true);
    });
    it('switches back to read mode when onCancel is called', () => {
        const forgeDoc = (0, testUtils_1.getLastBridgeCallForgeDoc)(bridgeCalls);
        const onEdit = (0, get_1.default)(forgeDoc, 'children[0].props.onEdit');
        onEdit();
        let isEditing = (0, get_1.default)(forgeDoc, 'children[0].props.isEditing');
        expect(isEditing).toBe(true);
        // Text update
        const onChange = (0, get_1.default)(forgeDoc, 'children[0].children[0].children[0].props.onChange');
        onChange('value change');
        // Cancel is called
        const onCancel = (0, get_1.default)(forgeDoc, 'children[0].props.onCancel');
        onCancel();
        isEditing = (0, get_1.default)(forgeDoc, 'children[0].props.isEditing');
        expect(isEditing).toBe(false);
        // Text should revert to previous value
        const valueText = (0, get_1.default)(forgeDoc, 'children[0].children[1].children[0].children[0].props.text');
        expect(valueText).toBe('test');
    });
});
